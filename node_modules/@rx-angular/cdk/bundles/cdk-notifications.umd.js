(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('rxjs/operators'), require('@rx-angular/cdk/coercing')) :
    typeof define === 'function' && define.amd ? define('@rx-angular/cdk/notifications', ['exports', 'rxjs', 'rxjs/operators', '@rx-angular/cdk/coercing'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['rx-angular'] = global['rx-angular'] || {}, global['rx-angular']['cdk-notifications'] = {}), global.rxjs, global.rxjs.operators, global['rx-angular']['cdk-coercing']));
}(this, (function (exports, rxjs, operators, coercing) { 'use strict';

    function toRxErrorNotification(error, value) {
        return {
            value: value,
            kind: "error" /* Error */,
            hasValue: !!value || false,
            complete: false,
            error: error || true,
        };
    }
    function toRxSuspenseNotification(value) {
        return {
            value: value,
            kind: "suspense" /* Suspense */,
            hasValue: !!value || false,
            complete: false,
            error: false,
        };
    }
    function toRxCompleteNotification(value) {
        return {
            value: value,
            kind: "complete" /* Complete */,
            hasValue: !!value || false,
            complete: true,
            error: false,
        };
    }

    /**
     * @internal
     *
     * A factory function returning an object to handle the process of switching templates by Notification channel.
     * You can next a Observable of `RxNotification` multiple times and merge them into the Observable exposed under `trigger$`
     *
     */
    function templateTriggerHandling() {
        var hotFlattened = coercing.coerceAllFactory(function () { return new rxjs.Subject(); }, operators.mergeAll());
        return {
            next: function (templateName) {
                hotFlattened.next(templateName);
            },
            trigger$: hotFlattened.values$.pipe(operators.share()),
        };
    }

    function rxMaterialize() {
        return function (o$) { return o$.pipe(operators.materialize(), operators.tap(function (_a) {
            var kind = _a.kind, error = _a.error;
            // As we dont want to just swallow errors we log them here
            if (kind === 'E') {
                console.error(error);
            }
        }), operators.map(function (_a) {
            var value = _a.value, error = _a.error, kind = _a.kind;
            var rxNotificationKind = notificationKindToRxNotificationKind(kind);
            return {
                value: value,
                hasValue: kind === 'N',
                error: error,
                kind: rxNotificationKind,
                complete: rxNotificationKind === "complete" /* Complete */,
            };
        })); };
    }
    /**
     * @internal
     *
     * @description
     * This function is here to turn RxJS notification kind values into RxNotification kind names.
     * The main reason for the naming is the RxNotification kind values map directly to the default
     * template names (`suspense`, `next`, `error` `complete`) in the directives of the template package
     */
    function notificationKindToRxNotificationKind(kind) {
        switch (kind) {
            case 'C':
                return "complete" /* Complete */;
            case 'E':
                return "error" /* Error */;
            case 'N':
            default:
                return "next" /* Next */;
        }
    }

    var calcWithSuspenseTpl = function (withSuspenseTpl) { return withSuspenseTpl && withSuspenseTpl(); };
    var ɵ0 = calcWithSuspenseTpl;
    /**
     * @description
     * Sends value and an initial `undefined` as value With a NEVER.
     * This is needed to render the suspense template and avoid completing (and render the complete template).
     * @param value
     */
    var emitAndDontComplete = function (value) { return rxjs.NEVER.pipe(operators.startWith(value)); };
    var ɵ1 = emitAndDontComplete;
    /**
    * @description
    * Flags the first run.
    * This is important as we want to create laziness in the template.
    * If no value ever is emitted we dont want to create/render the value (next template).
    * In case a suspense template is given (calculated by `withSuspense` param) we render the suspense template on the first run.
    */
    var mapFirst = function (transformation) { return function (o$) {
        var firstRun = true;
        return o$.pipe(operators.map(function (value) {
            if (!firstRun) {
                return value;
            }
            var result = transformation(value);
            firstRun = false;
            return result;
        }));
    }; };
    var ɵ2 = mapFirst;
    /**
     * This helper is responsible for turning a stream of materialized notifications
     * (next error, complete as object in the next stream) into an enriched version with an additional suspense notification type.
     *
     * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.
     * This value is important in the template to show an e.g. error and also have access to the last emitted value of next.
     * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner in case of the suspense state.
     *
     * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification
     * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification
     * and assign it as new value to the notification
     */
    var handleSuspenseAndLastValueInNotifications = function () {
        // Used to store the last value per handleSuspenseAndLastValueInNotifications call
        var latestNextValue;
        // returns a projection function with a lastValue cache
        return function (notification) {
            // if it the notification is of type next we take its value
            // otherwise we keep the existing last value
            if (notification.kind === "next" /* Next */) {
                latestNextValue = notification.value;
            }
            // If a next notification enters with a value of undefined we turn it into a suspense notification
            if (notification.kind === "next" /* Next */ &&
                notification.value === undefined) {
                return toRxSuspenseNotification(undefined);
            }
            // If a Notification of type error, complete or suspense enters we assign the latest last value to them.
            // This is needed to access the old value in case of error or complete.
            // Next notifications will pass as they are.
            if (notification.kind === "error" /* Error */ ||
                notification.kind === "complete" /* Complete */ ||
                notification.kind === "suspense" /* Suspense */) {
                notification.value = latestNextValue;
            }
            return notification;
        };
    };
    var ɵ3 = handleSuspenseAndLastValueInNotifications;
    /**
     * @internal
     *
     * @description
     * This factory function returns an object that can be driven imperatively over a `next` method.
     * Internally it prepares the incoming values for rendering by turning them into "template notifications",
     * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing or suspense states.
     *
     * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.
     * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the display of
     * the default template as well as the suspense, error, complete templates.
     */
    function createTemplateNotifier(withSuspenseTpl) {
        // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties
        var observablesSubject = new rxjs.ReplaySubject(1);
        var values$ = observablesSubject.pipe(operators.distinctUntilChanged(), 
        // Handle initialization edge cases
        mapFirst(function (value) {
            var isUndefined = value === undefined;
            var isNEVER = value === rxjs.NEVER;
            // If it is a `NEVER` Observable we know it will never emit a value nor complete or error.
            // Therefore we emit directly undefined to signal a suspense state
            if ((isUndefined || isNEVER)) {
                // Determines if a suspense notification is needed
                var isSuspenseTemplateGiven = calcWithSuspenseTpl(withSuspenseTpl);
                // Render suspense template if given. Otherwise do nothing (later undefined are filtered out)
                return isSuspenseTemplateGiven ? emitAndDontComplete(undefined) : undefined;
            }
            var isNull = value === null;
            if (isNull) {
                // We return the value and no undefined as first value
                // as we dont need to render the suspense template for null values (it is considered as not used)
                return rxjs.of(null);
            }
            return value;
        }), 
        // `undefined` values are only processed once at beginning to initialize lazy. After that they are filtered out.
        operators.filter(function (v) { return v !== undefined; }), 
        // handle static values inc null assignment and new Observable or Promises
        operators.map(function (observable$) {
            var isNull = observable$ === null;
            var isPromiseOrObs = typeof observable$.then === 'function' || rxjs.isObservable(observable$);
            // A value is considered as static value if it is `null`, or any other value than `undefined`, `Promise`, `Observable`
            var isStaticValue = !isPromiseOrObs && !(observable$ === undefined) || isNull;
            var isNEVER = observable$ === rxjs.NEVER;
            // If it is a `NEVER` Observable we know it will never emit a value nor complete or error.
            // Therefore we emit directly undefined to signal a suspense state
            if (isNEVER) {
                // Render suspense template for null values (it is considered as not used)
                return emitAndDontComplete(undefined);
            }
            // If it is a static value forward directly
            if (isStaticValue) {
                // Render next template for static values (it is considered as kinda sync)
                return emitAndDontComplete(observable$);
            }
            return rxjs.from(observable$).pipe(function (o$) {
                // Determines if a suspense notification is needed
                var isSuspenseTemplateGiven = calcWithSuspenseTpl(withSuspenseTpl);
                if (isSuspenseTemplateGiven) {
                    // Render suspense template
                    return o$.pipe(operators.startWith(undefined));
                }
                return o$;
            });
        }), operators.switchMap(function (o) {
            return o.pipe(operators.distinctUntilChanged(), rxMaterialize(), operators.map(handleSuspenseAndLastValueInNotifications()));
        }));
        return {
            next: function (observable) {
                observablesSubject.next(observable);
            },
            values$: values$,
        };
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.createTemplateNotifier = createTemplateNotifier;
    exports.rxMaterialize = rxMaterialize;
    exports.templateTriggerHandling = templateTriggerHandling;
    exports.toRxCompleteNotification = toRxCompleteNotification;
    exports.toRxErrorNotification = toRxErrorNotification;
    exports.toRxSuspenseNotification = toRxSuspenseNotification;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=cdk-notifications.umd.js.map
