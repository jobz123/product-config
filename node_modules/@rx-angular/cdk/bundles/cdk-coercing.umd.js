(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@rx-angular/cdk/coercing', ['exports', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['rx-angular'] = global['rx-angular'] || {}, global['rx-angular']['cdk-coercing'] = {}), global.rxjs, global.rxjs.operators));
}(this, (function (exports, rxjs, operators) { 'use strict';

    /**
     * This Observable factory creates an Observable out of a static value or ObservableInput.
     *
     * @param o - the value to coerce
     */
    function coerceObservable(o) {
        return rxjs.isObservable(o) ? o : rxjs.of(o);
    }

    /**
     * This operator maps an Observable out of a static value or ObservableInput.
     *
     */
    function coerceObservableWith() {
        return function (o$) { return operators.map(coerceObservable)(o$); };
    }

    /**
     * This Observable factory creates an Observable out of a static value or ObservableInput.
     * It forwards only distinct values from distinct incoming Observables or values.
     * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.
     *
     * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll
     *
     * @param o$ - The Observable to coerce and map to a Observable with distinct values
     * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll
     */
    function coerceDistinctObservable(o$, flattenOperator) {
        flattenOperator = flattenOperator || operators.switchAll();
        return coerceObservable(o$).pipe(operators.distinctUntilChanged(), flattenOperator, operators.distinctUntilChanged());
    }

    /**
     * This operator takes an Observable of values ot Observables aof values and
     * It forwards only distinct values from distinct incoming Observables or values.
     * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.
     *
     * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll
     *
     * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll
     *
     */
    function coerceDistinctWith(flattenOperator) {
        flattenOperator = flattenOperator || operators.switchAll();
        return function (o$) { return o$.pipe(coerceObservableWith(), operators.distinctUntilChanged(), flattenOperator, operators.distinctUntilChanged()); };
    }

    /**
     * @internal
     *
     * A factory function returning an object to handle the process of merging Observable next notifications into one
     *   Observable. This API takes away the clumsy handling of static values and Observable, reduces the number of
     *   emissions by:
     * - only merging distinct Observables
     * - only emit distingt values of the merged result
     *
     * You can next a Observable of `U` multiple times and merge them into the Observable exposed under one optimized
     *   `values$`
     *
     */
    function coerceAllFactory(subjectFactory, flattenOperator) {
        var observablesSubject = subjectFactory ? subjectFactory() : new rxjs.Subject();
        flattenOperator = flattenOperator || operators.switchAll();
        var values$ = observablesSubject.pipe(coerceDistinctWith(flattenOperator));
        return {
            next: function (observable) {
                observablesSubject.next(observable);
            },
            values$: values$,
        };
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.coerceAllFactory = coerceAllFactory;
    exports.coerceDistinctObservable = coerceDistinctObservable;
    exports.coerceDistinctWith = coerceDistinctWith;
    exports.coerceObservable = coerceObservable;
    exports.coerceObservableWith = coerceObservableWith;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=cdk-coercing.umd.js.map
