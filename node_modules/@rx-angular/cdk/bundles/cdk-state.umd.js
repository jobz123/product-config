(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@rx-angular/cdk/coalescing'), require('@rx-angular/cdk/zone-less'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@rx-angular/cdk/state', ['exports', '@rx-angular/cdk/coalescing', '@rx-angular/cdk/zone-less', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['rx-angular'] = global['rx-angular'] || {}, global['rx-angular']['cdk-state'] = {}), global['rx-angular'].cdk.coalescing, global['rx-angular']['cdk-zone-less'], global.rxjs, global.rxjs.operators));
}(this, (function (exports, coalescing, zoneLess, rxjs, operators) { 'use strict';

    var resolvedPromise = zoneLess.Promise.resolve();
    var resolvedPromise$ = rxjs.from(resolvedPromise);
    /**
     * @internal
     *
     * Used for typing
     */
    function getEntriesToObjectReducerFn(keys) {
        return function (accumulator, currentValue, currentIndex) {
            var _a;
            return Object.assign(Object.assign({}, accumulator), (_a = {}, _a[keys[currentIndex]] = currentValue, _a));
        };
    }
    /**
     * This Observable creation function helps to accumulate an object of key & Observable of values to
     * an Observable of objects of key & value.
     * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.
     *
     * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.
     *
     * @example
     *
     * Default usage:
     *
     * const object$: Observable<{
     *   prop1: number,
     *   prop2: string,
     *   prop3: string
     * }> = accumulateObservables({
     *   prop1: interval(42),
     *   prop2: of('lorem'),
     *   prop3: 'test'
     * });
     *
     * Usage with custom duration selector:
     *
     * const object$: Observable<{
     *   prop1: number,
     *   prop2: string,
     *   prop3: string
     * }> = accumulateObservables({
     *   prop1: interval(42),
     *   prop2: of('lorem'),
     *   prop3: 'test'
     * }, timer(0, 20));
     *
     * @param obj - An object of key & Observable values pairs
     * @param durationSelector - An Observable determining the duration for the internal coalescing method
     */
    function accumulateObservables(
    // @TODO type static or Observable to enable mixing of imperative and reatctive values
    obj, durationSelector) {
        if (durationSelector === void 0) { durationSelector = resolvedPromise$; }
        var keys = Object.keys(obj);
        // @TODO better typing to enable static values => coerceObservable(obj[key])
        var observables = keys.map(function (key) { return obj[key].pipe(
        // we avoid using the nullish operator later ;)
        operators.filter(function (v) { return v !== undefined; }), 
        // state "changes" differ from each other, this operator ensures distinct values
        operators.distinctUntilChanged()); });
        return rxjs.combineLatest(observables).pipe(
        // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions
        // together
        coalescing.coalesceWith(durationSelector), 
        // mapping array of values to object
        operators.map(function (values) { return values.reduce(getEntriesToObjectReducerFn(keys), {}); }), 
        // by using shareReplay we share the last composition work done to create the accumulated object
        operators.shareReplay(1));
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.accumulateObservables = accumulateObservables;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=cdk-state.umd.js.map
