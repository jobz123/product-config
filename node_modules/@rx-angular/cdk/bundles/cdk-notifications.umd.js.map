{"version":3,"file":"cdk-notifications.umd.js","sources":["../../../../libs/cdk/notifications/src/lib/notification-transforms.ts","../../../../libs/cdk/notifications/src/lib/template-trigger-handling.ts","../../../../libs/cdk/notifications/src/lib/rx-materialize.ts","../../../../libs/cdk/notifications/src/lib/create-template-notifier.ts","../../../../libs/cdk/notifications/src/cdk-notifications.ts"],"sourcesContent":["import {\r\n  RxSuspenseNotification,\r\n  RxNotificationKind,\r\n  RxErrorNotification,\r\n  RxCompleteNotification,\r\n} from './model';\r\n\r\nexport function toRxErrorNotification<T>(\r\n  error?: any,\r\n  value?: T\r\n): RxErrorNotification<T> {\r\n  return {\r\n    value,\r\n    kind: RxNotificationKind.Error,\r\n    hasValue: !!value || false,\r\n    complete: false,\r\n    error: error || true,\r\n  };\r\n}\r\n\r\nexport function toRxSuspenseNotification<T>(\r\n  value?: T\r\n): RxSuspenseNotification<T> {\r\n  return {\r\n    value,\r\n    kind: RxNotificationKind.Suspense,\r\n    hasValue: !!value || false,\r\n    complete: false,\r\n    error: false,\r\n  };\r\n}\r\n\r\nexport function toRxCompleteNotification<T>(\r\n  value?: T\r\n): RxCompleteNotification<T> {\r\n  return {\r\n    value,\r\n    kind: RxNotificationKind.Complete,\r\n    hasValue: !!value || false,\r\n    complete: true,\r\n    error: false,\r\n  };\r\n}\r\n","import { Observable, Subject } from 'rxjs';\r\nimport { mergeAll, share } from 'rxjs/operators';\r\n\r\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\r\n\r\nimport { RxNotification } from './model';\r\n\r\n/**\r\n * @internal\r\n *\r\n * A factory function returning an object to handle the process of switching templates by Notification channel.\r\n * You can next a Observable of `RxNotification` multiple times and merge them into the Observable exposed under `trigger$`\r\n *\r\n */\r\nexport function templateTriggerHandling<T>(): {\r\n  trigger$: Observable<RxNotification<T>>;\r\n  next(templateName: Observable<RxNotification<T>>): void;\r\n} {\r\n  const hotFlattened = coerceAllFactory(\r\n    () => new Subject<Observable<RxNotification<T> | RxNotification<T>>>(),\r\n    mergeAll()\r\n  );\r\n  return {\r\n    next(templateName: Observable<RxNotification<T> | RxNotification<T>>) {\r\n      hotFlattened.next(templateName);\r\n    },\r\n    trigger$: hotFlattened.values$.pipe(share()),\r\n  };\r\n}\r\n","import { OperatorFunction, ObservableNotification } from 'rxjs';\r\nimport { map, materialize, tap } from 'rxjs/operators';\r\n\r\nimport { RxNotification, RxNotificationKind } from './model';\r\n\r\nexport function rxMaterialize<T>(): OperatorFunction<T, RxNotification<T>> {\r\n  return (o$) =>\r\n    o$.pipe(\r\n      materialize(),\r\n      tap(({ kind, error }) => {\r\n        // As we dont want to just swallow errors we log them here\r\n        if (kind === 'E') {\r\n          console.error(error);\r\n        }\r\n      }),\r\n      map(({ value, error, kind }) => {\r\n        const rxNotificationKind = notificationKindToRxNotificationKind(kind);\r\n        return {\r\n          value,\r\n          hasValue: kind === 'N',\r\n          error,\r\n          kind: rxNotificationKind,\r\n          complete: rxNotificationKind === RxNotificationKind.Complete,\r\n        };\r\n      })\r\n    );\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * @description\r\n * This function is here to turn RxJS notification kind values into RxNotification kind names.\r\n * The main reason for the naming is the RxNotification kind values map directly to the default\r\n * template names (`suspense`, `next`, `error` `complete`) in the directives of the template package\r\n */\r\nexport function notificationKindToRxNotificationKind(\r\n  kind: ObservableNotification<unknown>['kind']\r\n): RxNotificationKind {\r\n  switch (kind) {\r\n    case 'C':\r\n      return RxNotificationKind.Complete;\r\n    case 'E':\r\n      return RxNotificationKind.Error;\r\n    case 'N':\r\n    default:\r\n      return RxNotificationKind.Next;\r\n  }\r\n}\r\n","import {\r\n  from,\r\n  isObservable,\r\n  NEVER,\r\n  Observable,\r\n  ObservableInput,\r\n  of,\r\n  ReplaySubject\r\n} from 'rxjs';\r\nimport {\r\n  distinctUntilChanged,\r\n  filter,\r\n  map,\r\n  startWith,\r\n  switchMap,\r\n} from 'rxjs/operators';\r\n\r\nimport { rxMaterialize } from './rx-materialize';\r\nimport { RxNotification, RxNotificationKind } from './model';\r\nimport { toRxSuspenseNotification } from './notification-transforms';\r\n\r\nconst calcWithSuspenseTpl = (withSuspenseTpl?: () => boolean): boolean => withSuspenseTpl && withSuspenseTpl();\r\n\r\n/**\r\n * @description\r\n * Sends value and an initial `undefined` as value With a NEVER.\r\n * This is needed to render the suspense template and avoid completing (and render the complete template).\r\n * @param value\r\n */\r\nconst emitAndDontComplete = (value) => NEVER.pipe(startWith(value));\r\n/**\r\n* @description\r\n* Flags the first run.\r\n* This is important as we want to create laziness in the template.\r\n* If no value ever is emitted we dont want to create/render the value (next template).\r\n* In case a suspense template is given (calculated by `withSuspense` param) we render the suspense template on the first run.\r\n*/\r\nconst mapFirst = <T>(transformation: (value: any) => any) => (o$: Observable<T>): Observable<T> => {\r\n  let firstRun = true;\r\n  return o$.pipe(\r\n    map((value) => {\r\n      if(!firstRun) {\r\n        return value;\r\n      }\r\n      const result = transformation(value);\r\n      firstRun = false;\r\n      return result;\r\n    })\r\n  )\r\n}\r\n\r\n/**\r\n * This helper is responsible for turning a stream of materialized notifications\r\n * (next error, complete as object in the next stream) into an enriched version with an additional suspense notification type.\r\n *\r\n * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.\r\n * This value is important in the template to show an e.g. error and also have access to the last emitted value of next.\r\n * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner in case of the suspense state.\r\n *\r\n * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification\r\n * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification\r\n * and assign it as new value to the notification\r\n */\r\nconst handleSuspenseAndLastValueInNotifications = <T>() => {\r\n  // Used to store the last value per handleSuspenseAndLastValueInNotifications call\r\n  let  latestNextValue: T;\r\n\r\n  // returns a projection function with a lastValue cache\r\n  return (notification: RxNotification<T>): RxNotification<T> => {\r\n    // if it the notification is of type next we take its value\r\n    // otherwise we keep the existing last value\r\n    if(notification.kind === RxNotificationKind.Next) {\r\n      latestNextValue = notification.value;\r\n    }\r\n\r\n    // If a next notification enters with a value of undefined we turn it into a suspense notification\r\n    if (\r\n      notification.kind === RxNotificationKind.Next &&\r\n      notification.value === undefined\r\n    ) {\r\n      return toRxSuspenseNotification(undefined) as RxNotification<T>;\r\n    }\r\n\r\n    // If a Notification of type error, complete or suspense enters we assign the latest last value to them.\r\n    // This is needed to access the old value in case of error or complete.\r\n    // Next notifications will pass as they are.\r\n    if(\r\n      notification.kind === RxNotificationKind.Error ||\r\n      notification.kind === RxNotificationKind.Complete ||\r\n      notification.kind === RxNotificationKind.Suspense) {\r\n      notification.value = latestNextValue;\r\n    }\r\n\r\n    return notification as RxNotification<T>;\r\n  }\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * @description\r\n * This factory function returns an object that can be driven imperatively over a `next` method.\r\n * Internally it prepares the incoming values for rendering by turning them into \"template notifications\",\r\n * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing or suspense states.\r\n *\r\n * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.\r\n * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the display of\r\n * the default template as well as the suspense, error, complete templates.\r\n */\r\nexport function createTemplateNotifier<U>(withSuspenseTpl?: () => boolean): {\r\n  values$: Observable<RxNotification<U>>;\r\n  next(observable: ObservableInput<U> | U): void;\r\n} {\r\n  // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties\r\n  const observablesSubject = new ReplaySubject<ObservableInput<U>>(1);\r\n\r\n\r\n  const values$ = observablesSubject.pipe(\r\n    distinctUntilChanged(),\r\n    // Handle initialization edge cases\r\n    mapFirst((value) => {\r\n\r\n      const isUndefined = value === undefined;\r\n        const isNEVER = value === NEVER;\r\n        // If it is a `NEVER` Observable we know it will never emit a value nor complete or error.\r\n        // Therefore we emit directly undefined to signal a suspense state\r\n\r\n      if((isUndefined || isNEVER)) {\r\n        // Determines if a suspense notification is needed\r\n        const isSuspenseTemplateGiven = calcWithSuspenseTpl(withSuspenseTpl);\r\n\r\n        // Render suspense template if given. Otherwise do nothing (later undefined are filtered out)\r\n        return isSuspenseTemplateGiven ? emitAndDontComplete(undefined) : undefined\r\n      }\r\n\r\n      const isNull = value === null;\r\n\r\n      if (isNull) {\r\n        // We return the value and no undefined as first value\r\n        // as we dont need to render the suspense template for null values (it is considered as not used)\r\n        return of(null);\r\n      }\r\n\r\n      return value;\r\n    }),\r\n    // `undefined` values are only processed once at beginning to initialize lazy. After that they are filtered out.\r\n    filter((v) => v !== undefined),\r\n    // handle static values inc null assignment and new Observable or Promises\r\n    map((observable$): Observable<ObservableInput<U> | U> => {\r\n      const isNull = observable$ === null;\r\n      const isPromiseOrObs = typeof (observable$ as any).then === 'function' || isObservable(observable$);\r\n      // A value is considered as static value if it is `null`, or any other value than `undefined`, `Promise`, `Observable`\r\n      const isStaticValue = !isPromiseOrObs && !(observable$ === undefined) || isNull;\r\n\r\n      const isNEVER = observable$ === NEVER;\r\n      // If it is a `NEVER` Observable we know it will never emit a value nor complete or error.\r\n      // Therefore we emit directly undefined to signal a suspense state\r\n      if (isNEVER) {\r\n        // Render suspense template for null values (it is considered as not used)\r\n        return emitAndDontComplete(undefined);\r\n      }\r\n\r\n      // If it is a static value forward directly\r\n      if (isStaticValue) {\r\n        // Render next template for static values (it is considered as kinda sync)\r\n        return emitAndDontComplete(observable$);\r\n      }\r\n\r\n      return from(observable$).pipe(\r\n        (o$) => {\r\n          // Determines if a suspense notification is needed\r\n          const isSuspenseTemplateGiven = calcWithSuspenseTpl(withSuspenseTpl);\r\n\r\n          if (isSuspenseTemplateGiven) {\r\n            // Render suspense template\r\n            return o$.pipe(startWith(undefined));\r\n          }\r\n          return o$;\r\n        }\r\n      );\r\n    }),\r\n    switchMap((o: Observable<U>) => {\r\n      return o.pipe(\r\n        distinctUntilChanged(),\r\n        rxMaterialize(),\r\n        map(handleSuspenseAndLastValueInNotifications<U>())\r\n      );\r\n    })\r\n  );\r\n\r\n  return {\r\n    next(observable: ObservableInput<U>) {\r\n      observablesSubject.next(observable);\r\n    },\r\n    values$,\r\n  };\r\n}\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["coerceAllFactory","Subject","mergeAll","share","materialize","tap","map","NEVER","startWith","ReplaySubject","distinctUntilChanged","of","filter","isObservable","from","switchMap"],"mappings":"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"}