(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@rx-angular/cdk/zone-less', ['exports', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['rx-angular'] = global['rx-angular'] || {}, global['rx-angular']['cdk-zone-less'] = {}), global.ng.core, global.rxjs, global.rxjs.operators));
}(this, (function (exports, core, rxjs, operators) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var rxjs__namespace = /*#__PURE__*/_interopNamespace(rxjs);

    function getZoneUnPatchedApi(targetOrName, name) {
        // If the user has provided the API name as the first argument, for instance:
        // `const addEventListener = getZoneUnPatchedApi('addEventListener');`
        // Then we just swap arguments and make `global` or `window` as the default target.
        if (typeof targetOrName === 'string') {
            name = targetOrName;
            targetOrName = core.ɵglobal;
        }
        return targetOrName['__zone_symbol__' + name] || targetOrName[name];
    }

    /**
     * This file provides unpatched versions of APIs patched in the following file: https://github.com/angular/angular/blob/master/packages/zone.js/lib/browser/browser.ts
     */
    /**
     * This function is a zone un-patched implementation of Window#queueMicrotask() method.
     * It is which is exposed on the Window or Worker interface,
     * queues a microtask to be executed at a safe time prior to control returning to the browser's event loop.
     * The microtask is a short function which will run after the current task has completed its
     * work and when there is no other code waiting to be run before control of the execution context is returned to the browser's event loop.
     */
    function queueMicrotask() {
        return getZoneUnPatchedApi('queueMicrotask');
    }
    var Promise$1 = getZoneUnPatchedApi('Promise');
    /**
     * requestAnimationFrame
     *
     * @description
     *
     * This function is a zone un-patched implementation of Window#requestAnimationFrame() method
     *
     * The requestAnimationFrame() method calls a function or evaluates an expression on the next animationFrame.
     * The requestAnimationFrame() method will not continue calling the function after executed once.
     * The ID value returned by requestAnimationFrame() is used as the parameter for the cancelAnimationFrame() method.
     *
     * requestAnimationFrame(cb, ms);
     *
     * @param cb - Required. The function that will be executed
     *
     */
    function requestAnimationFrame(cb) {
        return getZoneUnPatchedApi('requestAnimationFrame')(cb);
    }
    /**
     * cancelAnimationFrame
     *
     * @description
     *
     * This function is a zone un-patched implementation of Window cancelAnimationFrame() method
     *
     * The cancelAnimationFrame() method clears a timer set with the requestAnimationFrame() method.
     * The ID value returned by requestAnimationFrame() is used as the parameter for the cancelAnimationFrame() method.
     *
     * To be able to use the cancelAnimationFrame() method, you must use a variable when creating the requestAnimationFrame method:
     *
     * const id = requestAnimationFrame("javascript function");
     * Then you will be able to stop the execution by calling the cancelAnimationFrame() method.
     *
     * cancelAnimationFrame(id);
     *
     * @param id {number} - Required. The ID value of the timer returned by the requestAnimationFrame() method
     *
     */
    function cancelAnimationFrame(id) {
        getZoneUnPatchedApi('cancelAnimationFrame')(id);
    }
    /**
     * setInterval
     *
     * @description
     *
     * This function is a zone un-patched implementation of Window setInterval() method
     *
     * The setInterval() method calls a function or evaluates an expression at specified intervals (in milliseconds).
     * The setInterval() method will continue calling the function until clearInterval() is called, or the window is closed.
     * The ID value returned by setInterval() is used as the parameter for the clearInterval() method.
     *
     * setInterval(cb, ms);
     *
     * @param cb - Required. The function that will be executed
     * @param ms - Required. The intervals (in milliseconds) on how often to execute the code. If the value is less than 10, the value 10 is used
     *
     */
    function setInterval(cb, ms) {
        if (ms === void 0) { ms = 0; }
        return getZoneUnPatchedApi('setInterval')(cb, ms);
    }
    /**
     * clearInterval
     *
     * @description
     *
     * This function is a zone un-patched implementation of Window clearInterval() method
     *
     * The clearInterval() method clears a timer set with the setInterval() method.
     * The ID value returned by setInterval() is used as the parameter for the clearInterval() method.
     *
     * To be able to use the clearInterval() method, you must use a variable when creating the interval method:
     *
     * const id = setInterval("javascript function", milliseconds);
     * Then you will be able to stop the execution by calling the clearInterval() method.
     *
     * clearInterval(id);
     *
     * @param id {number} - Required. The ID value of the timer returned by the setInterval() method
     *
     */
    function clearInterval(id) {
        return getZoneUnPatchedApi('clearInterval')(id);
    }
    /**
     * setTimeout
     *
     * @description
     *
     * This function is a zone un-patched implementation of Window setTimeout() method
     *
     * The setTimeout() method calls a function or evaluates an expression after a specified number of milliseconds.
     * The function is only executed once. If you need to repeat execution, use the setInterval() method.
     * Use the clearTimeout() method to prevent the function from running.
     *
     * setTimeout(cb, ms);
     *
     * @param cb - Required. The function that will be executed
     * @param ms - Optional. The number of milliseconds to wait before executing the code. If omitted, the value 0 is used
     *
     */
    function setTimeout(cb, ms) {
        if (ms === void 0) { ms = 0; }
        return getZoneUnPatchedApi('setTimeout')(cb, ms);
    }
    /**
     * clearTimeout
     *
     * @description
     *
     * This function is a zone un-patched implementation of Window#clearTimeout() method
     *
     * The clearTimeout() method clears a timer set with the setTimeout() method.
     * The ID value returned by setTimeout() is used as the parameter for the clearTimeout() method.
     *
     * const id = setTimeout("javascript function", milliseconds);
     * Then, if the function has not already been executed, you will be able to stop the execution by calling the clearTimeout() method.
     *
     * clearTimeout(id);
     *
     * @param id {number} -	Required. The ID value of the timer returned by the setTimeout() method
     *
     */
    function clearTimeout(id) {
        getZoneUnPatchedApi('clearTimeout')(id);
    }
    /**
     * This function is a zone un-patched implementation of Element#addEventListener() method.
     * @param target
     */
    function unpatchAddEventListener(target) {
        target.addEventListener = getZoneUnPatchedApi(target, 'addEventListener').bind(target);
        return target;
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    /**
     * A unit of work to be executed in a `scheduler`. An action is typically
     * created from within a {@link SchedulerLike} and an RxJS user does not need to concern
     * themselves about creating and manipulating an Action.
     *
     * ```ts
     * class Action<T> extends Subscription {
     *   new (scheduler: Scheduler, work: (state?: T) => void);
     *   schedule(state?: T, delay: number = 0): Subscription;
     * }
     * ```
     *
     * @class Action<T>
     */
    var Action = /** @class */ (function (_super) {
        __extends(Action, _super);
        function Action(scheduler, work) {
            return _super.call(this) || this;
        }
        /**
         * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed
         * some context object, `state`. May happen at some point in the future,
         * according to the `delay` parameter, if specified.
         * @param {T} [state] Some contextual data that the `work` function uses when
         * called by the Scheduler.
         * @param {number} [delay] Time to wait before executing the work, where the
         * time unit is implicit and defined by the Scheduler.
         * @return {void}
         */
        Action.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            return this;
        };
        return Action;
    }(rxjs.Subscription));

    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var AsyncAction = /** @class */ (function (_super) {
        __extends(AsyncAction, _super);
        function AsyncAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.pending = false;
            return _this;
        }
        AsyncAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (this.closed) {
                return this;
            }
            // Always replace the current state with the new state.
            this.state = state;
            var id = this.id;
            var scheduler = this.scheduler;
            //
            // Important implementation note:
            //
            // Actions only execute once by default, unless rescheduled from within the
            // scheduled callback. This allows us to implement single and repeat
            // actions via the same code path, without adding API surface area, as well
            // as mimic traditional recursion but across asynchronous boundaries.
            //
            // However, JS runtimes and timers distinguish between intervals achieved by
            // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
            // serial `setTimeout` calls can be individually delayed, which delays
            // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
            // guarantee the interval callback will be invoked more precisely to the
            // interval period, regardless of load.
            //
            // Therefore, we use `setInterval` to schedule single and repeat actions.
            // If the action reschedules itself with the same delay, the interval is not
            // canceled. If the action doesn't reschedule, or reschedules with a
            // different delay, the interval will be canceled after scheduled callback
            // execution.
            //
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, delay);
            }
            // Set the pending flag indicating that this action has been scheduled, or
            // has recursively rescheduled itself.
            this.pending = true;
            this.delay = delay;
            // If this action has already an async Id, don't request a new one.
            this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
            return this;
        };
        AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            return setInterval(scheduler.flush.bind(scheduler, this), delay);
        };
        AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            // If this action is rescheduled with the same delay time, don't clear the interval id.
            if (delay != null && this.delay === delay && this.pending === false) {
                return id;
            }
            // Otherwise, if the action's delay time is different from the current delay,
            // or the action has been rescheduled before it's executed, clear the interval id
            clearInterval(id);
            return undefined;
        };
        /**
         * Immediately executes this action and the `work` it contains.
         * @return {any}
         */
        AsyncAction.prototype.execute = function (state, delay) {
            if (this.closed) {
                return new Error('executing a cancelled action');
            }
            this.pending = false;
            var error = this._execute(state, delay);
            if (error) {
                return error;
            }
            else if (this.pending === false && this.id != null) {
                // Dequeue if the action didn't reschedule itself. Don't call
                // unsubscribe(), because the action could reschedule later.
                // For example:
                // ```
                // scheduler.schedule(function doWork(counter) {
                //   /* ... I'm a busy worker bee ... */
                //   var originalAction = this;
                //   /* wait 100ms before rescheduling the action */
                //   setTimeout(function () {
                //     originalAction.schedule(counter + 1);
                //   }, 100);
                // }, 1000);
                // ```
                this.id = this.recycleAsyncId(this.scheduler, this.id, null);
            }
        };
        AsyncAction.prototype._execute = function (state, delay) {
            var errored = false;
            var errorValue;
            try {
                this.work(state);
            }
            catch (e) {
                errored = true;
                errorValue = (!!e && e) || new Error(e);
            }
            if (errored) {
                this.unsubscribe();
                return errorValue;
            }
        };
        AsyncAction.prototype.unsubscribe = function () {
            if (!this.closed) {
                var _a = this, id = _a.id, scheduler = _a.scheduler;
                var actions = scheduler.actions;
                this.work = this.state = this.scheduler = null;
                this.pending = false;
                // arrRemove
                if (actions) {
                    var index = actions.indexOf(this);
                    0 <= index && actions.splice(index, 1);
                }
                if (id != null) {
                    this.id = this.recycleAsyncId(scheduler, id, null);
                }
                this.delay = null;
                _super.prototype.unsubscribe.call(this);
            }
        };
        return AsyncAction;
    }(Action));

    /**
     * Schedulers rely on provided actions and actions are using some asynchronous API
     * internally, e.g. `setInterval`, etc. We don't wanna copy-paste the code of all schedulers
     * here since it'll increase the bundle size. We can re-use constructors of RxJS schedulers
     * and provide our custom actions that use the unpatched API.
     */
    function createScheduler(scheduler, action) {
        // The `Reflect.construct` is a cross-browser feature, it's only not supported in IE11,
        // but apps anyway require polyfills if they want to be run in IE11.
        return Reflect.construct(scheduler.constructor, [action]);
    }

    // tslint:disable file-name-casing
    /**
     *
     * NOTE: This is a zone un-patched version of rxjs asyncScheduler
     *
     * Async Scheduler
     *
     * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
     *
     * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
     * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
     * in intervals.
     *
     * If you just want to "defer" task, that is to perform it right after currently
     * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
     * better choice will be the {@link asapScheduler} scheduler.
     *
     * ## Examples
     * Use async scheduler to delay task
     * ```ts
     * import { asyncScheduler } from '@cu/perf-utils';
     *
     * const task = () => console.log('it works!');
     *
     * asyncScheduler.schedule(task, 2000);
     *
     * // After 2 seconds logs:
     * // "it works!"
     * ```
     *
     * Use async scheduler to repeat task in intervals
     * ```ts
     * import { asyncScheduler } from '@cu/perf-utils';
     *
     * function task(state) {
     *   console.log(state);
     *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
     *                                   // which we reschedule with new state and delay
     * }
     *
     * asyncScheduler.schedule(task, 3000, 0);
     *
     * // Logs:
     * // 0 after 3s
     * // 1 after 4s
     * // 2 after 5s
     * // 3 after 6s
     * ```
     */
    var asyncScheduler = createScheduler(rxjs__namespace.asyncScheduler, AsyncAction);

    function isNumeric(val) {
        // parseFloat NaNs numeric-cast false positives (null|true|false|"")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        // adding 1 corrects loss of precision from parseFloat (#15100)
        return !Array.isArray(val) && val - parseFloat(val) + 1 >= 0;
    }
    function isScheduler(value) {
        return value && typeof value.schedule === 'function';
    }

    /**
     * Creates an Observable that emits sequential numbers every specified
     * interval of time, on a specified {@link SchedulerLike}.
     *
     * <span class="informal">Emits incremental numbers periodically in time.
     * </span>
     *
     * ![](interval.png)
     *
     * `interval` returns an Observable that emits an infinite sequence of
     * ascending integers, with a constant interval of time of your choosing
     * between those emissions. The first emission is not sent immediately, but
     * only after the first period has passed. By default, this operator uses the
     * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any
     * {@link SchedulerLike} to it.
     *
     * ## Example
     * Emits ascending numbers, one every second (1000ms) up to the number 3
     * ```ts
     * import { interval } from 'rxjs';
     * import { take } from 'rxjs/operators';
     *
     * const numbers = interval(1000);
     *
     * const takeFourNumbers = numbers.pipe(take(4));
     *
     * takeFourNumbers.subscribe(x => console.log('Next: ', x));
     *
     * // Logs:
     * // Next: 0
     * // Next: 1
     * // Next: 2
     * // Next: 3
     * ```
     *
     * @see {@link timer}
     * @see {@link delay}
     *
     * @param {number} [period=0] The interval size in milliseconds (by default)
     * or the time unit determined by the scheduler's clock.
     * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a sequential number each time
     * interval.
     * @static true
     * @name interval
     * @owner Observable
     */
    function interval(period, scheduler) {
        if (period === void 0) { period = 0; }
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        if (!isNumeric(period) || period < 0) {
            period = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            scheduler = asyncScheduler;
        }
        return new rxjs.Observable(function (subscriber) {
            subscriber.add(scheduler.schedule(dispatch$1, period, { subscriber: subscriber, counter: 0, period: period }));
            return subscriber;
        });
    }
    function dispatch$1(state) {
        var subscriber = state.subscriber, counter = state.counter, period = state.period;
        subscriber.next(counter);
        this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
    }

    /**
     * Creates an Observable that starts emitting after an `dueTime` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link index/interval}, but you can specify when
     * should the emissions start.</span>
     *
     * ![](timer.png)
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `dueTime`. The initial delay may be a `Date`. By default, this
     * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you
     * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * ## Examples
     * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds
     * ```ts
     * import { timer } from 'rxjs';
     *
     * const numbers = timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     * ```
     *
     * ### Emits one number after five seconds
     * ```ts
     * import { timer } from 'rxjs';
     *
     * const numbers = timer(5000);
     * numbers.subscribe(x => console.log(x));
     * ```
     * @see {@link index/interval}
     * @see {@link delay}
     *
     * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting
     * milliseconds to wait before emitting the first value of 0`.
     * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the
     * subsequent numbers.
     * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `dueTime` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    function timer(dueTime, periodOrScheduler, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        var period = -1;
        if (isNumeric(periodOrScheduler)) {
            period = (Number(periodOrScheduler) < 1 && 1) || Number(periodOrScheduler);
        }
        else if (isScheduler(periodOrScheduler)) {
            scheduler = periodOrScheduler;
        }
        if (!isScheduler(scheduler)) {
            scheduler = asyncScheduler;
        }
        return new rxjs.Observable(function (subscriber) {
            var due = isNumeric(dueTime)
                ? dueTime
                : +dueTime - scheduler.now();
            return scheduler.schedule(dispatch, due, {
                index: 0,
                period: period,
                subscriber: subscriber,
            });
        });
    }
    function dispatch(state) {
        var index = state.index, period = state.period, subscriber = state.subscriber;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        this.schedule(state, period);
    }

    // @ts-ignore
    var isFunction = function (fn) { return typeof fn === 'function'; };
    var ɵ0 = isFunction;
    var isArray = Array.isArray;
    var ɵ1 = function () { return Object.prototype.toString; };
    var toString = (ɵ1)();
    /* tslint:enable:max-line-length */
    function fromEvent(target, eventName, options, resultSelector) {
        if (isFunction(options)) {
            // DEPRECATED PATH
            // @ts-ignore
            resultSelector = options;
            options = undefined;
        }
        if (resultSelector) {
            // DEPRECATED PATH
            return fromEvent(target, eventName, options).pipe(operators.map(function (args) { return isArray(args) ? resultSelector.apply(void 0, __spreadArray([], __read(args))) : resultSelector(args); }));
        }
        return new rxjs.Observable(function (subscriber) {
            function handler(e) {
                if (arguments.length > 1) {
                    subscriber.next(Array.prototype.slice.call(arguments));
                }
                else {
                    subscriber.next(e);
                }
            }
            setupSubscription(target, eventName, handler, subscriber, options);
        });
    }
    function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            getZoneUnPatchedApi(sourceObj, 'addEventListener').call(sourceObj, eventName, handler, options);
            unsubscribe = function () { return getZoneUnPatchedApi(source_1, 'removeEventListener').call(source_1, eventName, handler, options); };
        }
        else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () { return source_2.off(eventName, handler); };
        }
        else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () { return source_3.removeListener(eventName, handler); };
        }
        else if (sourceObj && sourceObj.length) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        }
        else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(unsubscribe);
    }
    function isNodeStyleEventEmitter(sourceObj) {
        return (sourceObj &&
            typeof sourceObj.addListener === 'function' &&
            typeof sourceObj.removeListener === 'function');
    }
    function isJQueryStyleEventEmitter(sourceObj) {
        return (sourceObj &&
            typeof sourceObj.on === 'function' &&
            typeof sourceObj.off === 'function');
    }
    function isEventTarget(sourceObj) {
        return (sourceObj &&
            typeof sourceObj.addEventListener === 'function' &&
            typeof sourceObj.removeEventListener === 'function');
    }

    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var AsapAction = /** @class */ (function (_super) {
        __extends(AsapAction, _super);
        function AsapAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            // If delay is greater than 0, request as an async action.
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            // Push the action to the end of the scheduler queue.
            scheduler.actions.push(this);
            // If a microtask has already been scheduled, don't schedule another
            // one. If a microtask hasn't been scheduled yet, schedule one now. Return
            // the current scheduled microtask id.
            return (scheduler.scheduled ||
                (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, undefined))));
        };
        AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            // If delay exists and is greater than 0, or if the delay is null (the
            // action wasn't rescheduled) but was originally scheduled as an async
            // action, then recycle as an async action.
            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            // If the scheduler queue is empty, cancel the requested microtask and
            // set the scheduled flag to undefined so the next AsapAction will schedule
            // its own.
            if (scheduler.actions.length === 0) {
                Immediate.clearImmediate(id);
                scheduler.scheduled = undefined;
            }
            // Return undefined so the action knows to request a new async id if it's rescheduled.
            return undefined;
        };
        return AsapAction;
    }(AsyncAction));
    var nextHandle = 1;
    // The promise needs to be created lazily otherwise it won't be patched by Zones
    var resolved;
    var activeHandles = {};
    /**
     * Finds the handle in the list of active handles, and removes it.
     * Returns `true` if found, `false` otherwise. Used both to clear
     * Immediate scheduled tasks, and to identify if a task should be scheduled.
     */
    function findAndClearHandle(handle) {
        if (handle in activeHandles) {
            delete activeHandles[handle];
            return true;
        }
        return false;
    }
    /**
     * Helper functions to schedule and unschedule microtasks.
     */
    var Immediate = {
        setImmediate: function (cb) {
            var handle = nextHandle++;
            activeHandles[handle] = true;
            if (!resolved) {
                resolved = Promise$1.resolve();
            }
            resolved.then(function () { return findAndClearHandle(handle) && cb(); });
            return handle;
        },
        clearImmediate: function (handle) {
            findAndClearHandle(handle);
        },
    };
    /**
     * Used for internal testing purposes only. Do not export from library.
     */
    var TestTools = {
        pending: function () {
            return Object.keys(activeHandles).length;
        },
    };

    // tslint:disable file-name-casing
    /**
     *
     * NOTE: This is a zone un-patched version of rxjs asapScheduler
     *
     * Asap Scheduler
     *
     * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
     *
     * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task
     * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
     * code to end and then it will try to execute given task as fast as possible.
     *
     * `asap` scheduler will do its best to minimize time between end of currently executing code
     * and start of scheduled task. This makes it best candidate for performing so called "deferring".
     * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
     * some (although minimal) unwanted delay.
     *
     * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
     * after currently executing code. In particular, if some task was also scheduled with `asap` before,
     * that task will execute first. That being said, if you need to schedule task asynchronously, but
     * as soon as possible, `asap` scheduler is your best bet.
     *
     * ## Example
     * Compare async and asap scheduler<
     * ```ts
     * import { asapScheduler, asyncScheduler } from '@cu/perf-utils';
     *
     * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...
     * asapScheduler.schedule(() => console.log('asap'));
     *
     * // Logs:
     * // "asap"
     * // "async"
     * // ... but 'asap' goes first!
     * ```
     */
    var asapScheduler = createScheduler(rxjs__namespace.asapScheduler, AsapAction);

    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var QueueAction = /** @class */ (function (_super) {
        __extends(QueueAction, _super);
        function QueueAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        QueueAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay > 0) {
                return _super.prototype.schedule.call(this, state, delay);
            }
            this.delay = delay;
            this.state = state;
            // @ts-ignore
            this.scheduler.flush(this);
            return this;
        };
        QueueAction.prototype.execute = function (state, delay) {
            return delay > 0 || this.closed
                ? _super.prototype.execute.call(this, state, delay)
                : this._execute(state, delay);
        };
        QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            // If delay exists and is greater than 0, or if the delay is null (the
            // action wasn't rescheduled) but was originally scheduled as an async
            // action, then recycle as an async action.
            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            // Otherwise flush the scheduler starting with this action.
            // @ts-ignore
            return scheduler.flush(this);
        };
        return QueueAction;
    }(AsyncAction));

    // tslint:disable file-name-casing
    /**
     *
     * NOTE: This is a zone un-patched version of rxjs queueScheduler
     *
     * Queue Scheduler
     *
     * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
     *
     * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.
     *
     * When used without delay, it schedules given task synchronously - executes it right when
     * it is scheduled. However when called recursively, that is when inside the scheduled task,
     * another task is scheduled with queue scheduler, instead of executing immediately as well,
     * that task will be put on a queue and wait for current one to finish.
     *
     * This means that when you execute task with `queue` scheduler, you are sure it will end
     * before any other task scheduled with that scheduler will start.
     *
     * ## Examples
     * Schedule recursively first, then do something
     * ```ts
     * import { queueScheduler } from '@cu/perf-utils';
     *
     * queueScheduler.schedule(() => {
     *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
     *
     *   console.log('first');
     * });
     *
     * // Logs:
     * // "first"
     * // "second"
     * ```
     *
     * Reschedule itself recursively
     * ```ts
     * import { queueScheduler } from '@cu/perf-utils';
     *
     * queueScheduler.schedule(function(state) {
     *   if (state !== 0) {
     *     console.log('before', state);
     *     this.schedule(state - 1); // `this` references currently executing Action,
     *                               // which we reschedule with new state
     *     console.log('after', state);
     *   }
     * }, 0, 3);
     *
     * // In scheduler that runs recursively, you would expect:
     * // "before", 3
     * // "before", 2
     * // "before", 1
     * // "after", 1
     * // "after", 2
     * // "after", 3
     *
     * // But with queue it logs:
     * // "before", 3
     * // "after", 3
     * // "before", 2
     * // "after", 2
     * // "before", 1
     * // "after", 1
     * ```
     */
    var queueScheduler = createScheduler(rxjs__namespace.queueScheduler, QueueAction);

    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var AnimationFrameAction = /** @class */ (function (_super) {
        __extends(AnimationFrameAction, _super);
        function AnimationFrameAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            // If delay is greater than 0, request as an async action.
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            // Push the action to the end of the scheduler queue.
            // @ts-ignore
            scheduler.actions.push(this);
            // If an animation frame has already been requested, don't request another
            // one. If an animation frame hasn't been requested yet, request one. Return
            // the current animation frame request id.
            return (scheduler.scheduled ||
                (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(undefined); })));
        };
        AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            // If delay exists and is greater than 0, or if the delay is null (the
            // action wasn't rescheduled) but was originally scheduled as an async
            // action, then recycle as an async action.
            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            // If the scheduler queue is empty, cancel the requested animation frame and
            // set the scheduled flag to undefined so the next AnimationFrameAction will
            // request its own.
            if (scheduler.actions.length === 0) {
                cancelAnimationFrame(id);
                scheduler.scheduled = undefined;
            }
            // Return undefined so the action knows to request a new async id if it's rescheduled.
            return undefined;
        };
        return AnimationFrameAction;
    }(AsyncAction));

    // tslint:disable file-name-casing
    /**
     *
     * NOTE: This is a zone un-patched version of rxjs animationFrameScheduler
     *
     * Animation Frame Scheduler
     *
     * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
     *
     * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler
     * behaviour.
     *
     * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
     * It makes sure scheduled task will happen just before next browser content repaint,
     * thus performing animations as efficiently as possible.
     *
     * ## Example
     * Schedule div height animation
     * ```ts
     * // html: <div style="background: #0ff;"></div>
     * import { animationFrameScheduler } from '@cu/perf-utils';
     *
     * const div = document.querySelector('div');
     *
     * animationFrameScheduler.schedule(function(height) {
     *   div.style.height = height + "px";
     *
     *   this.schedule(height + 1);  // `this` references currently executing Action,
     *                               // which we reschedule with new state
     * }, 0, 0);
     *
     * // You will see a div element growing in height
     * ```
     */
    var animationFrameScheduler = createScheduler(rxjs__namespace.animationFrameScheduler, AnimationFrameAction);

    /**
     * Generated bundle index. Do not edit.
     */

    exports.Promise = Promise$1;
    exports.animationFrameScheduler = animationFrameScheduler;
    exports.asapScheduler = asapScheduler;
    exports.asyncScheduler = asyncScheduler;
    exports.cancelAnimationFrame = cancelAnimationFrame;
    exports.clearInterval = clearInterval;
    exports.clearTimeout = clearTimeout;
    exports.fromEvent = fromEvent;
    exports.getZoneUnPatchedApi = getZoneUnPatchedApi;
    exports.interval = interval;
    exports.queueScheduler = queueScheduler;
    exports.requestAnimationFrame = requestAnimationFrame;
    exports.setInterval = setInterval;
    exports.setTimeout = setTimeout;
    exports.timer = timer;
    exports.unpatchAddEventListener = unpatchAddEventListener;
    exports.ɵa = createScheduler;
    exports.ɵb = AsyncAction;
    exports.ɵc = Action;
    exports.ɵf = AsapAction;
    exports.ɵh = QueueAction;
    exports.ɵj = AnimationFrameAction;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=cdk-zone-less.umd.js.map
