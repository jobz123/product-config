import { Subject, NEVER, ReplaySubject, of, isObservable, from } from 'rxjs';
import { mergeAll, share, materialize, tap, map, startWith, distinctUntilChanged, filter, switchMap } from 'rxjs/operators';
import { coerceAllFactory } from '@rx-angular/cdk/coercing';

function toRxErrorNotification(error, value) {
    return {
        value,
        kind: "error" /* Error */,
        hasValue: !!value || false,
        complete: false,
        error: error || true,
    };
}
function toRxSuspenseNotification(value) {
    return {
        value,
        kind: "suspense" /* Suspense */,
        hasValue: !!value || false,
        complete: false,
        error: false,
    };
}
function toRxCompleteNotification(value) {
    return {
        value,
        kind: "complete" /* Complete */,
        hasValue: !!value || false,
        complete: true,
        error: false,
    };
}

/**
 * @internal
 *
 * A factory function returning an object to handle the process of switching templates by Notification channel.
 * You can next a Observable of `RxNotification` multiple times and merge them into the Observable exposed under `trigger$`
 *
 */
function templateTriggerHandling() {
    const hotFlattened = coerceAllFactory(() => new Subject(), mergeAll());
    return {
        next(templateName) {
            hotFlattened.next(templateName);
        },
        trigger$: hotFlattened.values$.pipe(share()),
    };
}

function rxMaterialize() {
    return (o$) => o$.pipe(materialize(), tap(({ kind, error }) => {
        // As we dont want to just swallow errors we log them here
        if (kind === 'E') {
            console.error(error);
        }
    }), map(({ value, error, kind }) => {
        const rxNotificationKind = notificationKindToRxNotificationKind(kind);
        return {
            value,
            hasValue: kind === 'N',
            error,
            kind: rxNotificationKind,
            complete: rxNotificationKind === "complete" /* Complete */,
        };
    }));
}
/**
 * @internal
 *
 * @description
 * This function is here to turn RxJS notification kind values into RxNotification kind names.
 * The main reason for the naming is the RxNotification kind values map directly to the default
 * template names (`suspense`, `next`, `error` `complete`) in the directives of the template package
 */
function notificationKindToRxNotificationKind(kind) {
    switch (kind) {
        case 'C':
            return "complete" /* Complete */;
        case 'E':
            return "error" /* Error */;
        case 'N':
        default:
            return "next" /* Next */;
    }
}

const calcWithSuspenseTpl = (withSuspenseTpl) => withSuspenseTpl && withSuspenseTpl();
const ɵ0 = calcWithSuspenseTpl;
/**
 * @description
 * Sends value and an initial `undefined` as value With a NEVER.
 * This is needed to render the suspense template and avoid completing (and render the complete template).
 * @param value
 */
const emitAndDontComplete = (value) => NEVER.pipe(startWith(value));
const ɵ1 = emitAndDontComplete;
/**
* @description
* Flags the first run.
* This is important as we want to create laziness in the template.
* If no value ever is emitted we dont want to create/render the value (next template).
* In case a suspense template is given (calculated by `withSuspense` param) we render the suspense template on the first run.
*/
const mapFirst = (transformation) => (o$) => {
    let firstRun = true;
    return o$.pipe(map((value) => {
        if (!firstRun) {
            return value;
        }
        const result = transformation(value);
        firstRun = false;
        return result;
    }));
};
const ɵ2 = mapFirst;
/**
 * This helper is responsible for turning a stream of materialized notifications
 * (next error, complete as object in the next stream) into an enriched version with an additional suspense notification type.
 *
 * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.
 * This value is important in the template to show an e.g. error and also have access to the last emitted value of next.
 * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner in case of the suspense state.
 *
 * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification
 * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification
 * and assign it as new value to the notification
 */
const handleSuspenseAndLastValueInNotifications = () => {
    // Used to store the last value per handleSuspenseAndLastValueInNotifications call
    let latestNextValue;
    // returns a projection function with a lastValue cache
    return (notification) => {
        // if it the notification is of type next we take its value
        // otherwise we keep the existing last value
        if (notification.kind === "next" /* Next */) {
            latestNextValue = notification.value;
        }
        // If a next notification enters with a value of undefined we turn it into a suspense notification
        if (notification.kind === "next" /* Next */ &&
            notification.value === undefined) {
            return toRxSuspenseNotification(undefined);
        }
        // If a Notification of type error, complete or suspense enters we assign the latest last value to them.
        // This is needed to access the old value in case of error or complete.
        // Next notifications will pass as they are.
        if (notification.kind === "error" /* Error */ ||
            notification.kind === "complete" /* Complete */ ||
            notification.kind === "suspense" /* Suspense */) {
            notification.value = latestNextValue;
        }
        return notification;
    };
};
const ɵ3 = handleSuspenseAndLastValueInNotifications;
/**
 * @internal
 *
 * @description
 * This factory function returns an object that can be driven imperatively over a `next` method.
 * Internally it prepares the incoming values for rendering by turning them into "template notifications",
 * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing or suspense states.
 *
 * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.
 * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the display of
 * the default template as well as the suspense, error, complete templates.
 */
function createTemplateNotifier(withSuspenseTpl) {
    // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties
    const observablesSubject = new ReplaySubject(1);
    const values$ = observablesSubject.pipe(distinctUntilChanged(), 
    // Handle initialization edge cases
    mapFirst((value) => {
        const isUndefined = value === undefined;
        const isNEVER = value === NEVER;
        // If it is a `NEVER` Observable we know it will never emit a value nor complete or error.
        // Therefore we emit directly undefined to signal a suspense state
        if ((isUndefined || isNEVER)) {
            // Determines if a suspense notification is needed
            const isSuspenseTemplateGiven = calcWithSuspenseTpl(withSuspenseTpl);
            // Render suspense template if given. Otherwise do nothing (later undefined are filtered out)
            return isSuspenseTemplateGiven ? emitAndDontComplete(undefined) : undefined;
        }
        const isNull = value === null;
        if (isNull) {
            // We return the value and no undefined as first value
            // as we dont need to render the suspense template for null values (it is considered as not used)
            return of(null);
        }
        return value;
    }), 
    // `undefined` values are only processed once at beginning to initialize lazy. After that they are filtered out.
    filter((v) => v !== undefined), 
    // handle static values inc null assignment and new Observable or Promises
    map((observable$) => {
        const isNull = observable$ === null;
        const isPromiseOrObs = typeof observable$.then === 'function' || isObservable(observable$);
        // A value is considered as static value if it is `null`, or any other value than `undefined`, `Promise`, `Observable`
        const isStaticValue = !isPromiseOrObs && !(observable$ === undefined) || isNull;
        const isNEVER = observable$ === NEVER;
        // If it is a `NEVER` Observable we know it will never emit a value nor complete or error.
        // Therefore we emit directly undefined to signal a suspense state
        if (isNEVER) {
            // Render suspense template for null values (it is considered as not used)
            return emitAndDontComplete(undefined);
        }
        // If it is a static value forward directly
        if (isStaticValue) {
            // Render next template for static values (it is considered as kinda sync)
            return emitAndDontComplete(observable$);
        }
        return from(observable$).pipe((o$) => {
            // Determines if a suspense notification is needed
            const isSuspenseTemplateGiven = calcWithSuspenseTpl(withSuspenseTpl);
            if (isSuspenseTemplateGiven) {
                // Render suspense template
                return o$.pipe(startWith(undefined));
            }
            return o$;
        });
    }), switchMap((o) => {
        return o.pipe(distinctUntilChanged(), rxMaterialize(), map(handleSuspenseAndLastValueInNotifications()));
    }));
    return {
        next(observable) {
            observablesSubject.next(observable);
        },
        values$,
    };
}

/**
 * Generated bundle index. Do not edit.
 */

export { createTemplateNotifier, rxMaterialize, templateTriggerHandling, toRxCompleteNotification, toRxErrorNotification, toRxSuspenseNotification };
//# sourceMappingURL=cdk-notifications.js.map
