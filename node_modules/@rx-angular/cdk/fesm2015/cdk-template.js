import { ɵdetectChanges } from '@angular/core';
import { merge, of, concat, combineLatest, EMPTY, Observable, ReplaySubject, BehaviorSubject } from 'rxjs';
import { withLatestFrom, switchMap, delay, ignoreElements, catchError, distinctUntilChanged, map, tap, pluck } from 'rxjs/operators';
import { asyncScheduler } from '@rx-angular/cdk/zone-less';
import { onStrategy, strategyHandling } from '@rx-angular/cdk/render-strategies';

// Below are constants for LView indices to help us look up LView members
// without having to remember the specific indices.
// Uglify will inline these when minifying so there shouldn't be a cost.
const TVIEW = 1;
const T_HOST = 6;
const L_CONTAINER_NATIVE = 7;
const CONTEXT = 8;
const HEADER_OFFSET = 20;
/**
 * @internal
 *
 * Returns the TNode of the passed node form TVIEW of passed cdRef
 *
 * @param cdRef
 * @param native
 */
function getTNode(cdRef, native) {
    const lView = cdRef._cdRefInjectingView;
    if (!lView) {
        return undefined;
    }
    const tView = lView[TVIEW];
    let i = HEADER_OFFSET;
    let lContainer;
    while (!lContainer && i <= tView['bindingStartIndex']) {
        const candidate = lView[i];
        if (candidate && candidate[L_CONTAINER_NATIVE] === native) {
            lContainer = candidate;
        }
        i++;
    }
    return lContainer[T_HOST];
}
/**
 * @internal
 *
 * Returns a set of references to parent views
 *
 *
 * @param cdRef
 * @param tNode
 */
function extractProjectionParentViewSet(cdRef, tNode) {
    const injectingLView = cdRef._cdRefInjectingView;
    const injectingTView = injectingLView[1];
    const components = new Set(injectingTView['components']);
    const parentElements = new Set();
    let parent = tNode['parent'];
    while (parent != null && components.size > 0) {
        const idx = parent['index'];
        if (components.has(idx)) {
            // TODO: we should discuss about this. currently only the first Component will get returned, not a list of
            //  components. Maybe we should make the parent notification configurable regarding the level of `deepness`?
            // components.delete(idx);
            components.clear();
            parentElements.add(injectingLView[idx][CONTEXT]);
        }
        parent = parent['parent'];
    }
    return parentElements;
}
function extractProjectionViews(cdRef, tNode) {
    return Array.from(extractProjectionParentViewSet(cdRef, tNode));
}
/**
 * A side effect operator similar to `tap` but with a static logic
 *
 *
 *
 * @param cdRef
 * @param tNode
 * @param strategy$
 */
function renderProjectionParents(cdRef, tNode, strategy$) {
    return (o$) => o$.pipe(withLatestFrom(strategy$), switchMap(([_, strategy]) => {
        const parentElements = extractProjectionParentViewSet(cdRef, tNode);
        const behaviors = [];
        for (const el of parentElements.values()) {
            behaviors.push(onStrategy(el, strategy, (value, work, options) => {
                ɵdetectChanges(el);
            }, { scope: el }));
        }
        behaviors.push(onStrategy(null, strategy, (value, work, options) => work(cdRef, options.scope), { scope: cdRef.context || cdRef }));
        return merge(...behaviors);
    }));
}
/**
 * @internal
 * creates an embeddedViewRef
 *
 * @param viewContainerRef
 * @param templateRef
 * @param context
 * @param index
 * @return EmbeddedViewRef<C>
 */
function createEmbeddedView(viewContainerRef, templateRef, context, index = 0) {
    const view = viewContainerRef.createEmbeddedView(templateRef, context, index);
    view.detectChanges();
    return view;
}
/**
 * @internal
 *
 * A factory function returning an object to handle `TemplateRef`'s.
 * You can add and get a `TemplateRef`.
 *
 */
function templateHandling(viewContainerRef) {
    const templateCache = new Map();
    const get = (name) => {
        return templateCache.get(name);
    };
    return {
        add(name, templateRef) {
            assertTemplate(name, templateRef);
            if (!templateCache.has(name)) {
                templateCache.set(name, templateRef);
            }
            else {
                throw new Error('Updating an already existing Template is not supported at the moment.');
            }
        },
        get,
        createEmbeddedView: (name, context) => createEmbeddedView(viewContainerRef, get(name), context),
    };
    //
    function assertTemplate(property, templateRef) {
        const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
        if (!isTemplateRefOrNull) {
            throw new Error(`${property} must be a TemplateRef, but received something else.`);
        }
        return isTemplateRefOrNull;
    }
}
/**
 * @internal
 *
 * A side effect operator similar to `tap` but with a static internal logic.
 * It calls detect changes on the 'VirtualParent' and the injectingViewCdRef.
 *
 * @param tNode
 * @param injectingViewCdRef
 * @param strategy
 * @param notifyNeeded
 */
function notifyAllParentsIfNeeded(tNode, injectingViewCdRef, strategy, notifyNeeded) {
    return (o$) => o$.pipe(delay(0, asyncScheduler), switchMap((v) => {
        const notifyParent = notifyNeeded();
        if (!notifyParent) {
            return of(v);
        }
        const behaviors = tNode
            ? getVirtualParentNotifications$(tNode, injectingViewCdRef, strategy)
            : [];
        // @TODO remove this CD on injectingViewCdRef if possible
        behaviors.push(onStrategy(injectingViewCdRef, strategy, (_v, work, options) => work(injectingViewCdRef, options.scope), {
            scope: injectingViewCdRef.context || injectingViewCdRef,
        }));
        if (behaviors.length === 1) {
            return of(v);
        }
        return concat(of(v), combineLatest(behaviors).pipe(ignoreElements()));
    }));
}
/**
 * @internal
 *
 * returns an Observable executing a side effects for change detection of parents
 *
 * @param injectingViewCdRef
 * @param strategy
 * @param notify
 */
function notifyInjectingParentIfNeeded(injectingViewCdRef, strategy, notify) {
    return concat(of(null), notify
        ? onStrategy(injectingViewCdRef, strategy, (value, work, options) => {
            // console.log('notify injectingView', injectingViewCdRef);
            work(injectingViewCdRef, options.scope);
        }, {}).pipe(ignoreElements())
        : []);
}
/**
 * @internal
 *
 * Returns an array of observables triggering `detectChanges` on the __virtual parent__  (parent of the projected view)
 *
 * @param tNode - is a component that was projected into another component (virtual parent)
 * @param injectingViewCdRef - is needed to get the
 * @param strategy - the strategy to run the change detection
 */
function getVirtualParentNotifications$(tNode, injectingViewCdRef, strategy) {
    const parentElements = extractProjectionParentViewSet(injectingViewCdRef, tNode);
    const behaviors = [];
    for (const parentComponent of parentElements.values()) {
        behaviors.push(onStrategy(parentComponent, strategy, 
        // Here we CD the parent to update their projected views scenarios
        (value, work, options) => {
            // console.log('parentComponent', parentComponent);
            ɵdetectChanges(parentComponent);
        }, { scope: parentComponent }));
    }
    return behaviors;
}

var RxBaseTemplateNames;
(function (RxBaseTemplateNames) {
    RxBaseTemplateNames["error"] = "errorTpl";
    RxBaseTemplateNames["complete"] = "completeTpl";
    RxBaseTemplateNames["suspense"] = "suspenseTpl";
})(RxBaseTemplateNames || (RxBaseTemplateNames = {}));

/** @internal **/
function isRxRenderError(e) {
    return (e != null && Array.isArray(e) && e.length === 2 && e[0] instanceof Error);
}
/** @internal **/
function createErrorHandler(_handler) {
    const _handleError = _handler
        ? (e) => _handler.handleError(e)
        : console.error;
    return {
        handleError: (error) => {
            if (isRxRenderError(error)) {
                _handleError(error[0]);
                console.error('additionalErrorContext', error[1]);
            }
            else {
                _handleError(error);
            }
        },
    };
}
/** @internal **/
function toRenderError(e, context) {
    return [e, context];
}

/**
 * @internal
 *
 * A factory function that returns a map of projections to turn a notification of a Observable (next, error, complete)
 *
 * @param customNextContext - projection function to provide custom properties as well as override existing
 */
function notificationKindToViewContext(customNextContext) {
    // @TODO rethink overrides
    return {
        suspense: (notification) => {
            const $implicit = notification.value;
            return Object.assign({ $implicit, $suspense: true, $error: false, $complete: false }, customNextContext($implicit));
        },
        next: (notification) => {
            const $implicit = notification.value;
            return Object.assign({ $implicit, $suspense: false, $error: false, $complete: false }, customNextContext($implicit));
        },
        error: (notification) => {
            const $implicit = notification.value;
            return Object.assign({ $implicit, $complete: false, $error: notification.error, $suspense: false }, customNextContext($implicit));
        },
        complete: (notification) => {
            const $implicit = notification.value;
            return Object.assign({ $implicit, $error: false, $complete: true, $suspense: false }, customNextContext($implicit));
        },
    };
}
function createTemplateManager(config) {
    const { renderSettings, notificationToTemplateName, templateSettings } = config;
    const { defaultStrategyName, strategies, cdRef: injectingViewCdRef, patchZone, parent, eRef, } = renderSettings;
    const errorHandler = createErrorHandler(renderSettings.errorHandler);
    const tNode = parent
        ? getTNode(injectingViewCdRef, eRef.nativeElement)
        : false;
    let activeTemplate;
    const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);
    const templates = templateHandling(templateSettings.viewContainerRef);
    const viewContainerRef = templateSettings.viewContainerRef;
    const triggerHandling = config.templateTrigger$ || EMPTY;
    const getContext = notificationKindToViewContext(templateSettings.customContext || ((v) => { }));
    const workFactory = patchZone
        ? (work) => patchZone.run(work)
        : (work) => work();
    return {
        addTemplateRef: templates.add,
        // addTrigger: triggerHandling.next,
        nextStrategy: strategyHandling$.next,
        render(values$) {
            return values$.pipe(
            /* tslint:disable */
            // mergeWith(triggerHandling.trigger$ || EMPTY),
            /* tslint:enable */
            withLatestFrom(strategyHandling$.strategy$), 
            // Cancel old renders
            switchMap(([notification, strategy]) => {
                const kind = notification.kind;
                const value = notification.value;
                const templateName = notificationToTemplateName[kind](value, templates);
                const template = templates.get(templateName);
                const isNewTemplate = activeTemplate !== templateName;
                const notifyParent = isNewTemplate && parent;
                return merge(onStrategy(value, strategy, (v, work, options) => {
                    const context = getContext[kind](notification);
                    if (isNewTemplate) {
                        // template has changed (undefined => next; suspense => next; ...)
                        // handle remove & insert
                        // remove current view if there is any
                        if (viewContainerRef.length > 0) {
                            // patch removal if needed
                            workFactory(() => viewContainerRef.clear());
                        }
                        // create new view if any
                        if (template) {
                            // createEmbeddedView is already patched, no need for workFactory
                            workFactory(() => templates.createEmbeddedView(templateName, context));
                        }
                    }
                    else if (template) {
                        // template didn't change, update it
                        // handle update
                        const view = viewContainerRef.get(0);
                        Object.keys(context).forEach((k) => {
                            view.context[k] = context[k];
                        });
                        // update view context, patch if needed
                        workFactory(() => work(view, options.scope, notification));
                    }
                    activeTemplate = templateName;
                }
                // we don't need to specify any scope here. The template manager is the only one
                // who will call `viewRef#detectChanges` on any of the templates it manages.
                // whenever a new value comes in, any pre-scheduled work of this taskManager will
                // be nooped before a new work will be scheduled. This happens because of the implementation
                // of `StrategyCredential#behavior`
                ).pipe(notifyAllParentsIfNeeded(tNode, injectingViewCdRef, strategy, () => notifyParent)), notifyInjectingParentIfNeeded(injectingViewCdRef, strategy, isNewTemplate).pipe(ignoreElements())).pipe(catchError((e) => {
                    errorHandler.handleError(e);
                    return of(e);
                }));
            }));
        },
    };
}

/**
 * @internal
 *
 * Factory that returns a `ListTemplateManager` for the passed params.
 *
 * @param templateSettings
 */
function getTemplateHandler(templateSettings) {
    const { viewContainerRef, initialTemplateRef, createViewContext, updateViewContext, patchZone, } = templateSettings;
    const workFactory = patchZone
        ? (work) => patchZone.run(work)
        : (work) => work();
    return {
        updateUnchangedContext,
        insertView,
        moveView,
        removeView,
        getListChanges,
        updateView,
    };
    // =====
    function updateUnchangedContext(index, count) {
        const view = viewContainerRef.get(index);
        workFactory(() => {
            view.context.updateContext({
                count,
                index,
            });
            view.detectChanges();
        });
    }
    function moveView(oldIndex, item, index, count) {
        const oldView = viewContainerRef.get(oldIndex);
        const view = viewContainerRef.move(oldView, index);
        workFactory(() => {
            updateViewContext(item, view, {
                count,
                index,
            });
            view.detectChanges();
        });
    }
    function updateView(item, index, count) {
        const view = viewContainerRef.get(index);
        workFactory(() => {
            updateViewContext(item, view, {
                count,
                index,
            });
            view.detectChanges();
        });
    }
    function removeView(index) {
        return workFactory(() => viewContainerRef.remove(index));
    }
    function insertView(item, index, count) {
        workFactory(() => {
            createEmbeddedView(viewContainerRef, initialTemplateRef, createViewContext(item, {
                count,
                index,
            }), index);
        });
    }
}
/**
 * @internal
 *
 * @param changes
 * @param items
 */
function getListChanges(changes, items) {
    const changedIdxs = new Set();
    const changesArr = [];
    let notifyParent = false;
    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
        const item = record.item;
        if (record.previousIndex == null) {
            // insert
            changesArr.push(getInsertChange(item, currentIndex === null ? undefined : currentIndex));
            changedIdxs.add(item);
            notifyParent = true;
        }
        else if (currentIndex == null) {
            // remove
            changesArr.push(getRemoveChange(item, adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex));
            changedIdxs.add(item);
            notifyParent = true;
        }
        else if (adjustedPreviousIndex !== null) {
            // move
            changesArr.push(getMoveChange(item, currentIndex, adjustedPreviousIndex));
            changedIdxs.add(item);
            notifyParent = true;
        }
    });
    changes.forEachIdentityChange((record) => {
        const item = record.item;
        if (!changedIdxs.has(item)) {
            changesArr.push(getUpdateChange(item, record.currentIndex));
            changedIdxs.add(item);
        }
    });
    items.forEach((item, index) => {
        if (!changedIdxs.has(item)) {
            changesArr.push(getUnchangedChange(item, index));
        }
    });
    return [changesArr, notifyParent];
    // ==========
    function getMoveChange(item, currentIndex, adjustedPreviousIndex) {
        return [
            2 /* move */,
            [item, currentIndex, adjustedPreviousIndex],
        ];
    }
    function getUpdateChange(item, currentIndex) {
        return [3 /* update */, [item, currentIndex]];
    }
    function getUnchangedChange(item, index) {
        return [4 /* context */, [item, index]];
    }
    function getInsertChange(item, currentIndex) {
        return [
            0 /* insert */,
            [item, currentIndex === null ? undefined : currentIndex],
        ];
    }
    function getRemoveChange(item, adjustedPreviousIndex) {
        return [
            1 /* remove */,
            [item, adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex],
        ];
    }
}

function createListTemplateManager(config) {
    const { templateSettings, renderSettings, trackBy, iterableDiffers } = config;
    const { defaultStrategyName, strategies, cdRef: injectingViewCdRef, patchZone, parent, eRef, } = renderSettings;
    const errorHandler = createErrorHandler(renderSettings.errorHandler);
    const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);
    const differ = iterableDiffers.find([]).create(trackBy);
    //               type,  context
    const tNode = parent
        ? getTNode(injectingViewCdRef, eRef.nativeElement)
        : false;
    /* TODO (regarding createView): this is currently not in use. for the list-manager this would mean to provide
     functions for not only create. developers than should have to provide create, move, remove,... the whole thing.
     i don't know if this is the right decision for a first RC */
    const listViewHandler = getTemplateHandler(Object.assign(Object.assign({}, templateSettings), { initialTemplateRef: templateSettings.templateRef, patchZone }));
    const viewContainerRef = templateSettings.viewContainerRef;
    let notifyParent = false;
    let changesArr;
    let partiallyFinished = false;
    return {
        nextStrategy(nextConfig) {
            strategyHandling$.next(nextConfig);
        },
        render(values$) {
            return values$.pipe(render());
        },
    };
    function render() {
        return (o$) => combineLatest([o$, strategyHandling$.strategy$.pipe(distinctUntilChanged())]).pipe(
        // map iterable to latest diff
        map(([iterable, strategy]) => {
            if (partiallyFinished) {
                const currentIterable = [];
                for (let i = 0, ilen = viewContainerRef.length; i < ilen; i++) {
                    const viewRef = viewContainerRef.get(i);
                    currentIterable[i] = viewRef.context.$implicit;
                }
                differ.diff(currentIterable);
            }
            return {
                changes: differ.diff(iterable),
                items: iterable != null && Array.isArray(iterable) ? iterable : [],
                strategy
            };
        }), 
        // Cancel old renders
        switchMap(({ changes, items, strategy }) => {
            if (!changes) {
                return of([]);
            }
            const listChanges = listViewHandler.getListChanges(changes, items);
            changesArr = listChanges[0];
            const insertedOrRemoved = listChanges[1];
            const applyChanges$ = getObservablesFromChangesArray(changesArr, strategy, items.length);
            partiallyFinished = true;
            // @TODO we need to know if we need to notifyParent on move aswell
            notifyParent = insertedOrRemoved && parent;
            return new Observable(subscriber => {
                const s = merge(combineLatest(
                // emit after all changes are rendered
                applyChanges$.length > 0 ? applyChanges$ : [of(items)]).pipe(tap(() => (partiallyFinished = false)), 
                // somehow this makes the strategySelect work
                notifyAllParentsIfNeeded(tNode, injectingViewCdRef, strategy, () => notifyParent)), 
                // emit injectingParent if needed
                notifyInjectingParentIfNeeded(injectingViewCdRef, strategy, insertedOrRemoved).pipe(ignoreElements())).pipe(map(() => items), catchError((e) => {
                    partiallyFinished = false;
                    errorHandler.handleError(e);
                    return of(items);
                })).subscribe(subscriber);
                return () => {
                    s.unsubscribe();
                };
            });
        }));
    }
    /**
     * @internal
     *
     * returns an array of streams which process all of the view updates needed to reflect the latest diff to the
     * viewContainer.
     * I
     *
     * @param changes
     * @param strategy
     * @param count
     */
    function getObservablesFromChangesArray(changes, strategy, count) {
        return changes.length > 0
            ? changes.map((change) => {
                const payload = change[1];
                return onStrategy(change[0], strategy, type => {
                    switch (type) {
                        case 0 /* insert */:
                            listViewHandler.insertView(payload[0], payload[1], count);
                            break;
                        case 2 /* move */:
                            listViewHandler.moveView(payload[2], payload[0], payload[1], count);
                            break;
                        case 1 /* remove */:
                            listViewHandler.removeView(payload[1]);
                            break;
                        case 3 /* update */:
                            listViewHandler.updateView(payload[0], payload[1], count);
                            break;
                        case 4 /* context */:
                            listViewHandler.updateUnchangedContext(payload[1], count);
                            break;
                    }
                }, {});
            })
            : [of(null)];
    }
}

const computeFirst = ({ count, index }) => index === 0;
const ɵ0 = computeFirst;
const computeLast = ({ count, index }) => index === count - 1;
const ɵ1 = computeLast;
const computeEven = ({ count, index }) => index % 2 === 0;
const ɵ2 = computeEven;
class RxDefaultListViewContext {
    constructor(item, customProps) {
        this.item = item;
        this._item = new ReplaySubject(1);
        this.item$ = this._item.asObservable();
        this._context$ = new BehaviorSubject({
            index: -1,
            count: -1,
        });
        this.select = (props) => {
            return this.item$.pipe(pluck(...props));
        };
        // tslint:disable-next-line:no-unused-expression
        this.$implicit = item;
        if (customProps) {
            this.updateContext(customProps);
        }
    }
    set $implicit($implicit) {
        this._$implicit = $implicit;
        this._item.next($implicit);
    }
    get $implicit() {
        return this._$implicit;
    }
    get $complete() {
        return this._$complete;
    }
    get $error() {
        return this._$error;
    }
    get $suspense() {
        return this._$suspense;
    }
    get index() {
        return this._context$.getValue().index;
    }
    get count() {
        return this._context$.getValue().count;
    }
    get first() {
        return computeFirst(this._context$.getValue());
    }
    get last() {
        return computeLast(this._context$.getValue());
    }
    get even() {
        return computeEven(this._context$.getValue());
    }
    get odd() {
        return !this.even;
    }
    get index$() {
        return this._context$.pipe(pluck('index'), distinctUntilChanged());
    }
    get count$() {
        return this._context$.pipe(pluck('count'), distinctUntilChanged());
    }
    get first$() {
        return this._context$.pipe(map(computeFirst), distinctUntilChanged());
    }
    get last$() {
        return this._context$.pipe(map(computeLast), distinctUntilChanged());
    }
    get even$() {
        return this._context$.pipe(map(computeEven), distinctUntilChanged());
    }
    get odd$() {
        return this.even$.pipe(map((even) => !even));
    }
    updateContext(newProps) {
        this._context$.next(Object.assign(Object.assign({}, this._context$.getValue()), newProps));
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { RxBaseTemplateNames, RxDefaultListViewContext, createListTemplateManager, createTemplateManager, templateHandling };
//# sourceMappingURL=cdk-template.js.map
