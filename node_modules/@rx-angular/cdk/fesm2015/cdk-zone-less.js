import { ɵglobal } from '@angular/core';
import * as rxjs from 'rxjs';
import { Subscription, Observable } from 'rxjs';
import { map } from 'rxjs/operators';

function getZoneUnPatchedApi(targetOrName, name) {
    // If the user has provided the API name as the first argument, for instance:
    // `const addEventListener = getZoneUnPatchedApi('addEventListener');`
    // Then we just swap arguments and make `global` or `window` as the default target.
    if (typeof targetOrName === 'string') {
        name = targetOrName;
        targetOrName = ɵglobal;
    }
    return targetOrName['__zone_symbol__' + name] || targetOrName[name];
}

/**
 * This file provides unpatched versions of APIs patched in the following file: https://github.com/angular/angular/blob/master/packages/zone.js/lib/browser/browser.ts
 */
/**
 * This function is a zone un-patched implementation of Window#queueMicrotask() method.
 * It is which is exposed on the Window or Worker interface,
 * queues a microtask to be executed at a safe time prior to control returning to the browser's event loop.
 * The microtask is a short function which will run after the current task has completed its
 * work and when there is no other code waiting to be run before control of the execution context is returned to the browser's event loop.
 */
function queueMicrotask() {
    return getZoneUnPatchedApi('queueMicrotask');
}
const Promise$1 = getZoneUnPatchedApi('Promise');
/**
 * requestAnimationFrame
 *
 * @description
 *
 * This function is a zone un-patched implementation of Window#requestAnimationFrame() method
 *
 * The requestAnimationFrame() method calls a function or evaluates an expression on the next animationFrame.
 * The requestAnimationFrame() method will not continue calling the function after executed once.
 * The ID value returned by requestAnimationFrame() is used as the parameter for the cancelAnimationFrame() method.
 *
 * requestAnimationFrame(cb, ms);
 *
 * @param cb - Required. The function that will be executed
 *
 */
function requestAnimationFrame(cb) {
    return getZoneUnPatchedApi('requestAnimationFrame')(cb);
}
/**
 * cancelAnimationFrame
 *
 * @description
 *
 * This function is a zone un-patched implementation of Window cancelAnimationFrame() method
 *
 * The cancelAnimationFrame() method clears a timer set with the requestAnimationFrame() method.
 * The ID value returned by requestAnimationFrame() is used as the parameter for the cancelAnimationFrame() method.
 *
 * To be able to use the cancelAnimationFrame() method, you must use a variable when creating the requestAnimationFrame method:
 *
 * const id = requestAnimationFrame("javascript function");
 * Then you will be able to stop the execution by calling the cancelAnimationFrame() method.
 *
 * cancelAnimationFrame(id);
 *
 * @param id {number} - Required. The ID value of the timer returned by the requestAnimationFrame() method
 *
 */
function cancelAnimationFrame(id) {
    getZoneUnPatchedApi('cancelAnimationFrame')(id);
}
/**
 * setInterval
 *
 * @description
 *
 * This function is a zone un-patched implementation of Window setInterval() method
 *
 * The setInterval() method calls a function or evaluates an expression at specified intervals (in milliseconds).
 * The setInterval() method will continue calling the function until clearInterval() is called, or the window is closed.
 * The ID value returned by setInterval() is used as the parameter for the clearInterval() method.
 *
 * setInterval(cb, ms);
 *
 * @param cb - Required. The function that will be executed
 * @param ms - Required. The intervals (in milliseconds) on how often to execute the code. If the value is less than 10, the value 10 is used
 *
 */
function setInterval(cb, ms = 0) {
    return getZoneUnPatchedApi('setInterval')(cb, ms);
}
/**
 * clearInterval
 *
 * @description
 *
 * This function is a zone un-patched implementation of Window clearInterval() method
 *
 * The clearInterval() method clears a timer set with the setInterval() method.
 * The ID value returned by setInterval() is used as the parameter for the clearInterval() method.
 *
 * To be able to use the clearInterval() method, you must use a variable when creating the interval method:
 *
 * const id = setInterval("javascript function", milliseconds);
 * Then you will be able to stop the execution by calling the clearInterval() method.
 *
 * clearInterval(id);
 *
 * @param id {number} - Required. The ID value of the timer returned by the setInterval() method
 *
 */
function clearInterval(id) {
    return getZoneUnPatchedApi('clearInterval')(id);
}
/**
 * setTimeout
 *
 * @description
 *
 * This function is a zone un-patched implementation of Window setTimeout() method
 *
 * The setTimeout() method calls a function or evaluates an expression after a specified number of milliseconds.
 * The function is only executed once. If you need to repeat execution, use the setInterval() method.
 * Use the clearTimeout() method to prevent the function from running.
 *
 * setTimeout(cb, ms);
 *
 * @param cb - Required. The function that will be executed
 * @param ms - Optional. The number of milliseconds to wait before executing the code. If omitted, the value 0 is used
 *
 */
function setTimeout(cb, ms = 0) {
    return getZoneUnPatchedApi('setTimeout')(cb, ms);
}
/**
 * clearTimeout
 *
 * @description
 *
 * This function is a zone un-patched implementation of Window#clearTimeout() method
 *
 * The clearTimeout() method clears a timer set with the setTimeout() method.
 * The ID value returned by setTimeout() is used as the parameter for the clearTimeout() method.
 *
 * const id = setTimeout("javascript function", milliseconds);
 * Then, if the function has not already been executed, you will be able to stop the execution by calling the clearTimeout() method.
 *
 * clearTimeout(id);
 *
 * @param id {number} -	Required. The ID value of the timer returned by the setTimeout() method
 *
 */
function clearTimeout(id) {
    getZoneUnPatchedApi('clearTimeout')(id);
}
/**
 * This function is a zone un-patched implementation of Element#addEventListener() method.
 * @param target
 */
function unpatchAddEventListener(target) {
    target.addEventListener = getZoneUnPatchedApi(target, 'addEventListener').bind(target);
    return target;
}

// tslint:disable
/**
 * A unit of work to be executed in a `scheduler`. An action is typically
 * created from within a {@link SchedulerLike} and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
class Action extends Subscription {
    constructor(scheduler, work) {
        super();
    }
    /**
     * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    schedule(state, delay = 0) {
        return this;
    }
}

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
class AsyncAction extends Action {
    constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    schedule(state, delay = 0) {
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        const id = this.id;
        const scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    }
    requestAsyncId(scheduler, id, delay = 0) {
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    }
    recycleAsyncId(scheduler, id, delay = 0) {
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay != null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        clearInterval(id);
        return undefined;
    }
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    execute(state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        const error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    }
    _execute(state, delay) {
        let errored = false;
        let errorValue;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = (!!e && e) || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    }
    unsubscribe() {
        if (!this.closed) {
            const { id, scheduler } = this;
            const { actions } = scheduler;
            this.work = this.state = this.scheduler = null;
            this.pending = false;
            // arrRemove
            if (actions) {
                const index = actions.indexOf(this);
                0 <= index && actions.splice(index, 1);
            }
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, null);
            }
            this.delay = null;
            super.unsubscribe();
        }
    }
}

/**
 * Schedulers rely on provided actions and actions are using some asynchronous API
 * internally, e.g. `setInterval`, etc. We don't wanna copy-paste the code of all schedulers
 * here since it'll increase the bundle size. We can re-use constructors of RxJS schedulers
 * and provide our custom actions that use the unpatched API.
 */
function createScheduler(scheduler, action) {
    // The `Reflect.construct` is a cross-browser feature, it's only not supported in IE11,
    // but apps anyway require polyfills if they want to be run in IE11.
    return Reflect.construct(scheduler.constructor, [action]);
}

// tslint:disable file-name-casing
/**
 *
 * NOTE: This is a zone un-patched version of rxjs asyncScheduler
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asapScheduler} scheduler.
 *
 * ## Examples
 * Use async scheduler to delay task
 * ```ts
 * import { asyncScheduler } from '@cu/perf-utils';
 *
 * const task = () => console.log('it works!');
 *
 * asyncScheduler.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 * ```
 *
 * Use async scheduler to repeat task in intervals
 * ```ts
 * import { asyncScheduler } from '@cu/perf-utils';
 *
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * asyncScheduler.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 * ```
 */
const asyncScheduler = createScheduler(rxjs.asyncScheduler, AsyncAction);

function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !Array.isArray(val) && val - parseFloat(val) + 1 >= 0;
}
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}

/**
 * Creates an Observable that emits sequential numbers every specified
 * interval of time, on a specified {@link SchedulerLike}.
 *
 * <span class="informal">Emits incremental numbers periodically in time.
 * </span>
 *
 * ![](interval.png)
 *
 * `interval` returns an Observable that emits an infinite sequence of
 * ascending integers, with a constant interval of time of your choosing
 * between those emissions. The first emission is not sent immediately, but
 * only after the first period has passed. By default, this operator uses the
 * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any
 * {@link SchedulerLike} to it.
 *
 * ## Example
 * Emits ascending numbers, one every second (1000ms) up to the number 3
 * ```ts
 * import { interval } from 'rxjs';
 * import { take } from 'rxjs/operators';
 *
 * const numbers = interval(1000);
 *
 * const takeFourNumbers = numbers.pipe(take(4));
 *
 * takeFourNumbers.subscribe(x => console.log('Next: ', x));
 *
 * // Logs:
 * // Next: 0
 * // Next: 1
 * // Next: 2
 * // Next: 3
 * ```
 *
 * @see {@link timer}
 * @see {@link delay}
 *
 * @param {number} [period=0] The interval size in milliseconds (by default)
 * or the time unit determined by the scheduler's clock.
 * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling
 * the emission of values, and providing a notion of "time".
 * @return {Observable} An Observable that emits a sequential number each time
 * interval.
 * @static true
 * @name interval
 * @owner Observable
 */
function interval(period = 0, scheduler = asyncScheduler) {
    if (!isNumeric(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = asyncScheduler;
    }
    return new Observable((subscriber) => {
        subscriber.add(scheduler.schedule(dispatch$1, period, { subscriber, counter: 0, period }));
        return subscriber;
    });
}
function dispatch$1(state) {
    const { subscriber, counter, period } = state;
    subscriber.next(counter);
    this.schedule({ subscriber, counter: counter + 1, period }, period);
}

/**
 * Creates an Observable that starts emitting after an `dueTime` and
 * emits ever increasing numbers after each `period` of time thereafter.
 *
 * <span class="informal">Its like {@link index/interval}, but you can specify when
 * should the emissions start.</span>
 *
 * ![](timer.png)
 *
 * `timer` returns an Observable that emits an infinite sequence of ascending
 * integers, with a constant interval of time, `period` of your choosing
 * between those emissions. The first emission happens after the specified
 * `dueTime`. The initial delay may be a `Date`. By default, this
 * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you
 * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output
 * Observable emits only one value, `0`. Otherwise, it emits an infinite
 * sequence.
 *
 * ## Examples
 * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds
 * ```ts
 * import { timer } from 'rxjs';
 *
 * const numbers = timer(3000, 1000);
 * numbers.subscribe(x => console.log(x));
 * ```
 *
 * ### Emits one number after five seconds
 * ```ts
 * import { timer } from 'rxjs';
 *
 * const numbers = timer(5000);
 * numbers.subscribe(x => console.log(x));
 * ```
 * @see {@link index/interval}
 * @see {@link delay}
 *
 * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting
 * milliseconds to wait before emitting the first value of 0`.
 * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the
 * subsequent numbers.
 * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling
 * the emission of values, and providing a notion of "time".
 * @return {Observable} An Observable that emits a `0` after the
 * `dueTime` and ever increasing numbers after each `period` of time
 * thereafter.
 * @static true
 * @name timer
 * @owner Observable
 */
function timer(dueTime = 0, periodOrScheduler, scheduler) {
    let period = -1;
    if (isNumeric(periodOrScheduler)) {
        period = (Number(periodOrScheduler) < 1 && 1) || Number(periodOrScheduler);
    }
    else if (isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!isScheduler(scheduler)) {
        scheduler = asyncScheduler;
    }
    return new Observable((subscriber) => {
        const due = isNumeric(dueTime)
            ? dueTime
            : +dueTime - scheduler.now();
        return scheduler.schedule(dispatch, due, {
            index: 0,
            period,
            subscriber,
        });
    });
}
function dispatch(state) {
    const { index, period, subscriber } = state;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}

// tslint:disable
// @ts-ignore
const isFunction = (fn) => typeof fn === 'function';
const ɵ0 = isFunction;
const isArray = Array.isArray;
const ɵ1 = () => Object.prototype.toString;
const toString = (ɵ1)();
/* tslint:enable:max-line-length */
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
        // DEPRECATED PATH
        // @ts-ignore
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        // DEPRECATED PATH
        return fromEvent(target, eventName, options).pipe(map((args) => isArray(args) ? resultSelector(...args) : resultSelector(args)));
    }
    return new Observable((subscriber) => {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    let unsubscribe;
    if (isEventTarget(sourceObj)) {
        const source = sourceObj;
        getZoneUnPatchedApi(sourceObj, 'addEventListener').call(sourceObj, eventName, handler, options);
        unsubscribe = () => getZoneUnPatchedApi(source, 'removeEventListener').call(source, eventName, handler, options);
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        const source = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = () => source.off(eventName, handler);
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        const source = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = () => source.removeListener(eventName, handler);
    }
    else if (sourceObj && sourceObj.length) {
        for (let i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return (sourceObj &&
        typeof sourceObj.addListener === 'function' &&
        typeof sourceObj.removeListener === 'function');
}
function isJQueryStyleEventEmitter(sourceObj) {
    return (sourceObj &&
        typeof sourceObj.on === 'function' &&
        typeof sourceObj.off === 'function');
}
function isEventTarget(sourceObj) {
    return (sourceObj &&
        typeof sourceObj.addEventListener === 'function' &&
        typeof sourceObj.removeEventListener === 'function');
}

// tslint:disable
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
class AsapAction extends AsyncAction {
    constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    requestAsyncId(scheduler, id, delay = 0) {
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return super.requestAsyncId(scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        scheduler.actions.push(this);
        // If a microtask has already been scheduled, don't schedule another
        // one. If a microtask hasn't been scheduled yet, schedule one now. Return
        // the current scheduled microtask id.
        return (scheduler.scheduled ||
            (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, undefined))));
    }
    recycleAsyncId(scheduler, id, delay = 0) {
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return super.recycleAsyncId(scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested microtask and
        // set the scheduled flag to undefined so the next AsapAction will schedule
        // its own.
        if (scheduler.actions.length === 0) {
            Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    }
}
let nextHandle = 1;
// The promise needs to be created lazily otherwise it won't be patched by Zones
let resolved;
const activeHandles = {};
/**
 * Finds the handle in the list of active handles, and removes it.
 * Returns `true` if found, `false` otherwise. Used both to clear
 * Immediate scheduled tasks, and to identify if a task should be scheduled.
 */
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
/**
 * Helper functions to schedule and unschedule microtasks.
 */
const Immediate = {
    setImmediate(cb) {
        const handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
            resolved = Promise$1.resolve();
        }
        resolved.then(() => findAndClearHandle(handle) && cb());
        return handle;
    },
    clearImmediate(handle) {
        findAndClearHandle(handle);
    },
};
/**
 * Used for internal testing purposes only. Do not export from library.
 */
const TestTools = {
    pending() {
        return Object.keys(activeHandles).length;
    },
};

// tslint:disable file-name-casing
/**
 *
 * NOTE: This is a zone un-patched version of rxjs asapScheduler
 *
 * Asap Scheduler
 *
 * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
 *
 * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task
 * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
 * code to end and then it will try to execute given task as fast as possible.
 *
 * `asap` scheduler will do its best to minimize time between end of currently executing code
 * and start of scheduled task. This makes it best candidate for performing so called "deferring".
 * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
 * some (although minimal) unwanted delay.
 *
 * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
 * after currently executing code. In particular, if some task was also scheduled with `asap` before,
 * that task will execute first. That being said, if you need to schedule task asynchronously, but
 * as soon as possible, `asap` scheduler is your best bet.
 *
 * ## Example
 * Compare async and asap scheduler<
 * ```ts
 * import { asapScheduler, asyncScheduler } from '@cu/perf-utils';
 *
 * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...
 * asapScheduler.schedule(() => console.log('asap'));
 *
 * // Logs:
 * // "asap"
 * // "async"
 * // ... but 'asap' goes first!
 * ```
 */
const asapScheduler = createScheduler(rxjs.asapScheduler, AsapAction);

// tslint:disable
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
class QueueAction extends AsyncAction {
    constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    schedule(state, delay = 0) {
        if (delay > 0) {
            return super.schedule(state, delay);
        }
        this.delay = delay;
        this.state = state;
        // @ts-ignore
        this.scheduler.flush(this);
        return this;
    }
    execute(state, delay) {
        return delay > 0 || this.closed
            ? super.execute(state, delay)
            : this._execute(state, delay);
    }
    requestAsyncId(scheduler, id, delay = 0) {
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return super.requestAsyncId(scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        // @ts-ignore
        return scheduler.flush(this);
    }
}

// tslint:disable file-name-casing
/**
 *
 * NOTE: This is a zone un-patched version of rxjs queueScheduler
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * ## Examples
 * Schedule recursively first, then do something
 * ```ts
 * import { queueScheduler } from '@cu/perf-utils';
 *
 * queueScheduler.schedule(() => {
 *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 * ```
 *
 * Reschedule itself recursively
 * ```ts
 * import { queueScheduler } from '@cu/perf-utils';
 *
 * queueScheduler.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 * ```
 */
const queueScheduler = createScheduler(rxjs.queueScheduler, QueueAction);

// tslint:disable
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
class AnimationFrameAction extends AsyncAction {
    constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    requestAsyncId(scheduler, id, delay = 0) {
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return super.requestAsyncId(scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        // @ts-ignore
        scheduler.actions.push(this);
        // If an animation frame has already been requested, don't request another
        // one. If an animation frame hasn't been requested yet, request one. Return
        // the current animation frame request id.
        return (scheduler.scheduled ||
            (scheduler.scheduled = requestAnimationFrame(() => scheduler.flush(undefined))));
    }
    recycleAsyncId(scheduler, id, delay = 0) {
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return super.recycleAsyncId(scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested animation frame and
        // set the scheduled flag to undefined so the next AnimationFrameAction will
        // request its own.
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    }
}

// tslint:disable file-name-casing
/**
 *
 * NOTE: This is a zone un-patched version of rxjs animationFrameScheduler
 *
 * Animation Frame Scheduler
 *
 * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
 *
 * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler
 * behaviour.
 *
 * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
 * It makes sure scheduled task will happen just before next browser content repaint,
 * thus performing animations as efficiently as possible.
 *
 * ## Example
 * Schedule div height animation
 * ```ts
 * // html: <div style="background: #0ff;"></div>
 * import { animationFrameScheduler } from '@cu/perf-utils';
 *
 * const div = document.querySelector('div');
 *
 * animationFrameScheduler.schedule(function(height) {
 *   div.style.height = height + "px";
 *
 *   this.schedule(height + 1);  // `this` references currently executing Action,
 *                               // which we reschedule with new state
 * }, 0, 0);
 *
 * // You will see a div element growing in height
 * ```
 */
const animationFrameScheduler = createScheduler(rxjs.animationFrameScheduler, AnimationFrameAction);

/**
 * Generated bundle index. Do not edit.
 */

export { Promise$1 as Promise, animationFrameScheduler, asapScheduler, asyncScheduler, cancelAnimationFrame, clearInterval, clearTimeout, fromEvent, getZoneUnPatchedApi, interval, queueScheduler, requestAnimationFrame, setInterval, setTimeout, timer, unpatchAddEventListener, createScheduler as ɵa, AsyncAction as ɵb, Action as ɵc, AsapAction as ɵf, QueueAction as ɵh, AnimationFrameAction as ɵj };
//# sourceMappingURL=cdk-zone-less.js.map
