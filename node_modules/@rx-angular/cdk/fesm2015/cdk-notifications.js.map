{"version":3,"file":"cdk-notifications.js","sources":["../../../../libs/cdk/notifications/src/lib/notification-transforms.ts","../../../../libs/cdk/notifications/src/lib/template-trigger-handling.ts","../../../../libs/cdk/notifications/src/lib/rx-materialize.ts","../../../../libs/cdk/notifications/src/lib/create-template-notifier.ts","../../../../libs/cdk/notifications/src/cdk-notifications.ts"],"sourcesContent":["import {\r\n  RxSuspenseNotification,\r\n  RxNotificationKind,\r\n  RxErrorNotification,\r\n  RxCompleteNotification,\r\n} from './model';\r\n\r\nexport function toRxErrorNotification<T>(\r\n  error?: any,\r\n  value?: T\r\n): RxErrorNotification<T> {\r\n  return {\r\n    value,\r\n    kind: RxNotificationKind.Error,\r\n    hasValue: !!value || false,\r\n    complete: false,\r\n    error: error || true,\r\n  };\r\n}\r\n\r\nexport function toRxSuspenseNotification<T>(\r\n  value?: T\r\n): RxSuspenseNotification<T> {\r\n  return {\r\n    value,\r\n    kind: RxNotificationKind.Suspense,\r\n    hasValue: !!value || false,\r\n    complete: false,\r\n    error: false,\r\n  };\r\n}\r\n\r\nexport function toRxCompleteNotification<T>(\r\n  value?: T\r\n): RxCompleteNotification<T> {\r\n  return {\r\n    value,\r\n    kind: RxNotificationKind.Complete,\r\n    hasValue: !!value || false,\r\n    complete: true,\r\n    error: false,\r\n  };\r\n}\r\n","import { Observable, Subject } from 'rxjs';\r\nimport { mergeAll, share } from 'rxjs/operators';\r\n\r\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\r\n\r\nimport { RxNotification } from './model';\r\n\r\n/**\r\n * @internal\r\n *\r\n * A factory function returning an object to handle the process of switching templates by Notification channel.\r\n * You can next a Observable of `RxNotification` multiple times and merge them into the Observable exposed under `trigger$`\r\n *\r\n */\r\nexport function templateTriggerHandling<T>(): {\r\n  trigger$: Observable<RxNotification<T>>;\r\n  next(templateName: Observable<RxNotification<T>>): void;\r\n} {\r\n  const hotFlattened = coerceAllFactory(\r\n    () => new Subject<Observable<RxNotification<T> | RxNotification<T>>>(),\r\n    mergeAll()\r\n  );\r\n  return {\r\n    next(templateName: Observable<RxNotification<T> | RxNotification<T>>) {\r\n      hotFlattened.next(templateName);\r\n    },\r\n    trigger$: hotFlattened.values$.pipe(share()),\r\n  };\r\n}\r\n","import { OperatorFunction, ObservableNotification } from 'rxjs';\r\nimport { map, materialize, tap } from 'rxjs/operators';\r\n\r\nimport { RxNotification, RxNotificationKind } from './model';\r\n\r\nexport function rxMaterialize<T>(): OperatorFunction<T, RxNotification<T>> {\r\n  return (o$) =>\r\n    o$.pipe(\r\n      materialize(),\r\n      tap(({ kind, error }) => {\r\n        // As we dont want to just swallow errors we log them here\r\n        if (kind === 'E') {\r\n          console.error(error);\r\n        }\r\n      }),\r\n      map(({ value, error, kind }) => {\r\n        const rxNotificationKind = notificationKindToRxNotificationKind(kind);\r\n        return {\r\n          value,\r\n          hasValue: kind === 'N',\r\n          error,\r\n          kind: rxNotificationKind,\r\n          complete: rxNotificationKind === RxNotificationKind.Complete,\r\n        };\r\n      })\r\n    );\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * @description\r\n * This function is here to turn RxJS notification kind values into RxNotification kind names.\r\n * The main reason for the naming is the RxNotification kind values map directly to the default\r\n * template names (`suspense`, `next`, `error` `complete`) in the directives of the template package\r\n */\r\nexport function notificationKindToRxNotificationKind(\r\n  kind: ObservableNotification<unknown>['kind']\r\n): RxNotificationKind {\r\n  switch (kind) {\r\n    case 'C':\r\n      return RxNotificationKind.Complete;\r\n    case 'E':\r\n      return RxNotificationKind.Error;\r\n    case 'N':\r\n    default:\r\n      return RxNotificationKind.Next;\r\n  }\r\n}\r\n","import {\r\n  from,\r\n  isObservable,\r\n  NEVER,\r\n  Observable,\r\n  ObservableInput,\r\n  of,\r\n  ReplaySubject\r\n} from 'rxjs';\r\nimport {\r\n  distinctUntilChanged,\r\n  filter,\r\n  map,\r\n  startWith,\r\n  switchMap,\r\n} from 'rxjs/operators';\r\n\r\nimport { rxMaterialize } from './rx-materialize';\r\nimport { RxNotification, RxNotificationKind } from './model';\r\nimport { toRxSuspenseNotification } from './notification-transforms';\r\n\r\nconst calcWithSuspenseTpl = (withSuspenseTpl?: () => boolean): boolean => withSuspenseTpl && withSuspenseTpl();\r\n\r\n/**\r\n * @description\r\n * Sends value and an initial `undefined` as value With a NEVER.\r\n * This is needed to render the suspense template and avoid completing (and render the complete template).\r\n * @param value\r\n */\r\nconst emitAndDontComplete = (value) => NEVER.pipe(startWith(value));\r\n/**\r\n* @description\r\n* Flags the first run.\r\n* This is important as we want to create laziness in the template.\r\n* If no value ever is emitted we dont want to create/render the value (next template).\r\n* In case a suspense template is given (calculated by `withSuspense` param) we render the suspense template on the first run.\r\n*/\r\nconst mapFirst = <T>(transformation: (value: any) => any) => (o$: Observable<T>): Observable<T> => {\r\n  let firstRun = true;\r\n  return o$.pipe(\r\n    map((value) => {\r\n      if(!firstRun) {\r\n        return value;\r\n      }\r\n      const result = transformation(value);\r\n      firstRun = false;\r\n      return result;\r\n    })\r\n  )\r\n}\r\n\r\n/**\r\n * This helper is responsible for turning a stream of materialized notifications\r\n * (next error, complete as object in the next stream) into an enriched version with an additional suspense notification type.\r\n *\r\n * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.\r\n * This value is important in the template to show an e.g. error and also have access to the last emitted value of next.\r\n * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner in case of the suspense state.\r\n *\r\n * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification\r\n * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification\r\n * and assign it as new value to the notification\r\n */\r\nconst handleSuspenseAndLastValueInNotifications = <T>() => {\r\n  // Used to store the last value per handleSuspenseAndLastValueInNotifications call\r\n  let  latestNextValue: T;\r\n\r\n  // returns a projection function with a lastValue cache\r\n  return (notification: RxNotification<T>): RxNotification<T> => {\r\n    // if it the notification is of type next we take its value\r\n    // otherwise we keep the existing last value\r\n    if(notification.kind === RxNotificationKind.Next) {\r\n      latestNextValue = notification.value;\r\n    }\r\n\r\n    // If a next notification enters with a value of undefined we turn it into a suspense notification\r\n    if (\r\n      notification.kind === RxNotificationKind.Next &&\r\n      notification.value === undefined\r\n    ) {\r\n      return toRxSuspenseNotification(undefined) as RxNotification<T>;\r\n    }\r\n\r\n    // If a Notification of type error, complete or suspense enters we assign the latest last value to them.\r\n    // This is needed to access the old value in case of error or complete.\r\n    // Next notifications will pass as they are.\r\n    if(\r\n      notification.kind === RxNotificationKind.Error ||\r\n      notification.kind === RxNotificationKind.Complete ||\r\n      notification.kind === RxNotificationKind.Suspense) {\r\n      notification.value = latestNextValue;\r\n    }\r\n\r\n    return notification as RxNotification<T>;\r\n  }\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * @description\r\n * This factory function returns an object that can be driven imperatively over a `next` method.\r\n * Internally it prepares the incoming values for rendering by turning them into \"template notifications\",\r\n * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing or suspense states.\r\n *\r\n * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.\r\n * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the display of\r\n * the default template as well as the suspense, error, complete templates.\r\n */\r\nexport function createTemplateNotifier<U>(withSuspenseTpl?: () => boolean): {\r\n  values$: Observable<RxNotification<U>>;\r\n  next(observable: ObservableInput<U> | U): void;\r\n} {\r\n  // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties\r\n  const observablesSubject = new ReplaySubject<ObservableInput<U>>(1);\r\n\r\n\r\n  const values$ = observablesSubject.pipe(\r\n    distinctUntilChanged(),\r\n    // Handle initialization edge cases\r\n    mapFirst((value) => {\r\n\r\n      const isUndefined = value === undefined;\r\n        const isNEVER = value === NEVER;\r\n        // If it is a `NEVER` Observable we know it will never emit a value nor complete or error.\r\n        // Therefore we emit directly undefined to signal a suspense state\r\n\r\n      if((isUndefined || isNEVER)) {\r\n        // Determines if a suspense notification is needed\r\n        const isSuspenseTemplateGiven = calcWithSuspenseTpl(withSuspenseTpl);\r\n\r\n        // Render suspense template if given. Otherwise do nothing (later undefined are filtered out)\r\n        return isSuspenseTemplateGiven ? emitAndDontComplete(undefined) : undefined\r\n      }\r\n\r\n      const isNull = value === null;\r\n\r\n      if (isNull) {\r\n        // We return the value and no undefined as first value\r\n        // as we dont need to render the suspense template for null values (it is considered as not used)\r\n        return of(null);\r\n      }\r\n\r\n      return value;\r\n    }),\r\n    // `undefined` values are only processed once at beginning to initialize lazy. After that they are filtered out.\r\n    filter((v) => v !== undefined),\r\n    // handle static values inc null assignment and new Observable or Promises\r\n    map((observable$): Observable<ObservableInput<U> | U> => {\r\n      const isNull = observable$ === null;\r\n      const isPromiseOrObs = typeof (observable$ as any).then === 'function' || isObservable(observable$);\r\n      // A value is considered as static value if it is `null`, or any other value than `undefined`, `Promise`, `Observable`\r\n      const isStaticValue = !isPromiseOrObs && !(observable$ === undefined) || isNull;\r\n\r\n      const isNEVER = observable$ === NEVER;\r\n      // If it is a `NEVER` Observable we know it will never emit a value nor complete or error.\r\n      // Therefore we emit directly undefined to signal a suspense state\r\n      if (isNEVER) {\r\n        // Render suspense template for null values (it is considered as not used)\r\n        return emitAndDontComplete(undefined);\r\n      }\r\n\r\n      // If it is a static value forward directly\r\n      if (isStaticValue) {\r\n        // Render next template for static values (it is considered as kinda sync)\r\n        return emitAndDontComplete(observable$);\r\n      }\r\n\r\n      return from(observable$).pipe(\r\n        (o$) => {\r\n          // Determines if a suspense notification is needed\r\n          const isSuspenseTemplateGiven = calcWithSuspenseTpl(withSuspenseTpl);\r\n\r\n          if (isSuspenseTemplateGiven) {\r\n            // Render suspense template\r\n            return o$.pipe(startWith(undefined));\r\n          }\r\n          return o$;\r\n        }\r\n      );\r\n    }),\r\n    switchMap((o: Observable<U>) => {\r\n      return o.pipe(\r\n        distinctUntilChanged(),\r\n        rxMaterialize(),\r\n        map(handleSuspenseAndLastValueInNotifications<U>())\r\n      );\r\n    })\r\n  );\r\n\r\n  return {\r\n    next(observable: ObservableInput<U>) {\r\n      observablesSubject.next(observable);\r\n    },\r\n    values$,\r\n  };\r\n}\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}