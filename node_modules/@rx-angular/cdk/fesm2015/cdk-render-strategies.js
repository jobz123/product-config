import * as i0 from '@angular/core';
import { ɵmarkDirty, InjectionToken, Injectable, Optional, Inject } from '@angular/core';
import { Observable, throwError, of, BehaviorSubject, fromEvent, ReplaySubject } from 'rxjs';
import { filter, switchMap, mapTo, tap, take, map, shareReplay, takeUntil, switchAll, startWith, share } from 'rxjs/operators';
import { forceFrameRate, scheduleCallback, cancelCallback } from '@rx-angular/cdk/internals/scheduler';
import { coalescingManager, coalesceWith } from '@rx-angular/cdk/coalescing';
import { requestAnimationFrame, cancelAnimationFrame } from '@rx-angular/cdk/zone-less';
import { coerceAllFactory } from '@rx-angular/cdk/coercing';

forceFrameRate(60);
const ɵ0$1 = (cdRef) => cdRef.detectChanges(), ɵ1$1 = (work, scope) => {
    return (o$) => o$.pipe(scheduleOnQueue(work, { priority: 0 /* NoPriority */, scope }));
};
const noPriorityStrategy = {
    name: 'noPriority',
    work: ɵ0$1,
    behavior: ɵ1$1,
};
const ɵ2$1 = (cdRef) => cdRef.detectChanges(), ɵ3$1 = (work, scope) => {
    return (o$) => o$.pipe(scheduleOnQueue(work, {
        priority: 1 /* ImmediatePriority */,
        scope,
    }));
};
const immediateStrategy = {
    name: 'immediate',
    work: ɵ2$1,
    behavior: ɵ3$1,
};
const ɵ4$1 = (cdRef) => cdRef.detectChanges(), ɵ5$1 = (work, scope) => {
    return (o$) => o$.pipe(scheduleOnQueue(work, {
        priority: 2 /* UserBlockingPriority */,
        scope,
    }));
};
const userBlockingStrategy = {
    name: 'userBlocking',
    work: ɵ4$1,
    behavior: ɵ5$1,
};
const ɵ6$1 = (cdRef) => cdRef.detectChanges(), ɵ7$1 = (work, scope) => {
    return (o$) => o$.pipe(scheduleOnQueue(work, { priority: 3 /* NormalPriority */, scope }));
};
const normalStrategy = {
    name: 'normal',
    work: ɵ6$1,
    behavior: ɵ7$1,
};
const ɵ8$1 = (cdRef) => cdRef.detectChanges(), ɵ9 = (work, scope) => {
    return (o$) => o$.pipe(scheduleOnQueue(work, { priority: 4 /* LowPriority */, scope }));
};
const lowStrategy = {
    name: 'low',
    work: ɵ8$1,
    behavior: ɵ9,
};
const ɵ10 = (cdRef) => cdRef.detectChanges(), ɵ11 = (work, scope) => {
    return (o$) => o$.pipe(scheduleOnQueue(work, { priority: 5 /* IdlePriority */, scope }));
};
const idleStrategy = {
    name: 'idle',
    work: ɵ10,
    behavior: ɵ11,
};
function scheduleOnQueue(work, options) {
    return (o$) => o$.pipe(filter(() => !coalescingManager.isCoalescing(options.scope)), switchMap((v) => new Observable((subscriber) => {
        coalescingManager.add(options.scope);
        const task = scheduleCallback(options.priority, () => {
            work();
            coalescingManager.remove(options.scope);
            subscriber.next(v);
        }, { delay: options.delay });
        return () => {
            coalescingManager.remove(options.scope);
            cancelCallback(task);
        };
    }).pipe(mapTo(v))));
}
const RX_CONCURRENT_STRATEGIES = {
    noPriority: noPriorityStrategy,
    immediate: immediateStrategy,
    userBlocking: userBlockingStrategy,
    normal: normalStrategy,
    low: lowStrategy,
    idle: idleStrategy,
};

const animationFrameTick = () => new Observable((subscriber) => {
    const id = requestAnimationFrame(() => {
        subscriber.next(0);
        subscriber.complete();
    });
    return () => {
        cancelAnimationFrame(id);
    };
});
const ɵ0 = animationFrameTick;
const ɵ1 = (cdRef, _, notification) => {
    cdRef.detectChanges();
}, ɵ2 = (work, scope) => (o$) => o$.pipe(coalesceWith(animationFrameTick(), scope), tap(() => work()));
const localCredentials = {
    name: 'local',
    work: ɵ1,
    behavior: ɵ2,
};
const ɵ3 = (_, context) => ɵmarkDirty(context), ɵ4 = (work) => (o$) => o$.pipe(tap(() => work()));
const globalCredentials = {
    name: 'global',
    work: ɵ3,
    behavior: ɵ4,
};
const ɵ5 = () => void 0, ɵ6 = () => (o$) => o$;
const noopCredentials = {
    name: 'noop',
    work: ɵ5,
    behavior: ɵ6,
};
const ɵ7 = (cdRef) => cdRef.markForCheck(), ɵ8 = (work) => (o$) => o$.pipe(tap(() => work()));
const nativeCredentials = {
    name: 'native',
    work: ɵ7,
    behavior: ɵ8,
};
const RX_NATIVE_STRATEGIES = {
    global: globalCredentials,
    native: nativeCredentials,
    noop: noopCredentials,
    local: localCredentials,
};

const RX_ANGULAR_CONFIG = new InjectionToken('rx-angular-config');
const RX_ANGULAR_DEFAULTS = {
    primaryStrategy: 'normal',
    customStrategies: Object.assign(Object.assign({}, RX_NATIVE_STRATEGIES), RX_CONCURRENT_STRATEGIES),
    patchZone: true
};
function mergeDefaultConfig(cfg) {
    const custom = cfg
        ? cfg
        : {
            customStrategies: {}
        };
    return Object.assign(Object.assign(Object.assign({}, RX_ANGULAR_DEFAULTS), custom), { customStrategies: Object.assign(Object.assign({}, custom.customStrategies), RX_ANGULAR_DEFAULTS.customStrategies) });
}

/**
 * @internal
 *
 * @param value
 * @param strategy
 * @param workFactory
 * @param options
 */
function onStrategy(value, strategy, workFactory, options = {}) {
    let error;
    return new Observable(subscriber => {
        subscriber.next(value);
    }).pipe(strategy.behavior(() => {
        try {
            workFactory(value, strategy.work, options);
        }
        catch (e) {
            error = e;
        }
    }, options.scope || {}), switchMap(() => error ? throwError([error, value]) : of(value)), take(1));
}

/**
 * @description
 * RxStrategyProvider is a wrapper service that you can use to consume strategies and schedule your code execution.
 *
 * @example
 * Component({
 *   selector: 'app-service-communicator',
 *   template: ``
 * });
 * export class ServiceCommunicationComponent {
 *   private currentUserSettings;
 *
 *   constructor(
 *     private strategyProvider: RxStrategyProvider,
 *     private userService: UserService,
 *     private backgroundSync: BackgroundSyncService
 *   ) {
 *     this.userService.fetchCurrentUserSettings
 *       .pipe(
 *         tap(settings => (this.currentUserSettings = settings)),
 *         this.strategyProvider.scheduleWith(
 *           settings => this.backgroundSync.openConnection(settings),
 *           { strategy: 'idle' }
 *         )
 *       )
 *       .subscribe();
 *   }
 * }
 *
 * @docsCategory RxStrategyProvider
 * @docsPage RxStrategyProvider
 */
class RxStrategyProvider {
    /**
     * @internal
     */
    constructor(cfg) {
        this._strategies$ = new BehaviorSubject(undefined);
        this._primaryStrategy$ = new BehaviorSubject(undefined);
        /**
         * @description
         * Current strategy of the service as an observable.
         */
        this.primaryStrategy$ = this._primaryStrategy$.asObservable();
        /**
         * @description
         * Returns observable of an object that contains key-value pairs of strategy names and their credentials (settings) that are available in the service.
         */
        this.strategies$ = this._strategies$.asObservable();
        /**
         * @description
         * Returns an observable of an array of strategy names available in the service.
         */
        this.strategyNames$ = this.strategies$.pipe(map((strategies) => Object.values(strategies).map((s) => s.name)), shareReplay({ bufferSize: 1, refCount: true }));
        this._cfg = mergeDefaultConfig(cfg);
        this._strategies$.next(this._cfg.customStrategies);
        this.primaryStrategy = this.config.primaryStrategy;
    }
    /**
     * @description
     * Returns current `RxAngularConfig` used in the service.
     * Config includes:
     * - strategy that currently in use - `primaryStrategy`
     * - array of custom user defined strategies - `customStrategies`
     * - setting that is responsible for running in our outside of the zone.js - `patchZone`
     */
    get config() {
        return this._cfg;
    }
    /**
     * @description
     * Returns object that contains key-value pairs of strategy names and their credentials (settings) that are available in the service.
     */
    get strategies() {
        return this._strategies$.getValue();
    }
    /**
     * @description
     * Returns an array of strategy names available in the service.
     */
    get strategyNames() {
        return Object.values(this.strategies).map((s) => s.name);
    }
    /**
     * @description
     * Returns current strategy of the service.
     */
    get primaryStrategy() {
        return this._primaryStrategy$.getValue().name;
    }
    /**
     * @description
     * Set's the strategy that will be used by the service.
     */
    set primaryStrategy(strategyName) {
        this._primaryStrategy$.next(this.strategies[strategyName]);
    }
    /**
     * @description
     * Allows to schedule a work inside rxjs `pipe`. Accepts the work and configuration options object.
     * - work is any function that should be executed
     * - (optional) options includes strategy, patchZone and scope
     *
     * Scope is by default a subscription but you can also pass `this` and then the scope will be current component.
     * Scope setup is useful if your work is some of the methods of `ChangeDetectorRef`. Only one change detection will be triggered if you have multiple schedules of change detection methods and scope is set to `this`.
     *
     * @example
     * myObservable$.pipe(
     *    this.strategyProvider.scheduleWith(() => myWork(), {strategy: 'idle', patchZone: false})
     * ).subscribe();
     *
     * @return MonoTypeOperatorFunction<R>
     */
    scheduleWith(work, options) {
        const strategy = this.strategies[(options === null || options === void 0 ? void 0 : options.strategy) || this.primaryStrategy];
        const scope = (options === null || options === void 0 ? void 0 : options.scope) || {};
        const _work = getWork(work, options === null || options === void 0 ? void 0 : options.patchZone);
        return (o$) => o$.pipe(switchMap((v) => onStrategy(v, strategy, (_v) => {
            _work(_v);
        }, { scope })));
    }
    /**
     * @description
     * Allows to schedule a work as an observable. Accepts the work and configuration options object.
     * - work is any function that should be executed
     * - (optional) options includes strategy, patchZone and scope
     *
     * Scope is by default a subscription but you can also pass `this` and then the scope will be current component.
     * Scope setup is especially useful if you provide work that will trigger a change detection.
     *
     * @example
     * this.strategyProvider.schedule(() => myWork(), {strategy: 'idle', patchZone: false}).subscribe();
     *
     * @return Observable<R>
     */
    schedule(work, options) {
        const strategy = this.strategies[(options === null || options === void 0 ? void 0 : options.strategy) || this.primaryStrategy];
        const scope = (options === null || options === void 0 ? void 0 : options.scope) || {};
        const _work = getWork(work, options === null || options === void 0 ? void 0 : options.patchZone);
        let returnVal;
        return onStrategy(null, strategy, () => {
            returnVal = _work();
        }, { scope }).pipe(map(() => returnVal));
    }
    /**
     * @description
     * Allows to schedule a change detection cycle. Accepts the ChangeDetectorRef and configuration options object.
     * Options include:
     * - afterCD which is the work that should be executed after change detection cycle.
     * - abortCtrl is an AbortController that you can use to cancel the scheduled cycle.
     *
     * @example
     * this.strategyProvider.scheduleCd(this.changeDetectorRef, {afterCD: myWork()});
     *
     * @return AbortController
     */
    scheduleCD(cdRef, options) {
        const strategy = this.strategies[(options === null || options === void 0 ? void 0 : options.strategy) || this.primaryStrategy];
        const scope = (options === null || options === void 0 ? void 0 : options.scope) || cdRef;
        const abC = (options === null || options === void 0 ? void 0 : options.abortCtrl) || new AbortController();
        const work = getWork(() => {
            strategy.work(cdRef, scope);
            if (options === null || options === void 0 ? void 0 : options.afterCD) {
                options.afterCD();
            }
        }, options.patchZone);
        onStrategy(null, strategy, () => {
            work();
        }, { scope })
            .pipe(takeUntil(fromEvent(abC.signal, 'abort')))
            .subscribe();
        return abC;
    }
}
/** @nocollapse */ RxStrategyProvider.ɵprov = i0.ɵɵdefineInjectable({ factory: function RxStrategyProvider_Factory() { return new RxStrategyProvider(i0.ɵɵinject(RX_ANGULAR_CONFIG, 8)); }, token: RxStrategyProvider, providedIn: "root" });
/** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
RxStrategyProvider.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/**
 * @type {function(): !Array<(null|{
 *   type: ?,
 *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),
 * })>}
 * @nocollapse
 */
RxStrategyProvider.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [RX_ANGULAR_CONFIG,] }] }
];
function getWork(work, patchZone) {
    let _work = work;
    if (patchZone) {
        _work = (args) => patchZone.run(() => work(args));
    }
    return _work;
}

/**
 * @internal
 *
 * A factory function returning an object to handle the process of turning strategy names into `RxStrategyCredentials`
 * You can next a strategy name as Observable or string and get an Observable of `RxStrategyCredentials`
 *
 * @param defaultStrategyName
 * @param strategies
 */
function strategyHandling(defaultStrategyName, strategies) {
    const hotFlattened = coerceAllFactory(() => new ReplaySubject(1), switchAll());
    return {
        strategy$: hotFlattened.values$.pipe(startWith(defaultStrategyName), nameToStrategyCredentials(strategies, defaultStrategyName), share()),
        next(name) {
            hotFlattened.next(name);
        },
    };
}
/**
 * @internal
 */
function nameToStrategyCredentials(strategies, defaultStrategyName) {
    return (o$) => o$.pipe(map((name) => name && Object.keys(strategies).includes(name)
        ? strategies[name]
        : strategies[defaultStrategyName]));
}

/**
 * Generated bundle index. Do not edit.
 */

export { RX_ANGULAR_CONFIG, RX_CONCURRENT_STRATEGIES, RX_NATIVE_STRATEGIES, RxStrategyProvider, onStrategy, strategyHandling };
//# sourceMappingURL=cdk-render-strategies.js.map
