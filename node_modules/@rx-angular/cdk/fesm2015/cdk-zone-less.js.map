{"version":3,"file":"cdk-zone-less.js","sources":["../../../../libs/cdk/zone-less/src/get-zone-unpatched-api/index.ts","../../../../libs/cdk/zone-less/src/browser/browser.ts","../../../../libs/cdk/zone-less/src/rxjs/scheduler/Action.ts","../../../../libs/cdk/zone-less/src/rxjs/scheduler/async/AsyncAction.ts","../../../../libs/cdk/zone-less/src/rxjs/scheduler/create-scheduler.ts","../../../../libs/cdk/zone-less/src/rxjs/scheduler/async/async.ts","../../../../libs/cdk/zone-less/src/rxjs/observable/utils.ts","../../../../libs/cdk/zone-less/src/rxjs/observable/interval.ts","../../../../libs/cdk/zone-less/src/rxjs/observable/timer.ts","../../../../libs/cdk/zone-less/src/rxjs/operators/fromEvent.ts","../../../../libs/cdk/zone-less/src/rxjs/scheduler/asap/AsapAction.ts","../../../../libs/cdk/zone-less/src/rxjs/scheduler/asap/asap.ts","../../../../libs/cdk/zone-less/src/rxjs/scheduler/queue/QueueAction.ts","../../../../libs/cdk/zone-less/src/rxjs/scheduler/queue/queue.ts","../../../../libs/cdk/zone-less/src/rxjs/scheduler/animation-frame/AnimationFrameAction.ts","../../../../libs/cdk/zone-less/src/rxjs/scheduler/animation-frame/animationFrame.ts","../../../../libs/cdk/zone-less/src/cdk-zone-less.ts"],"sourcesContent":["import { ɵglobal } from '@angular/core';\r\n\r\n/**\r\n * @description\r\n *\r\n * This function returns the zone un-patched API for the a specific Browser API.\r\n * If no target is passed the window is used instead\r\n *\r\n * @param name - The name of the API to check.\r\n * @param target - The target to get un-patched API from.\r\n * @return {Function} - The zone un-patched API in question.\r\n *\r\n */\r\nexport function getZoneUnPatchedApi<\r\n  N extends keyof (Window & typeof globalThis)\r\n>(name: N): (Window & typeof globalThis)[N];\r\n\r\nexport function getZoneUnPatchedApi<T extends object, N extends keyof T>(\r\n  target: T,\r\n  name: N\r\n): T[N];\r\n\r\nexport function getZoneUnPatchedApi<T extends object, N extends keyof T>(\r\n  targetOrName: T | string,\r\n  name?: N\r\n) {\r\n  // If the user has provided the API name as the first argument, for instance:\r\n  // `const addEventListener = getZoneUnPatchedApi('addEventListener');`\r\n  // Then we just swap arguments and make `global` or `window` as the default target.\r\n  if (typeof targetOrName === 'string') {\r\n    name = targetOrName as N;\r\n    targetOrName = ɵglobal as T;\r\n  }\r\n  return targetOrName['__zone_symbol__' + name] || targetOrName[name];\r\n}\r\n","import { getZoneUnPatchedApi } from '../get-zone-unpatched-api';\r\n\r\n/**\r\n * This file provides unpatched versions of APIs patched in the following file: https://github.com/angular/angular/blob/master/packages/zone.js/lib/browser/browser.ts\r\n */\r\n\r\n/**\r\n * This function is a zone un-patched implementation of Window#queueMicrotask() method.\r\n * It is which is exposed on the Window or Worker interface,\r\n * queues a microtask to be executed at a safe time prior to control returning to the browser's event loop.\r\n * The microtask is a short function which will run after the current task has completed its\r\n * work and when there is no other code waiting to be run before control of the execution context is returned to the browser's event loop.\r\n */\r\nexport function queueMicrotask() {\r\n  return getZoneUnPatchedApi('queueMicrotask');\r\n}\r\n\r\nexport const Promise: PromiseConstructor = getZoneUnPatchedApi('Promise');\r\n\r\n/**\r\n * requestAnimationFrame\r\n *\r\n * @description\r\n *\r\n * This function is a zone un-patched implementation of Window#requestAnimationFrame() method\r\n *\r\n * The requestAnimationFrame() method calls a function or evaluates an expression on the next animationFrame.\r\n * The requestAnimationFrame() method will not continue calling the function after executed once.\r\n * The ID value returned by requestAnimationFrame() is used as the parameter for the cancelAnimationFrame() method.\r\n *\r\n * requestAnimationFrame(cb, ms);\r\n *\r\n * @param cb - Required. The function that will be executed\r\n *\r\n */\r\nexport function requestAnimationFrame(cb: FrameRequestCallback): number {\r\n  return getZoneUnPatchedApi('requestAnimationFrame')(cb);\r\n}\r\n\r\n/**\r\n * cancelAnimationFrame\r\n *\r\n * @description\r\n *\r\n * This function is a zone un-patched implementation of Window cancelAnimationFrame() method\r\n *\r\n * The cancelAnimationFrame() method clears a timer set with the requestAnimationFrame() method.\r\n * The ID value returned by requestAnimationFrame() is used as the parameter for the cancelAnimationFrame() method.\r\n *\r\n * To be able to use the cancelAnimationFrame() method, you must use a variable when creating the requestAnimationFrame method:\r\n *\r\n * const id = requestAnimationFrame(\"javascript function\");\r\n * Then you will be able to stop the execution by calling the cancelAnimationFrame() method.\r\n *\r\n * cancelAnimationFrame(id);\r\n *\r\n * @param id {number} - Required. The ID value of the timer returned by the requestAnimationFrame() method\r\n *\r\n */\r\n\r\nexport function cancelAnimationFrame(id: number): void {\r\n  getZoneUnPatchedApi('cancelAnimationFrame')(id);\r\n}\r\n\r\n/**\r\n * setInterval\r\n *\r\n * @description\r\n *\r\n * This function is a zone un-patched implementation of Window setInterval() method\r\n *\r\n * The setInterval() method calls a function or evaluates an expression at specified intervals (in milliseconds).\r\n * The setInterval() method will continue calling the function until clearInterval() is called, or the window is closed.\r\n * The ID value returned by setInterval() is used as the parameter for the clearInterval() method.\r\n *\r\n * setInterval(cb, ms);\r\n *\r\n * @param cb - Required. The function that will be executed\r\n * @param ms - Required. The intervals (in milliseconds) on how often to execute the code. If the value is less than 10, the value 10 is used\r\n *\r\n */\r\nexport function setInterval(cb: TimerHandler, ms: number = 0): number {\r\n  return getZoneUnPatchedApi('setInterval')(cb, ms);\r\n}\r\n\r\n/**\r\n * clearInterval\r\n *\r\n * @description\r\n *\r\n * This function is a zone un-patched implementation of Window clearInterval() method\r\n *\r\n * The clearInterval() method clears a timer set with the setInterval() method.\r\n * The ID value returned by setInterval() is used as the parameter for the clearInterval() method.\r\n *\r\n * To be able to use the clearInterval() method, you must use a variable when creating the interval method:\r\n *\r\n * const id = setInterval(\"javascript function\", milliseconds);\r\n * Then you will be able to stop the execution by calling the clearInterval() method.\r\n *\r\n * clearInterval(id);\r\n *\r\n * @param id {number} - Required. The ID value of the timer returned by the setInterval() method\r\n *\r\n */\r\nexport function clearInterval(id: number): void {\r\n  return getZoneUnPatchedApi('clearInterval')(id);\r\n}\r\n\r\n/**\r\n * setTimeout\r\n *\r\n * @description\r\n *\r\n * This function is a zone un-patched implementation of Window setTimeout() method\r\n *\r\n * The setTimeout() method calls a function or evaluates an expression after a specified number of milliseconds.\r\n * The function is only executed once. If you need to repeat execution, use the setInterval() method.\r\n * Use the clearTimeout() method to prevent the function from running.\r\n *\r\n * setTimeout(cb, ms);\r\n *\r\n * @param cb - Required. The function that will be executed\r\n * @param ms - Optional. The number of milliseconds to wait before executing the code. If omitted, the value 0 is used\r\n *\r\n */\r\nexport function setTimeout(cb: TimerHandler, ms: number = 0): number {\r\n  return getZoneUnPatchedApi('setTimeout')(cb, ms);\r\n}\r\n\r\n/**\r\n * clearTimeout\r\n *\r\n * @description\r\n *\r\n * This function is a zone un-patched implementation of Window#clearTimeout() method\r\n *\r\n * The clearTimeout() method clears a timer set with the setTimeout() method.\r\n * The ID value returned by setTimeout() is used as the parameter for the clearTimeout() method.\r\n *\r\n * const id = setTimeout(\"javascript function\", milliseconds);\r\n * Then, if the function has not already been executed, you will be able to stop the execution by calling the clearTimeout() method.\r\n *\r\n * clearTimeout(id);\r\n *\r\n * @param id {number} -\tRequired. The ID value of the timer returned by the setTimeout() method\r\n *\r\n */\r\nexport function clearTimeout(id: number): void {\r\n  getZoneUnPatchedApi('clearTimeout')(id);\r\n}\r\n\r\n/**\r\n * This function is a zone un-patched implementation of Element#addEventListener() method.\r\n * @param target\r\n */\r\nexport function unpatchAddEventListener<T extends EventTarget>(target: T): T {\r\n  target.addEventListener = getZoneUnPatchedApi(\r\n    target,\r\n    'addEventListener'\r\n  ).bind(target);\r\n\r\n  return target;\r\n}\r\n","// tslint:disable\r\nimport { Subscription } from 'rxjs';\r\nimport { Scheduler } from './Scheduler';\r\nimport { SchedulerAction } from './types';\r\n\r\n/**\r\n * A unit of work to be executed in a `scheduler`. An action is typically\r\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\r\n * themselves about creating and manipulating an Action.\r\n *\r\n * ```ts\r\n * class Action<T> extends Subscription {\r\n *   new (scheduler: Scheduler, work: (state?: T) => void);\r\n *   schedule(state?: T, delay: number = 0): Subscription;\r\n * }\r\n * ```\r\n *\r\n * @class Action<T>\r\n */\r\nexport class Action<T> extends Subscription {\r\n  constructor(\r\n    scheduler: Scheduler,\r\n    work: (this: SchedulerAction<T>, state?: T) => void\r\n  ) {\r\n    super();\r\n  }\r\n  /**\r\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\r\n   * some context object, `state`. May happen at some point in the future,\r\n   * according to the `delay` parameter, if specified.\r\n   * @param {T} [state] Some contextual data that the `work` function uses when\r\n   * called by the Scheduler.\r\n   * @param {number} [delay] Time to wait before executing the work, where the\r\n   * time unit is implicit and defined by the Scheduler.\r\n   * @return {void}\r\n   */\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    return this;\r\n  }\r\n}\r\n","// tslint:disable\r\nimport { Subscription } from 'rxjs';\r\nimport { Action } from '../Action';\r\nimport { SchedulerAction } from '../types';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\nimport { setInterval, clearInterval } from '../../../browser/browser';\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nexport class AsyncAction<T> extends Action<T> {\r\n  public id: any;\r\n  public state?: T;\r\n  // @ts-ignore: Property has no initializer and is not definitely assigned\r\n  public delay: number;\r\n  protected pending = false;\r\n\r\n  constructor(\r\n    protected scheduler: AsyncScheduler,\r\n    protected work: (this: SchedulerAction<T>, state?: T) => void\r\n  ) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (this.closed) {\r\n      return this;\r\n    }\r\n\r\n    // Always replace the current state with the new state.\r\n    this.state = state;\r\n\r\n    const id = this.id;\r\n    const scheduler = this.scheduler;\r\n\r\n    //\r\n    // Important implementation note:\r\n    //\r\n    // Actions only execute once by default, unless rescheduled from within the\r\n    // scheduled callback. This allows us to implement single and repeat\r\n    // actions via the same code path, without adding API surface area, as well\r\n    // as mimic traditional recursion but across asynchronous boundaries.\r\n    //\r\n    // However, JS runtimes and timers distinguish between intervals achieved by\r\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\r\n    // serial `setTimeout` calls can be individually delayed, which delays\r\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\r\n    // guarantee the interval callback will be invoked more precisely to the\r\n    // interval period, regardless of load.\r\n    //\r\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\r\n    // If the action reschedules itself with the same delay, the interval is not\r\n    // canceled. If the action doesn't reschedule, or reschedules with a\r\n    // different delay, the interval will be canceled after scheduled callback\r\n    // execution.\r\n    //\r\n    if (id != null) {\r\n      this.id = this.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n\r\n    // Set the pending flag indicating that this action has been scheduled, or\r\n    // has recursively rescheduled itself.\r\n    this.pending = true;\r\n\r\n    this.delay = delay;\r\n    // If this action has already an async Id, don't request a new one.\r\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\r\n\r\n    return this;\r\n  }\r\n\r\n  protected requestAsyncId(\r\n    scheduler: AsyncScheduler,\r\n    id?: any,\r\n    delay: number = 0\r\n  ): any {\r\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\r\n  }\r\n\r\n  protected recycleAsyncId(\r\n    scheduler: AsyncScheduler,\r\n    id: any,\r\n    delay: number | null = 0\r\n  ): any {\r\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\r\n    if (delay != null && this.delay === delay && this.pending === false) {\r\n      return id;\r\n    }\r\n    // Otherwise, if the action's delay time is different from the current delay,\r\n    // or the action has been rescheduled before it's executed, clear the interval id\r\n    clearInterval(id);\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Immediately executes this action and the `work` it contains.\r\n   * @return {any}\r\n   */\r\n  public execute(state: T, delay: number): any {\r\n    if (this.closed) {\r\n      return new Error('executing a cancelled action');\r\n    }\r\n\r\n    this.pending = false;\r\n    const error = this._execute(state, delay);\r\n    if (error) {\r\n      return error;\r\n    } else if (this.pending === false && this.id != null) {\r\n      // Dequeue if the action didn't reschedule itself. Don't call\r\n      // unsubscribe(), because the action could reschedule later.\r\n      // For example:\r\n      // ```\r\n      // scheduler.schedule(function doWork(counter) {\r\n      //   /* ... I'm a busy worker bee ... */\r\n      //   var originalAction = this;\r\n      //   /* wait 100ms before rescheduling the action */\r\n      //   setTimeout(function () {\r\n      //     originalAction.schedule(counter + 1);\r\n      //   }, 100);\r\n      // }, 1000);\r\n      // ```\r\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\r\n    }\r\n  }\r\n\r\n  protected _execute(state: T, delay: number): any {\r\n    let errored = false;\r\n    let errorValue: any;\r\n    try {\r\n      this.work(state);\r\n    } catch (e) {\r\n      errored = true;\r\n      errorValue = (!!e && e) || new Error(e);\r\n    }\r\n    if (errored) {\r\n      this.unsubscribe();\r\n      return errorValue;\r\n    }\r\n  }\r\n\r\n  unsubscribe() {\r\n    if (!this.closed) {\r\n      const { id, scheduler } = this;\r\n      const { actions } = scheduler;\r\n\r\n      this.work = this.state = this.scheduler = null!;\r\n      this.pending = false;\r\n\r\n      // arrRemove\r\n      if (actions) {\r\n        const index = actions.indexOf(this);\r\n        0 <= index && actions.splice(index, 1);\r\n      }\r\n      if (id != null) {\r\n        this.id = this.recycleAsyncId(scheduler, id, null);\r\n      }\r\n\r\n      this.delay = null!;\r\n      super.unsubscribe();\r\n    }\r\n  }\r\n}\r\n","import { SchedulerLike } from 'rxjs';\r\nimport { Action } from './Action';\r\n\r\n/**\r\n * Schedulers rely on provided actions and actions are using some asynchronous API\r\n * internally, e.g. `setInterval`, etc. We don't wanna copy-paste the code of all schedulers\r\n * here since it'll increase the bundle size. We can re-use constructors of RxJS schedulers\r\n * and provide our custom actions that use the unpatched API.\r\n */\r\nexport function createScheduler<T extends SchedulerLike>(\r\n  scheduler: T,\r\n  action: typeof Action\r\n): T {\r\n  // The `Reflect.construct` is a cross-browser feature, it's only not supported in IE11,\r\n  // but apps anyway require polyfills if they want to be run in IE11.\r\n  return Reflect.construct(scheduler.constructor, [action]);\r\n}\r\n","// tslint:disable file-name-casing\r\nimport * as rxjs from 'rxjs';\r\nimport { AsyncAction } from './AsyncAction';\r\nimport { createScheduler } from '../create-scheduler';\r\n\r\n/**\r\n *\r\n * NOTE: This is a zone un-patched version of rxjs asyncScheduler\r\n *\r\n * Async Scheduler\r\n *\r\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\r\n *\r\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\r\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\r\n * in intervals.\r\n *\r\n * If you just want to \"defer\" task, that is to perform it right after currently\r\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\r\n * better choice will be the {@link asapScheduler} scheduler.\r\n *\r\n * ## Examples\r\n * Use async scheduler to delay task\r\n * ```ts\r\n * import { asyncScheduler } from '@cu/perf-utils';\r\n *\r\n * const task = () => console.log('it works!');\r\n *\r\n * asyncScheduler.schedule(task, 2000);\r\n *\r\n * // After 2 seconds logs:\r\n * // \"it works!\"\r\n * ```\r\n *\r\n * Use async scheduler to repeat task in intervals\r\n * ```ts\r\n * import { asyncScheduler } from '@cu/perf-utils';\r\n *\r\n * function task(state) {\r\n *   console.log(state);\r\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\r\n *                                   // which we reschedule with new state and delay\r\n * }\r\n *\r\n * asyncScheduler.schedule(task, 3000, 0);\r\n *\r\n * // Logs:\r\n * // 0 after 3s\r\n * // 1 after 4s\r\n * // 2 after 5s\r\n * // 3 after 6s\r\n * ```\r\n */\r\nexport const asyncScheduler = createScheduler(rxjs.asyncScheduler, AsyncAction);\r\n","import { SchedulerLike } from 'rxjs';\r\n\r\nexport function isNumeric(val: any): val is number | string {\r\n  // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\r\n  // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\r\n  // subtraction forces infinities to NaN\r\n  // adding 1 corrects loss of precision from parseFloat (#15100)\r\n  return !Array.isArray(val) && val - parseFloat(val) + 1 >= 0;\r\n}\r\n\r\nexport function isScheduler(value: any): value is SchedulerLike {\r\n  return value && typeof (<any>value).schedule === 'function';\r\n}\r\n","import { Observable, SchedulerAction, SchedulerLike, Subscriber } from 'rxjs';\r\nimport { asyncScheduler } from '../scheduler/async/async';\r\nimport { isNumeric } from './utils';\r\n\r\n/**\r\n * Creates an Observable that emits sequential numbers every specified\r\n * interval of time, on a specified {@link SchedulerLike}.\r\n *\r\n * <span class=\"informal\">Emits incremental numbers periodically in time.\r\n * </span>\r\n *\r\n * ![](interval.png)\r\n *\r\n * `interval` returns an Observable that emits an infinite sequence of\r\n * ascending integers, with a constant interval of time of your choosing\r\n * between those emissions. The first emission is not sent immediately, but\r\n * only after the first period has passed. By default, this operator uses the\r\n * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any\r\n * {@link SchedulerLike} to it.\r\n *\r\n * ## Example\r\n * Emits ascending numbers, one every second (1000ms) up to the number 3\r\n * ```ts\r\n * import { interval } from 'rxjs';\r\n * import { take } from 'rxjs/operators';\r\n *\r\n * const numbers = interval(1000);\r\n *\r\n * const takeFourNumbers = numbers.pipe(take(4));\r\n *\r\n * takeFourNumbers.subscribe(x => console.log('Next: ', x));\r\n *\r\n * // Logs:\r\n * // Next: 0\r\n * // Next: 1\r\n * // Next: 2\r\n * // Next: 3\r\n * ```\r\n *\r\n * @see {@link timer}\r\n * @see {@link delay}\r\n *\r\n * @param {number} [period=0] The interval size in milliseconds (by default)\r\n * or the time unit determined by the scheduler's clock.\r\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\r\n * the emission of values, and providing a notion of \"time\".\r\n * @return {Observable} An Observable that emits a sequential number each time\r\n * interval.\r\n * @static true\r\n * @name interval\r\n * @owner Observable\r\n */\r\nexport function interval(\r\n  period = 0,\r\n  scheduler: SchedulerLike = asyncScheduler\r\n): Observable<number> {\r\n  if (!isNumeric(period) || period < 0) {\r\n    period = 0;\r\n  }\r\n\r\n  if (!scheduler || typeof scheduler.schedule !== 'function') {\r\n    scheduler = asyncScheduler;\r\n  }\r\n\r\n  return new Observable<number>((subscriber) => {\r\n    subscriber.add(\r\n      scheduler.schedule(dispatch, period, { subscriber, counter: 0, period })\r\n    );\r\n    return subscriber;\r\n  });\r\n}\r\n\r\nfunction dispatch(this: SchedulerAction<IntervalState>, state: IntervalState) {\r\n  const { subscriber, counter, period } = state;\r\n  subscriber.next(counter);\r\n  this.schedule({ subscriber, counter: counter + 1, period }, period);\r\n}\r\n\r\ninterface IntervalState {\r\n  subscriber: Subscriber<number>;\r\n  counter: number;\r\n  period: number;\r\n}\r\n","import { Observable, SchedulerAction, SchedulerLike, Subscriber } from 'rxjs';\r\nimport { asyncScheduler } from '../scheduler/async/async';\r\nimport { isNumeric, isScheduler } from './utils';\r\n\r\n/**\r\n * Creates an Observable that starts emitting after an `dueTime` and\r\n * emits ever increasing numbers after each `period` of time thereafter.\r\n *\r\n * <span class=\"informal\">Its like {@link index/interval}, but you can specify when\r\n * should the emissions start.</span>\r\n *\r\n * ![](timer.png)\r\n *\r\n * `timer` returns an Observable that emits an infinite sequence of ascending\r\n * integers, with a constant interval of time, `period` of your choosing\r\n * between those emissions. The first emission happens after the specified\r\n * `dueTime`. The initial delay may be a `Date`. By default, this\r\n * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you\r\n * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output\r\n * Observable emits only one value, `0`. Otherwise, it emits an infinite\r\n * sequence.\r\n *\r\n * ## Examples\r\n * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds\r\n * ```ts\r\n * import { timer } from 'rxjs';\r\n *\r\n * const numbers = timer(3000, 1000);\r\n * numbers.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * ### Emits one number after five seconds\r\n * ```ts\r\n * import { timer } from 'rxjs';\r\n *\r\n * const numbers = timer(5000);\r\n * numbers.subscribe(x => console.log(x));\r\n * ```\r\n * @see {@link index/interval}\r\n * @see {@link delay}\r\n *\r\n * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting\r\n * milliseconds to wait before emitting the first value of 0`.\r\n * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the\r\n * subsequent numbers.\r\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\r\n * the emission of values, and providing a notion of \"time\".\r\n * @return {Observable} An Observable that emits a `0` after the\r\n * `dueTime` and ever increasing numbers after each `period` of time\r\n * thereafter.\r\n * @static true\r\n * @name timer\r\n * @owner Observable\r\n */\r\nexport function timer(\r\n  dueTime: number | Date = 0,\r\n  periodOrScheduler?: number | SchedulerLike,\r\n  scheduler?: SchedulerLike\r\n): Observable<number> {\r\n  let period = -1;\r\n  if (isNumeric(periodOrScheduler)) {\r\n    period = (Number(periodOrScheduler) < 1 && 1) || Number(periodOrScheduler);\r\n  } else if (isScheduler(periodOrScheduler)) {\r\n    scheduler = periodOrScheduler as any;\r\n  }\r\n\r\n  if (!isScheduler(scheduler)) {\r\n    scheduler = asyncScheduler;\r\n  }\r\n\r\n  return new Observable((subscriber) => {\r\n    const due = isNumeric(dueTime)\r\n      ? (dueTime as number)\r\n      : +dueTime - scheduler.now();\r\n\r\n    return scheduler.schedule(dispatch, due, {\r\n      index: 0,\r\n      period,\r\n      subscriber,\r\n    });\r\n  });\r\n}\r\n\r\ninterface TimerState {\r\n  index: number;\r\n  period: number;\r\n  subscriber: Subscriber<number>;\r\n}\r\n\r\nfunction dispatch(this: SchedulerAction<TimerState>, state: TimerState) {\r\n  const { index, period, subscriber } = state;\r\n  subscriber.next(index);\r\n\r\n  if (subscriber.closed) {\r\n    return;\r\n  } else if (period === -1) {\r\n    return subscriber.complete();\r\n  }\r\n\r\n  state.index = index + 1;\r\n  this.schedule(state, period);\r\n}\r\n","// tslint:disable\r\nimport { Observable, Subscriber } from 'rxjs';\r\nimport { map } from 'rxjs/operators';\r\nimport { getZoneUnPatchedApi } from '../../get-zone-unpatched-api';\r\n\r\n// @ts-ignore\r\nconst isFunction = (fn) => typeof fn === 'function';\r\nconst isArray = Array.isArray;\r\nconst toString: Function = (() => Object.prototype.toString)();\r\n\r\nexport interface NodeStyleEventEmitter {\r\n  addListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\r\n  removeListener: (\r\n    eventName: string | symbol,\r\n    handler: NodeEventHandler\r\n  ) => this;\r\n}\r\n\r\nexport type NodeEventHandler = (...args: any[]) => void;\r\n\r\n// For APIs that implement `addListener` and `removeListener` methods that may\r\n// not use the same arguments or return EventEmitter values\r\n// such as React Native\r\nexport interface NodeCompatibleEventEmitter {\r\n  addListener: (eventName: string, handler: NodeEventHandler) => void | {};\r\n  removeListener: (eventName: string, handler: NodeEventHandler) => void | {};\r\n}\r\n\r\nexport interface JQueryStyleEventEmitter {\r\n  on: (eventName: string, handler: Function) => void;\r\n  off: (eventName: string, handler: Function) => void;\r\n}\r\n\r\nexport interface HasEventTargetAddRemove<E> {\r\n  addEventListener(\r\n    type: string,\r\n    listener: ((evt: E) => void) | null,\r\n    options?: boolean | AddEventListenerOptions\r\n  ): void;\r\n  removeEventListener(\r\n    type: string,\r\n    listener?: ((evt: E) => void) | null,\r\n    options?: EventListenerOptions | boolean\r\n  ): void;\r\n}\r\n\r\nexport type EventTargetLike<T> =\r\n  | HasEventTargetAddRemove<T>\r\n  | NodeStyleEventEmitter\r\n  | NodeCompatibleEventEmitter\r\n  | JQueryStyleEventEmitter;\r\n\r\nexport type FromEventTarget<T> =\r\n  | EventTargetLike<T>\r\n  | ArrayLike<EventTargetLike<T>>;\r\n\r\nexport interface EventListenerOptions {\r\n  capture?: boolean;\r\n  passive?: boolean;\r\n  once?: boolean;\r\n}\r\n\r\nexport interface AddEventListenerOptions extends EventListenerOptions {\r\n  once?: boolean;\r\n  passive?: boolean;\r\n}\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function fromEvent<T>(\r\n  target: FromEventTarget<T>,\r\n  eventName: string\r\n): Observable<T>;\r\n/** @deprecated resultSelector no longer supported, pipe to map instead */\r\n// tslint:disable-next-line:unified-signatures\r\nexport function fromEvent<T>(\r\n  target: FromEventTarget<T>,\r\n  eventName: string,\r\n  resultSelector: (...args: any[]) => T\r\n): Observable<T>;\r\n// tslint:disable-next-line:unified-signatures\r\nexport function fromEvent<T>(\r\n  target: FromEventTarget<T>,\r\n  eventName: string,\r\n  options: EventListenerOptions\r\n): Observable<T>;\r\n/** @deprecated resultSelector no longer supported, pipe to map instead */\r\n// tslint:disable-next-line:unified-signatures\r\nexport function fromEvent<T>(\r\n  target: FromEventTarget<T>,\r\n  eventName: string,\r\n  options: EventListenerOptions,\r\n  resultSelector: (...args: any[]) => T\r\n): Observable<T>;\r\n/* tslint:enable:max-line-length */\r\n\r\nexport function fromEvent<T>(\r\n  target: FromEventTarget<T>,\r\n  eventName: string,\r\n  options?: EventListenerOptions | ((...args: any[]) => T),\r\n  resultSelector?: (...args: any[]) => T\r\n): Observable<T> {\r\n  if (isFunction(options)) {\r\n    // DEPRECATED PATH\r\n    // @ts-ignore\r\n    resultSelector = options;\r\n    options = undefined;\r\n  }\r\n  if (resultSelector) {\r\n    // DEPRECATED PATH\r\n    return fromEvent<T>(\r\n      target,\r\n      eventName,\r\n      <EventListenerOptions | undefined>options\r\n    ).pipe(\r\n      map((args) =>\r\n        isArray(args) ? resultSelector(...args) : resultSelector(args)\r\n      )\r\n    );\r\n  }\r\n\r\n  return new Observable<T>((subscriber) => {\r\n    function handler(e: T) {\r\n      if (arguments.length > 1) {\r\n        subscriber.next(Array.prototype.slice.call(arguments));\r\n      } else {\r\n        subscriber.next(e);\r\n      }\r\n    }\r\n    setupSubscription(\r\n      target,\r\n      eventName,\r\n      handler,\r\n      subscriber,\r\n      options as EventListenerOptions\r\n    );\r\n  });\r\n}\r\n\r\nfunction setupSubscription<T>(\r\n  sourceObj: FromEventTarget<T>,\r\n  eventName: string,\r\n  handler: (...args: any[]) => void,\r\n  subscriber: Subscriber<T>,\r\n  options?: EventListenerOptions\r\n) {\r\n  let unsubscribe: () => void;\r\n  if (isEventTarget(sourceObj)) {\r\n    const source = sourceObj;\r\n    getZoneUnPatchedApi(sourceObj, 'addEventListener').call(\r\n      sourceObj,\r\n      eventName,\r\n      handler,\r\n      options\r\n    );\r\n    unsubscribe = () =>\r\n      getZoneUnPatchedApi(source, 'removeEventListener').call(\r\n        source,\r\n        eventName,\r\n        handler,\r\n        options\r\n      );\r\n  } else if (isJQueryStyleEventEmitter(sourceObj)) {\r\n    const source = sourceObj;\r\n    sourceObj.on(eventName, handler);\r\n    unsubscribe = () => source.off(eventName, handler);\r\n  } else if (isNodeStyleEventEmitter(sourceObj)) {\r\n    const source = sourceObj;\r\n    sourceObj.addListener(eventName, handler as NodeEventHandler);\r\n    unsubscribe = () =>\r\n      source.removeListener(eventName, handler as NodeEventHandler);\r\n  } else if (sourceObj && (sourceObj as any).length) {\r\n    for (let i = 0, len = (sourceObj as any).length; i < len; i++) {\r\n      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\r\n    }\r\n  } else {\r\n    throw new TypeError('Invalid event target');\r\n  }\r\n\r\n  subscriber.add(unsubscribe);\r\n}\r\n\r\nfunction isNodeStyleEventEmitter(\r\n  sourceObj: any\r\n): sourceObj is NodeStyleEventEmitter {\r\n  return (\r\n    sourceObj &&\r\n    typeof sourceObj.addListener === 'function' &&\r\n    typeof sourceObj.removeListener === 'function'\r\n  );\r\n}\r\n\r\nfunction isJQueryStyleEventEmitter(\r\n  sourceObj: any\r\n): sourceObj is JQueryStyleEventEmitter {\r\n  return (\r\n    sourceObj &&\r\n    typeof sourceObj.on === 'function' &&\r\n    typeof sourceObj.off === 'function'\r\n  );\r\n}\r\n\r\nfunction isEventTarget(\r\n  sourceObj: any\r\n): sourceObj is HasEventTargetAddRemove<any> {\r\n  return (\r\n    sourceObj &&\r\n    typeof sourceObj.addEventListener === 'function' &&\r\n    typeof sourceObj.removeEventListener === 'function'\r\n  );\r\n}\r\n","// tslint:disable\r\nimport { AsyncAction } from '../async/AsyncAction';\r\nimport { AsapScheduler } from './AsapScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { Promise } from '../../../browser/browser';\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nexport class AsapAction<T> extends AsyncAction<T> {\r\n  constructor(\r\n    protected scheduler: AsapScheduler,\r\n    protected work: (this: SchedulerAction<T>, state?: T) => void\r\n  ) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  protected requestAsyncId(\r\n    scheduler: AsapScheduler,\r\n    id?: any,\r\n    delay: number = 0\r\n  ): any {\r\n    // If delay is greater than 0, request as an async action.\r\n    if (delay !== null && delay > 0) {\r\n      return super.requestAsyncId(scheduler, id, delay);\r\n    }\r\n    // Push the action to the end of the scheduler queue.\r\n    scheduler.actions.push(this);\r\n    // If a microtask has already been scheduled, don't schedule another\r\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\r\n    // the current scheduled microtask id.\r\n    return (\r\n      scheduler.scheduled ||\r\n      (scheduler.scheduled = Immediate.setImmediate(\r\n        scheduler.flush.bind(scheduler, undefined)\r\n      ))\r\n    );\r\n  }\r\n  protected recycleAsyncId(\r\n    scheduler: AsapScheduler,\r\n    id?: any,\r\n    delay: number = 0\r\n  ): any {\r\n    // If delay exists and is greater than 0, or if the delay is null (the\r\n    // action wasn't rescheduled) but was originally scheduled as an async\r\n    // action, then recycle as an async action.\r\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\r\n      return super.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n    // If the scheduler queue is empty, cancel the requested microtask and\r\n    // set the scheduled flag to undefined so the next AsapAction will schedule\r\n    // its own.\r\n    if (scheduler.actions.length === 0) {\r\n      Immediate.clearImmediate(id);\r\n      scheduler.scheduled = undefined;\r\n    }\r\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\r\n    return undefined;\r\n  }\r\n}\r\n\r\nlet nextHandle = 1;\r\n// The promise needs to be created lazily otherwise it won't be patched by Zones\r\nlet resolved: Promise<any>;\r\nconst activeHandles: { [key: number]: any } = {};\r\n\r\n/**\r\n * Finds the handle in the list of active handles, and removes it.\r\n * Returns `true` if found, `false` otherwise. Used both to clear\r\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\r\n */\r\nfunction findAndClearHandle(handle: number): boolean {\r\n  if (handle in activeHandles) {\r\n    delete activeHandles[handle];\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Helper functions to schedule and unschedule microtasks.\r\n */\r\nconst Immediate = {\r\n  setImmediate(cb: () => void): number {\r\n    const handle = nextHandle++;\r\n    activeHandles[handle] = true;\r\n    if (!resolved) {\r\n      resolved = Promise.resolve();\r\n    }\r\n    resolved.then(() => findAndClearHandle(handle) && cb());\r\n    return handle;\r\n  },\r\n\r\n  clearImmediate(handle: number): void {\r\n    findAndClearHandle(handle);\r\n  },\r\n};\r\n\r\n/**\r\n * Used for internal testing purposes only. Do not export from library.\r\n */\r\nexport const TestTools = {\r\n  pending() {\r\n    return Object.keys(activeHandles).length;\r\n  },\r\n};\r\n","// tslint:disable file-name-casing\r\nimport * as rxjs from 'rxjs';\r\nimport { AsapAction } from './AsapAction';\r\nimport { createScheduler } from '../create-scheduler';\r\n\r\n/**\r\n *\r\n * NOTE: This is a zone un-patched version of rxjs asapScheduler\r\n *\r\n * Asap Scheduler\r\n *\r\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\r\n *\r\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\r\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\r\n * code to end and then it will try to execute given task as fast as possible.\r\n *\r\n * `asap` scheduler will do its best to minimize time between end of currently executing code\r\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\r\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\r\n * some (although minimal) unwanted delay.\r\n *\r\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\r\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\r\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\r\n * as soon as possible, `asap` scheduler is your best bet.\r\n *\r\n * ## Example\r\n * Compare async and asap scheduler<\r\n * ```ts\r\n * import { asapScheduler, asyncScheduler } from '@cu/perf-utils';\r\n *\r\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\r\n * asapScheduler.schedule(() => console.log('asap'));\r\n *\r\n * // Logs:\r\n * // \"asap\"\r\n * // \"async\"\r\n * // ... but 'asap' goes first!\r\n * ```\r\n */\r\nexport const asapScheduler = createScheduler(rxjs.asapScheduler, AsapAction);\r\n","// tslint:disable\r\nimport { AsyncAction } from '../async/AsyncAction';\r\nimport { Subscription } from 'rxjs';\r\nimport { SchedulerAction } from '../types';\r\nimport { QueueScheduler } from './QueueScheduler';\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nexport class QueueAction<T> extends AsyncAction<T> {\r\n  constructor(\r\n    protected scheduler: QueueScheduler,\r\n    protected work: (this: SchedulerAction<T>, state?: T) => void\r\n  ) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (delay > 0) {\r\n      return super.schedule(state, delay);\r\n    }\r\n    this.delay = delay;\r\n    this.state = state;\r\n    // @ts-ignore\r\n    this.scheduler.flush(this);\r\n    return this;\r\n  }\r\n\r\n  public execute(state: T, delay: number): any {\r\n    return delay > 0 || this.closed\r\n      ? super.execute(state, delay)\r\n      : this._execute(state, delay);\r\n  }\r\n\r\n  protected requestAsyncId(\r\n    scheduler: QueueScheduler,\r\n    id?: any,\r\n    delay: number = 0\r\n  ): any {\r\n    // If delay exists and is greater than 0, or if the delay is null (the\r\n    // action wasn't rescheduled) but was originally scheduled as an async\r\n    // action, then recycle as an async action.\r\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\r\n      return super.requestAsyncId(scheduler, id, delay);\r\n    }\r\n    // Otherwise flush the scheduler starting with this action.\r\n    // @ts-ignore\r\n    return scheduler.flush(this);\r\n  }\r\n}\r\n","// tslint:disable file-name-casing\r\nimport * as rxjs from 'rxjs';\r\nimport { QueueAction } from './QueueAction';\r\nimport { createScheduler } from '../create-scheduler';\r\n\r\n/**\r\n *\r\n * NOTE: This is a zone un-patched version of rxjs queueScheduler\r\n *\r\n * Queue Scheduler\r\n *\r\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\r\n *\r\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\r\n *\r\n * When used without delay, it schedules given task synchronously - executes it right when\r\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\r\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\r\n * that task will be put on a queue and wait for current one to finish.\r\n *\r\n * This means that when you execute task with `queue` scheduler, you are sure it will end\r\n * before any other task scheduled with that scheduler will start.\r\n *\r\n * ## Examples\r\n * Schedule recursively first, then do something\r\n * ```ts\r\n * import { queueScheduler } from '@cu/perf-utils';\r\n *\r\n * queueScheduler.schedule(() => {\r\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\r\n *\r\n *   console.log('first');\r\n * });\r\n *\r\n * // Logs:\r\n * // \"first\"\r\n * // \"second\"\r\n * ```\r\n *\r\n * Reschedule itself recursively\r\n * ```ts\r\n * import { queueScheduler } from '@cu/perf-utils';\r\n *\r\n * queueScheduler.schedule(function(state) {\r\n *   if (state !== 0) {\r\n *     console.log('before', state);\r\n *     this.schedule(state - 1); // `this` references currently executing Action,\r\n *                               // which we reschedule with new state\r\n *     console.log('after', state);\r\n *   }\r\n * }, 0, 3);\r\n *\r\n * // In scheduler that runs recursively, you would expect:\r\n * // \"before\", 3\r\n * // \"before\", 2\r\n * // \"before\", 1\r\n * // \"after\", 1\r\n * // \"after\", 2\r\n * // \"after\", 3\r\n *\r\n * // But with queue it logs:\r\n * // \"before\", 3\r\n * // \"after\", 3\r\n * // \"before\", 2\r\n * // \"after\", 2\r\n * // \"before\", 1\r\n * // \"after\", 1\r\n * ```\r\n */\r\nexport const queueScheduler = createScheduler(rxjs.queueScheduler, QueueAction);\r\n","// tslint:disable\r\nimport { AsyncAction } from '../async/AsyncAction';\r\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport {\r\n  requestAnimationFrame,\r\n  cancelAnimationFrame,\r\n} from '../../../browser/browser';\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\r\n  constructor(\r\n    protected scheduler: AnimationFrameScheduler,\r\n    protected work: (this: SchedulerAction<T>, state?: T) => void\r\n  ) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  protected requestAsyncId(\r\n    scheduler: AnimationFrameScheduler,\r\n    id?: any,\r\n    delay: number = 0\r\n  ): any {\r\n    // If delay is greater than 0, request as an async action.\r\n    if (delay !== null && delay > 0) {\r\n      return super.requestAsyncId(scheduler, id, delay);\r\n    }\r\n    // Push the action to the end of the scheduler queue.\r\n    // @ts-ignore\r\n    scheduler.actions.push(this);\r\n    // If an animation frame has already been requested, don't request another\r\n    // one. If an animation frame hasn't been requested yet, request one. Return\r\n    // the current animation frame request id.\r\n    return (\r\n      scheduler.scheduled ||\r\n      (scheduler.scheduled = requestAnimationFrame(() =>\r\n        scheduler.flush(undefined)\r\n      ))\r\n    );\r\n  }\r\n  protected recycleAsyncId(\r\n    scheduler: AnimationFrameScheduler,\r\n    id?: any,\r\n    delay: number = 0\r\n  ): any {\r\n    // If delay exists and is greater than 0, or if the delay is null (the\r\n    // action wasn't rescheduled) but was originally scheduled as an async\r\n    // action, then recycle as an async action.\r\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\r\n      return super.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n    // If the scheduler queue is empty, cancel the requested animation frame and\r\n    // set the scheduled flag to undefined so the next AnimationFrameAction will\r\n    // request its own.\r\n    if (scheduler.actions.length === 0) {\r\n      cancelAnimationFrame(id);\r\n      scheduler.scheduled = undefined;\r\n    }\r\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\r\n    return undefined;\r\n  }\r\n}\r\n","// tslint:disable file-name-casing\r\nimport * as rxjs from 'rxjs';\r\nimport { AnimationFrameAction } from './AnimationFrameAction';\r\nimport { createScheduler } from '../create-scheduler';\r\n\r\n/**\r\n *\r\n * NOTE: This is a zone un-patched version of rxjs animationFrameScheduler\r\n *\r\n * Animation Frame Scheduler\r\n *\r\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\r\n *\r\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\r\n * behaviour.\r\n *\r\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\r\n * It makes sure scheduled task will happen just before next browser content repaint,\r\n * thus performing animations as efficiently as possible.\r\n *\r\n * ## Example\r\n * Schedule div height animation\r\n * ```ts\r\n * // html: <div style=\"background: #0ff;\"></div>\r\n * import { animationFrameScheduler } from '@cu/perf-utils';\r\n *\r\n * const div = document.querySelector('div');\r\n *\r\n * animationFrameScheduler.schedule(function(height) {\r\n *   div.style.height = height + \"px\";\r\n *\r\n *   this.schedule(height + 1);  // `this` references currently executing Action,\r\n *                               // which we reschedule with new state\r\n * }, 0, 0);\r\n *\r\n * // You will see a div element growing in height\r\n * ```\r\n */\r\nexport const animationFrameScheduler = createScheduler(\r\n  rxjs.animationFrameScheduler,\r\n  AnimationFrameAction\r\n);\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n\nexport {Action as ɵc} from './rxjs/scheduler/Action';\nexport {Scheduler as ɵd} from './rxjs/scheduler/Scheduler';\nexport {AnimationFrameAction as ɵj} from './rxjs/scheduler/animation-frame/AnimationFrameAction';\nexport {AnimationFrameScheduler as ɵk} from './rxjs/scheduler/animation-frame/AnimationFrameScheduler';\nexport {AsapAction as ɵf} from './rxjs/scheduler/asap/AsapAction';\nexport {AsapScheduler as ɵg} from './rxjs/scheduler/asap/AsapScheduler';\nexport {AsyncAction as ɵb} from './rxjs/scheduler/async/AsyncAction';\nexport {AsyncScheduler as ɵe} from './rxjs/scheduler/async/AsyncScheduler';\nexport {createScheduler as ɵa} from './rxjs/scheduler/create-scheduler';\nexport {QueueAction as ɵh} from './rxjs/scheduler/queue/QueueAction';\nexport {QueueScheduler as ɵi} from './rxjs/scheduler/queue/QueueScheduler';"],"names":["Promise","dispatch"],"mappings":"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"}