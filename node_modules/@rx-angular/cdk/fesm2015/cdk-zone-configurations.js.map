{"version":3,"file":"cdk-zone-configurations.js","sources":["../../../../libs/cdk/zone-configurations/src/lib/event-names.ts","../../../../libs/cdk/zone-configurations/src/lib/model/configurations.types.ts","../../../../libs/cdk/zone-configurations/src/lib/convenience-methods.ts","../../../../libs/cdk/zone-configurations/src/lib/zone-config.ts","../../../../libs/cdk/zone-configurations/src/cdk-zone-configurations.ts"],"sourcesContent":["// Standard Events\r\n\r\n// Focus Events\r\nexport const focusEvents = ['blur', 'focus', 'focusin', 'focusout'] as const;\r\n\r\n/**\r\n * Mouse Events\r\n * (MouseEvent)[https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent]\r\n */\r\nexport const mouseEvents = [\r\n  'mousedown',\r\n  'dblclick',\r\n  'mouseenter',\r\n  'mouseleave',\r\n  'mousemove',\r\n  'mouseout',\r\n  'mouseover',\r\n  'mouseup',\r\n  'click',\r\n] as const;\r\n\r\n/**\r\n * Wheel Events\r\n * (WheelEvent)[https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent]\r\n */\r\nexport const wheelEvents = [\r\n  // (WheelEvent)[https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent]\r\n  'wheel',\r\n  'mousewheel',\r\n] as const;\r\n\r\n// Input Events\r\nexport const inputEvents = [\r\n  'input',\r\n  'invalid',\r\n  'change',\r\n  'reset',\r\n  'select',\r\n  'submit',\r\n] as const;\r\n\r\n/**\r\n * @deprecated\r\n */\r\nexport const formControlsEvents = inputEvents;\r\n\r\n// [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent)\r\nexport const keyboardEvents = ['keydown', 'keypress', 'keyup'] as const;\r\n\r\n// [VR]()\r\nexport const vrEvents = [\r\n  'vrdisplayactivate',\r\n  'vrdisplayblur',\r\n  'vrdisplayconnect',\r\n  'vrdisplaydeactivate',\r\n  'vrdisplaydisconnect',\r\n  'vrdisplayfocus',\r\n  'vrdisplaypointerrestricted',\r\n  'vrdisplaypointerunrestricted',\r\n  'vrdisplaypresentchange',\r\n] as const;\r\n\r\n// [MSGesture]()\r\nexport const mSGestureEvents = [\r\n  'MSGestureChange',\r\n  'MSGestureDoubleTap',\r\n  'MSGestureEnd',\r\n  'MSGestureHold',\r\n  'MSGestureStart',\r\n  'MSGestureTap',\r\n  'MSInertiaStart',\r\n  'MSPointerCancel',\r\n  'MSPointerDown',\r\n  'MSPointerEnter',\r\n  'MSPointerLeave',\r\n  'MSPointerMove',\r\n  'MSPointerOut',\r\n  'MSPointerOver',\r\n  'MSPointerUp',\r\n] as const;\r\n\r\n// [xPrint](https://developer.mozilla.org/en-US/docs/Web/API/Window/afterprint_event)\r\nexport const printEvents = ['afterprint', 'beforeprint'] as const;\r\n// [network]()\r\nexport const networkEvents = ['offline', 'online'] as const;\r\n\r\n// [network]()\r\nexport const audioEvents = [\r\n  'canplay',\r\n  'canplaythrough',\r\n  'pause',\r\n  'play',\r\n  'playing',\r\n  'volumechange',\r\n] as const;\r\n\r\n// Composition Events\r\nexport const compositionEvents = [\r\n  'compositionstart',\r\n  'compositionupdate',\r\n  'compositionend',\r\n] as const;\r\n\r\n/**\r\n * Touch Events\r\n * [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent)\r\n * [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent)\r\n */\r\nexport const touchEvents = [\r\n  // [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent)\r\n  'pointerover',\r\n  'pointerenter',\r\n  'pointerdown',\r\n  'pointermove',\r\n  // 'pointerrawupdate',\r\n  'pointerup',\r\n  'pointercancel',\r\n  'pointerout',\r\n  'pointerleave',\r\n  'gotpointercapture',\r\n  'lostpointercapture',\r\n  'pointerup',\r\n\r\n  // [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent)\r\n  'touchstart',\r\n  'touchend',\r\n  'touchmove',\r\n  'touchcancel',\r\n\r\n  // [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent)\r\n  'drag',\r\n  'dragend',\r\n  'dragexit',\r\n  'dragenter',\r\n  'dragleave',\r\n  'dragover',\r\n  'dragstart',\r\n  'drop',\r\n] as const;\r\n\r\nexport const globalEvents = [\r\n  'contextmenu',\r\n  'resize',\r\n  'scroll',\r\n\r\n  'abort',\r\n  'load',\r\n  'loadeddata',\r\n  'loadedmetadata',\r\n  'loadstart',\r\n  'unload',\r\n\r\n  'error',\r\n] as const;\r\n\r\nexport const websocketEvents = ['close', 'error', 'message', 'open'] as const;\r\n\r\n/**\r\n * Basic XHR Events\r\n * [Load](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/load_event)\r\n * [Error](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/error_event)\r\n * There are more events you may want to unpatch https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\r\n */\r\n// XHREvent (group is here to make it easier to target XHR in angular applications. It contains redundant events e.g. 'error')\r\nexport const xhrEvents = ['load', 'error'] as const;\r\n\r\n// @TODO\r\nexport const windowEvents = [\r\n  'compassneedscalibration',\r\n  'durationchange',\r\n  'emptied',\r\n  'ended',\r\n\r\n  'orientationchange',\r\n\r\n  'ratechange',\r\n\r\n  'seeked',\r\n  'seeking',\r\n  'stalled',\r\n\r\n  'suspend',\r\n  'timeupdate',\r\n  'waiting',\r\n] as const;\r\n\r\n/**\r\n * All Events combined\r\n */\r\nexport const allEvents = Array.from(\r\n  new Set([\r\n    ...focusEvents,\r\n    ...mouseEvents,\r\n    ...wheelEvents,\r\n    ...inputEvents,\r\n    ...keyboardEvents,\r\n    ...inputEvents,\r\n    ...vrEvents,\r\n    ...mSGestureEvents,\r\n    ...printEvents,\r\n    ...networkEvents,\r\n    ...audioEvents,\r\n    ...compositionEvents,\r\n    ...touchEvents,\r\n    ...globalEvents,\r\n    ...websocketEvents,\r\n    ...xhrEvents,\r\n    ...windowEvents,\r\n  ])\r\n);\r\n","// prefix: __Zone_disable_\r\nexport interface RxZoneGlobalDisableConfigurations {\r\n  /**\r\n   * Disable the monkey patch of the `Node.js` `EventEmitter` API.\r\n   *\r\n   * By default, `zone.js` monkey patches the `Node.js` `EventEmitter` APIs to make asynchronous\r\n   * callbacks of those APIs in the same zone when scheduled.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const EventEmitter = require('events');\r\n   * class MyEmitter extends EventEmitter {}\r\n   * const myEmitter = new MyEmitter();\r\n   *\r\n   * const zone = Zone.current.fork({name: 'myZone'});\r\n   * zone.run(() => {\r\n   *   myEmitter.on('event', () => {\r\n   *     console.log('an event occurs in the zone', Zone.current.name);\r\n   *     // the callback runs in the zone when it is scheduled,\r\n   *     // so the output is 'an event occurs in the zone myZone'.\r\n   *   });\r\n   * });\r\n   * myEmitter.emit('event');\r\n   * ```\r\n   *\r\n   * If you set `__Zone_disable_EventEmitter = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch the `EventEmitter` APIs and the above code\r\n   * outputs 'an event occurred <root>'.\r\n   */\r\n  EventEmitter?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the `Node.js` `fs` API.\r\n   *\r\n   * By default, `zone.js` monkey patches `Node.js` `fs` APIs to make asynchronous callbacks of\r\n   * those APIs in the same zone when scheduled.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const fs = require('fs');\r\n   *\r\n   * const zone = Zone.current.fork({name: 'myZone'});\r\n   * zone.run(() => {\r\n   *   fs.stat('/tmp/world', (err, stats) => {\r\n   *     console.log('fs.stats() callback is invoked in the zone', Zone.current.name);\r\n   *     // since the callback of the `fs.stat()` runs in the same zone\r\n   *     // when it is called, so the output is 'fs.stats() callback is invoked in the zone myZone'.\r\n   *   });\r\n   * });\r\n   * ```\r\n   *\r\n   * If you set `__Zone_disable_fs = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch the `fs` API and the above code\r\n   * outputs 'get stats occurred <root>'.\r\n   */\r\n  fs?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the `Node.js` `timer` API.\r\n   *\r\n   * By default, `zone.js` monkey patches the `Node.js` `timer` APIs to make asynchronous\r\n   * callbacks of those APIs in the same zone when scheduled.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const zone = Zone.current.fork({name: 'myZone'});\r\n   * zone.run(() => {\r\n   *   setTimeout(() => {\r\n   *     console.log('setTimeout() callback is invoked in the zone', Zone.current.name);\r\n   *     // since the callback of `setTimeout()` runs in the same zone\r\n   *     // when it is scheduled, so the output is 'setTimeout() callback is invoked in the zone\r\n   *     // myZone'.\r\n   *   });\r\n   * });\r\n   * ```\r\n   *\r\n   * If you set `__Zone_disable_timers = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch the `timer` APIs and the above code\r\n   * outputs 'timeout <root>'.\r\n   */\r\n  node_timers?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the `Node.js` `process.nextTick()` API.\r\n   *\r\n   * By default, `zone.js` monkey patches the `Node.js` `process.nextTick()` API to make the\r\n   * callback in the same zone when calling `process.nextTick()`.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const zone = Zone.current.fork({name: 'myZone'});\r\n   * zone.run(() => {\r\n   *   process.nextTick(() => {\r\n   *     console.log('process.nextTick() callback is invoked in the zone', Zone.current.name);\r\n   *     // since the callback of `process.nextTick()` runs in the same zone\r\n   *     // when it is scheduled, so the output is 'process.nextTick() callback is invoked in the\r\n   *     // zone myZone'.\r\n   *   });\r\n   * });\r\n   * ```\r\n   *\r\n   * If you set `__Zone_disable_nextTick = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch the `process.nextTick()` API and the above code\r\n   * outputs 'nextTick <root>'.\r\n   */\r\n  nextTick?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the `Node.js` `crypto` API.\r\n   *\r\n   * By default, `zone.js` monkey patches the `Node.js` `crypto` APIs to make asynchronous callbacks\r\n   * of those APIs in the same zone when called.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const crypto = require('crypto');\r\n   *\r\n   * const zone = Zone.current.fork({name: 'myZone'});\r\n   * zone.run(() => {\r\n   *   crypto.randomBytes(() => {\r\n   *     console.log('crypto.randomBytes() callback is invoked in the zone', Zone.current.name);\r\n   *     // since the callback of `crypto.randomBytes()` runs in the same zone\r\n   *     // when it is called, so the output is 'crypto.randomBytes() callback is invoked in the\r\n   *     // zone myZone'.\r\n   *   });\r\n   * });\r\n   * ```\r\n   *\r\n   * If you set `__Zone_disable_crypto = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch the `crypto` API and the above code\r\n   * outputs 'crypto <root>'.\r\n   */\r\n  crypto?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the `Object.defineProperty()` API.\r\n   *\r\n   * Note: This configuration is available only in the legacy bundle (dist/zone.js). This module is\r\n   * not available in the evergreen bundle (zone-evergreen.js).\r\n   *\r\n   * In the legacy browser, the default behavior of `zone.js` is to monkey patch\r\n   * `Object.defineProperty()` and `Object.create()` to try to ensure PropertyDescriptor parameter's\r\n   * configurable property to be true. This patch is only needed in some old mobile browsers.\r\n   *\r\n   * If you set `__Zone_disable_defineProperty = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch the `Object.defineProperty()` API and does not\r\n   * modify desc.configurable to true.\r\n   *\r\n   */\r\n  defineProperty?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser `registerElement()` API.\r\n   *\r\n   * NOTE: This configuration is only available in the legacy bundle (dist/zone.js), this\r\n   * module is not available in the evergreen bundle (zone-evergreen.js).\r\n   *\r\n   * In the legacy browser, the default behavior of `zone.js` is to monkey patch the\r\n   * `registerElement()` API to make asynchronous callbacks of the API in the same zone when\r\n   * `registerElement()` is called.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const proto = Object.create(HTMLElement.prototype);\r\n   * proto.createdCallback = function() {\r\n   *   console.log('createdCallback is invoked in the zone', Zone.current.name);\r\n   * };\r\n   * proto.attachedCallback = function() {\r\n   *   console.log('attachedCallback is invoked in the zone', Zone.current.name);\r\n   * };\r\n   * proto.detachedCallback = function() {\r\n   *   console.log('detachedCallback is invoked in the zone', Zone.current.name);\r\n   * };\r\n   * proto.attributeChangedCallback = function() {\r\n   *   console.log('attributeChangedCallback is invoked in the zone', Zone.current.name);\r\n   * };\r\n   *\r\n   * const zone = Zone.current.fork({name: 'myZone'});\r\n   * zone.run(() => {\r\n   *   document.registerElement('x-elem', {prototype: proto});\r\n   * });\r\n   * ```\r\n   *\r\n   * When these callbacks are invoked, those callbacks will be in the zone when\r\n   * `registerElement()` is called.\r\n   *\r\n   * If you set `__Zone_disable_registerElement = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch `registerElement()` API and the above code\r\n   * outputs '<root>'.\r\n   */\r\n  registerElement?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser legacy `EventTarget` API.\r\n   *\r\n   * NOTE: This configuration is only available in the legacy bundle (dist/zone.js), this module\r\n   * is not available in the evergreen bundle (zone-evergreen.js).\r\n   *\r\n   * In some old browsers, the `EventTarget` is not available, so `zone.js` cannot directly monkey\r\n   * patch the `EventTarget`. Instead, `zone.js` patches all known HTML elements' prototypes (such\r\n   * as `HtmlDivElement`). The callback of the `addEventListener()` will be in the same zone when\r\n   * the `addEventListener()` is called.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const zone = Zone.current.fork({name: 'myZone'});\r\n   * zone.run(() => {\r\n   *   div.addEventListener('click', () => {\r\n   *     console.log('div click event listener is invoked in the zone', Zone.current.name);\r\n   *     // the output is 'div click event listener is invoked in the zone myZone'.\r\n   *   });\r\n   * });\r\n   * ```\r\n   *\r\n   * If you set `__Zone_disable_EventTargetLegacy = true` before importing `zone.js`\r\n   * In some old browsers, where `EventTarget` is not available, if you set\r\n   * `__Zone_disable_EventTargetLegacy = true` before importing `zone.js`, `zone.js` does not monkey\r\n   * patch all HTML element APIs and the above code outputs 'clicked <root>'.\r\n   */\r\n  EventTargetLegacy?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser `timer` APIs.\r\n   *\r\n   * By default, `zone.js` monkey patches browser timer\r\n   * APIs (`setTimeout()`/`setInterval()`/`setImmediate()`) to make asynchronous callbacks of those\r\n   * APIs in the same zone when scheduled.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const zone = Zone.current.fork({name: 'myZone'});\r\n   * zone.run(() => {\r\n   *   setTimeout(() => {\r\n   *     console.log('setTimeout() callback is invoked in the zone', Zone.current.name);\r\n   *     // since the callback of `setTimeout()` runs in the same zone\r\n   *     // when it is scheduled, so the output is 'setTimeout() callback is invoked in the zone\r\n   *     // myZone'.\r\n   *   });\r\n   * });\r\n   * ```\r\n   *\r\n   * If you set `__Zone_disable_timers = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch `timer` API and the above code\r\n   * outputs 'timeout <root>'.\r\n   *\r\n   */\r\n  timers?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser `requestAnimationFrame()` API.\r\n   *\r\n   * By default, `zone.js` monkey patches the browser `requestAnimationFrame()` API\r\n   * to make the asynchronous callback of the `requestAnimationFrame()` in the same zone when\r\n   * scheduled.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const zone = Zone.current.fork({name: 'myZone'});\r\n   * zone.run(() => {\r\n   *   requestAnimationFrame(() => {\r\n   *     console.log('requestAnimationFrame() callback is invoked in the zone', Zone.current.name);\r\n   *     // since the callback of `requestAnimationFrame()` will be in the same zone\r\n   *     // when it is scheduled, so the output will be 'requestAnimationFrame() callback is invoked\r\n   *     // in the zone myZone'\r\n   *   });\r\n   * });\r\n   * ```\r\n   *\r\n   * If you set `__Zone_disable_requestAnimationFrame = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch the `requestAnimationFrame()` API and the above code\r\n   * outputs 'raf <root>'.\r\n   */\r\n  requestAnimationFrame?: boolean;\r\n  /**\r\n   *\r\n   * Disable the monkey patch of the browser blocking APIs(`alert()`/`prompt()`/`confirm()`).\r\n   */\r\n  blocking?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser `EventTarget` APIs.\r\n   *\r\n   * By default, `zone.js` monkey patches EventTarget APIs. The callbacks of the\r\n   * `addEventListener()` run in the same zone when the `addEventListener()` is called.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const zone = Zone.current.fork({name: 'myZone'});\r\n   * zone.run(() => {\r\n   *   div.addEventListener('click', () => {\r\n   *     console.log('div event listener is invoked in the zone', Zone.current.name);\r\n   *     // the output is 'div event listener is invoked in the zone myZone'.\r\n   *   });\r\n   * });\r\n   * ```\r\n   *\r\n   * If you set `__Zone_disable_EventTarget = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch EventTarget API and the above code\r\n   * outputs 'clicked <root>'.\r\n   *\r\n   */\r\n  EventTarget?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser `FileReader` APIs.\r\n   */\r\n  FileReader?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser `MutationObserver` APIs.\r\n   */\r\n  MutationObserver?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser `IntersectionObserver` APIs.\r\n   */\r\n  IntersectionObserver?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser onProperty APIs(such as onclick).\r\n   *\r\n   * By default, `zone.js` monkey patches onXXX properties (such as onclick). The callbacks of onXXX\r\n   * properties run in the same zone when the onXXX properties is set.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const zone = Zone.current.fork({name: 'myZone'});\r\n   * zone.run(() => {\r\n   *   div.onclick = () => {\r\n   *     console.log('div click event listener is invoked in the zone', Zone.current.name);\r\n   *     // the output will be 'div click event listener is invoked in the zone myZone'\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * If you set `__Zone_disable_on_property = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch onXXX properties and the above code\r\n   * outputs 'clicked <root>'.\r\n   *\r\n   */\r\n  on_property?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser `customElements` APIs.\r\n   *\r\n   * By default, `zone.js` monkey patches `customElements` APIs to make callbacks run in the\r\n   * same zone when the `customElements.define()` is called.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * class TestCustomElement extends HTMLElement {\r\n   *   constructor() { super(); }\r\n   *   connectedCallback() {}\r\n   *   disconnectedCallback() {}\r\n   *   attributeChangedCallback(attrName, oldVal, newVal) {}\r\n   *   adoptedCallback() {}\r\n   * }\r\n   *\r\n   * const zone = Zone.fork({name: 'myZone'});\r\n   * zone.run(() => {\r\n   *   customElements.define('x-elem', TestCustomElement);\r\n   * });\r\n   * ```\r\n   *\r\n   * All those callbacks defined in TestCustomElement runs in the zone when\r\n   * the `customElements.define()` is called.\r\n   *\r\n   * If you set `__Zone_disable_customElements = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch `customElements` APIs and the above code\r\n   * runs inside <root> zone.\r\n   */\r\n  customElements?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser `XMLHttpRequest` APIs.\r\n   *\r\n   * By default, `zone.js` monkey patches `XMLHttpRequest` APIs to make XMLHttpRequest act\r\n   * as macroTask.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const zone = Zone.current.fork({\r\n   *   name: 'myZone',\r\n   *   onScheduleTask: (delegate, curr, target, task) => {\r\n   *     console.log('task is scheduled', task.type, task.source, task.zone.name);\r\n   *     return delegate.scheduleTask(target, task);\r\n   *   }\r\n   * })\r\n   * const xhr = new XMLHttpRequest();\r\n   * zone.run(() => {\r\n   *   xhr.onload = function() {};\r\n   *   xhr.open('get', '/', true);\r\n   *   xhr.send();\r\n   * });\r\n   * ```\r\n   *\r\n   * In this example, the instance of XMLHttpRequest runs in the zone and acts as a macroTask. The\r\n   * output is 'task is scheduled macroTask, XMLHttpRequest.send, zone'.\r\n   *\r\n   * If you set `__Zone_disable_XHR = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch `XMLHttpRequest` APIs and the above onScheduleTask callback\r\n   * will not be called.\r\n   *\r\n   */\r\n  XHR?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser geolocation APIs.\r\n   *\r\n   * By default, `zone.js` monkey patches geolocation APIs to make callbacks run in the same zone\r\n   * when those APIs are called.\r\n   *\r\n   * Consider the following examples:\r\n   *\r\n   * ```\r\n   * const zone = Zone.current.fork({\r\n   *   name: 'myZone'\r\n   * });\r\n   *\r\n   * zone.run(() => {\r\n   *   navigator.geolocation.getCurrentPosition(pos => {\r\n   *     console.log('navigator.getCurrentPosition() callback is invoked in the zone',\r\n   *     Zone.current.name);\r\n   *     // output is 'navigator.getCurrentPosition() callback is invoked in the zone myZone'.\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * If set you `__Zone_disable_geolocation = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch geolocation APIs and the above code\r\n   * outputs 'getCurrentPosition <root>'.\r\n   *\r\n   */\r\n  geolocation?: boolean;\r\n  /**\r\n   * Disable the monkey patch of the browser `canvas` APIs.\r\n   *\r\n   * By default, `zone.js` monkey patches `canvas` APIs to make callbacks run in the same zone when\r\n   * those APIs are called.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * const zone = Zone.current.fork({\r\n   *   name: 'myZone'\r\n   * });\r\n   *\r\n   * zone.run(() => {\r\n   *   canvas.toBlob(blog => {\r\n   *     console.log('canvas.toBlob() callback is invoked in the zone', Zone.current.name);\r\n   *     // output is 'canvas.toBlob() callback is invoked in the zone myZone'.\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * If you set `__Zone_disable_canvas = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch `canvas` APIs and the above code\r\n   * outputs 'canvas.toBlob <root>'.\r\n   */\r\n  canvas?: boolean;\r\n  /**\r\n   * Disable the `Promise` monkey patch.\r\n   *\r\n   * By default, `zone.js` monkey patches `Promise` APIs to make the `then()/catch()` callbacks in\r\n   * the same zone when those callbacks are called.\r\n   *\r\n   * Consider the following examples:\r\n   *\r\n   * ```\r\n   * const zone = Zone.current.fork({name: 'myZone'});\r\n   *\r\n   * const p = Promise.resolve(1);\r\n   *\r\n   * zone.run(() => {\r\n   *   p.then(() => {\r\n   *     console.log('then() callback is invoked in the zone', Zone.current.name);\r\n   *     // output is 'then() callback is invoked in the zone myZone'.\r\n   *   });\r\n   * });\r\n   * ```\r\n   *\r\n   * If you set `__Zone_disable_ZoneAwarePromise = true` before importing `zone.js`,\r\n   * `zone.js` does not monkey patch `Promise` APIs and the above code\r\n   * outputs 'promise then callback <root>'.\r\n   */\r\n  ZoneAwarePromise?: boolean;\r\n}\r\nexport type RxZoneGlobalDisableConfigurationsKey =\r\n  keyof RxZoneGlobalDisableConfigurations;\r\nexport const zoneGlobalDisableConfigurationsKeys: RxZoneGlobalDisableConfigurationsKey[] =\r\n  [\r\n    'EventEmitter',\r\n    'fs',\r\n    'node_timers',\r\n    'nextTick',\r\n    'crypto',\r\n    'defineProperty',\r\n    'registerElement',\r\n    'EventTargetLegacy',\r\n    'timers',\r\n    'requestAnimationFrame',\r\n    'blocking',\r\n    'EventTarget',\r\n    'FileReader',\r\n    'MutationObserver',\r\n    'IntersectionObserver',\r\n    'on_property',\r\n    'customElements',\r\n    'XHR',\r\n    'geolocation',\r\n    'canvas',\r\n    'ZoneAwarePromise',\r\n  ];\r\n\r\n// prefix: __zone_symbol__\r\nexport interface RxZoneGlobalEventsConfigurations {\r\n  /**\r\n   * Define event names that users don't want monkey patched by the `zone.js`.\r\n   *\r\n   * By default, `zone.js` monkey patches EventTarget.addEventListener(). The event listener\r\n   * callback runs in the same zone when the addEventListener() is called.\r\n   *\r\n   * Sometimes, you don't want all of the event names used in this patched version because it\r\n   * impacts performance. For example, you might want `scroll` or `mousemove` event listeners to run\r\n   * the native `addEventListener()` for better performance.\r\n   *\r\n   * Users can achieve this goal by defining `__zone_symbol__UNPATCHED_EVENTS = ['scroll',\r\n   * 'mousemove'];` before importing `zone.js`.\r\n   */\r\n  UNPATCHED_EVENTS?: string[];\r\n  /**\r\n   * Define the event names of the passive listeners.\r\n   *\r\n   * To add passive event listeners, you can use `elem.addEventListener('scroll', listener,\r\n   * {passive: true});` or implement your own `EventManagerPlugin`.\r\n   *\r\n   * You can also define a global variable as follows:\r\n   *\r\n   * ```\r\n   * __zone_symbol__PASSIVE_EVENTS = ['scroll'];\r\n   * ```\r\n   *\r\n   * The preceding code makes all scroll event listeners passive.\r\n   */\r\n  PASSIVE_EVENTS?: string[];\r\n}\r\nexport type RxZoneGlobalEventsConfigurationsKey =\r\n  keyof RxZoneGlobalEventsConfigurations;\r\nexport const zoneGlobalEventsConfigurationsKeys: RxZoneGlobalEventsConfigurationsKey[] =\r\n  ['UNPATCHED_EVENTS', 'PASSIVE_EVENTS'];\r\n\r\n// prefix: __zone_symbol__\r\nexport interface RxZoneGlobalSettingsConfigurations {\r\n  /**\r\n   * Disable wrapping uncaught promise rejection.\r\n   *\r\n   * By default, `zone.js` wraps the uncaught promise rejection in a new `Error` object\r\n   * which contains additional information such as a value of the rejection and a stack trace.\r\n   *\r\n   * If you set `__zone_symbol__DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION = true;` before\r\n   * importing `zone.js`, `zone.js` will not wrap the uncaught promise rejection.\r\n   */\r\n  DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION?: boolean;\r\n}\r\nexport type RxZoneGlobalSettingsConfigurationsKey =\r\n  keyof RxZoneGlobalSettingsConfigurations;\r\nexport const zoneGlobalSettingsConfigurationsKeys: RxZoneGlobalSettingsConfigurationsKey[] =\r\n  ['DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION'];\r\n\r\n// prefix: __zone_symbol__\r\nexport interface RxZoneRuntimeConfigurations {\r\n  ignoreConsoleErrorUncaughtError?: boolean;\r\n}\r\nexport type RxZoneRuntimeConfigurationsKey = keyof RxZoneRuntimeConfigurations;\r\nexport const zoneRuntimeConfigurationsKeys: RxZoneRuntimeConfigurationsKey[] = [\r\n  'ignoreConsoleErrorUncaughtError',\r\n];\r\n\r\n// prefix: __Zone_disable_\r\nexport interface RxZoneTestDisableConfigurations {\r\n  /**\r\n   * Disable the Jasmine integration.\r\n   *\r\n   * In the `zone-testing.js` bundle, by default, `zone-testing.js` monkey patches Jasmine APIs\r\n   * to make Jasmine APIs run in specified zone.\r\n   *\r\n   * 1. Make the `describe()`/`xdescribe()`/`fdescribe()` methods run in the syncTestZone.\r\n   * 2. Make the `it()`/`xit()`/`fit()`/`beforeEach()`/`afterEach()`/`beforeAll()`/`afterAll()`\r\n   * methods run in the ProxyZone.\r\n   *\r\n   * With this patch, `async()`/`fakeAsync()` can work with the Jasmine runner.\r\n   *\r\n   * If you set `__Zone_disable_jasmine = true` before importing `zone-testing.js`,\r\n   * `zone-testing.js` does not monkey patch the jasmine APIs and the `async()`/`fakeAsync()` cannot\r\n   * work with the Jasmine runner any longer.\r\n   */\r\n  jasmine?: boolean;\r\n  /**\r\n   * Disable the Mocha integration.\r\n   *\r\n   * In the `zone-testing.js` bundle, by default, `zone-testing.js` monkey patches the Mocha APIs\r\n   * to make Mocha APIs run in the specified zone.\r\n   *\r\n   * 1. Make the `describe()`/`xdescribe()`/`fdescribe()` methods run in the syncTestZone.\r\n   * 2. Make the `it()`/`xit()`/`fit()`/`beforeEach()`/`afterEach()`/`beforeAll()`/`afterAll()`\r\n   * methods run in the ProxyZone.\r\n   *\r\n   * With this patch, `async()`/`fakeAsync()` can work with the Mocha runner.\r\n   *\r\n   * If you set `__Zone_disable_mocha = true` before importing `zone-testing.js`,\r\n   * `zone-testing.js` does not monkey patch the Mocha APIs and the `async()/`fakeAsync()` can not\r\n   * work with the Mocha runner any longer.\r\n   */\r\n  mocha?: boolean;\r\n  /**\r\n   * Disable the Jest integration.\r\n   *\r\n   * In the `zone-testing.js` bundle, by default, `zone-testing.js` monkey patches Jest APIs\r\n   * to make Jest APIs run in the specified zone.\r\n   *\r\n   * 1. Make the `describe()`/`xdescribe()`/`fdescribe()` methods run in the syncTestZone.\r\n   * 2. Make the `it()`/`xit()`/`fit()`/`beforeEach()`/`afterEach()`/`before()`/`after()` methods\r\n   * run in the ProxyZone.\r\n   *\r\n   * With this patch, `async()`/`fakeAsync()` can work with the Jest runner.\r\n   *\r\n   * If you set `__Zone_disable_jest = true` before importing `zone-testing.js`,\r\n   * `zone-testing.js` does not monkey patch the jest APIs and `async()`/`fakeAsync()` cannot\r\n   * work with the Jest runner any longer.\r\n   */\r\n  jest?: boolean;\r\n}\r\nexport type RxZoneTestDisableConfigurationsKey =\r\n  keyof RxZoneTestDisableConfigurations;\r\nexport const zoneTestDisableConfigurationsKeys: RxZoneTestDisableConfigurationsKey[] =\r\n  ['jasmine', 'mocha', 'jest'];\r\n\r\n// prefix: __zone_symbol__\r\nexport interface RxZoneTestSettingsConfigurations {\r\n  /**\r\n   * Disable monkey patch the jasmine clock APIs.\r\n   *\r\n   * By default, `zone-testing.js` monkey patches the `jasmine.clock()` API,\r\n   * so the `jasmine.clock()` can work with the `fakeAsync()/tick()` API.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * describe('jasmine.clock integration', () => {\r\n   *   beforeEach(() => {\r\n   *     jasmine.clock().install();\r\n   *   });\r\n   *   afterEach(() => {\r\n   *     jasmine.clock().uninstall();\r\n   *   });\r\n   *   it('fakeAsync test', fakeAsync(() => {\r\n   *     setTimeout(spy, 100);\r\n   *     expect(spy).not.toHaveBeenCalled();\r\n   *     jasmine.clock().tick(100);\r\n   *     expect(spy).toHaveBeenCalled();\r\n   *   }));\r\n   * });\r\n   * ```\r\n   *\r\n   * In the `fakeAsync()` method, `jasmine.clock().tick()` works just like `tick()`.\r\n   *\r\n   * If you set `__zone_symbol__fakeAsyncDisablePatchingClock = true` before importing\r\n   * `zone-testing.js`,`zone-testing.js` does not monkey patch the `jasmine.clock()` APIs and the\r\n   * `jasmine.clock()` cannot work with `fakeAsync()` any longer.\r\n   */\r\n  fakeAsyncDisablePatchingClock?: boolean;\r\n  /**\r\n   * Enable auto running into `fakeAsync()` when installing the `jasmine.clock()`.\r\n   *\r\n   * By default, `zone-testing.js` does not automatically run into `fakeAsync()`\r\n   * if the `jasmine.clock().install()` is called.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * describe('jasmine.clock integration', () => {\r\n   *   beforeEach(() => {\r\n   *     jasmine.clock().install();\r\n   *   });\r\n   *   afterEach(() => {\r\n   *     jasmine.clock().uninstall();\r\n   *   });\r\n   *   it('fakeAsync test', fakeAsync(() => {\r\n   *     setTimeout(spy, 100);\r\n   *     expect(spy).not.toHaveBeenCalled();\r\n   *     jasmine.clock().tick(100);\r\n   *     expect(spy).toHaveBeenCalled();\r\n   *   }));\r\n   * });\r\n   * ```\r\n   *\r\n   * You must run `fakeAsync()` to make test cases in the `FakeAsyncTestZone`.\r\n   *\r\n   * If you set `__zone_symbol__fakeAsyncAutoFakeAsyncWhenClockPatched = true` before importing\r\n   * `zone-testing.js`, `zone-testing.js` can run test case automatically in the\r\n   * `FakeAsyncTestZone` without calling the `fakeAsync()`.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * describe('jasmine.clock integration', () => {\r\n   *   beforeEach(() => {\r\n   *     jasmine.clock().install();\r\n   *   });\r\n   *   afterEach(() => {\r\n   *     jasmine.clock().uninstall();\r\n   *   });\r\n   *   it('fakeAsync test', () => { // here we don't need to call fakeAsync\r\n   *     setTimeout(spy, 100);\r\n   *     expect(spy).not.toHaveBeenCalled();\r\n   *     jasmine.clock().tick(100);\r\n   *     expect(spy).toHaveBeenCalled();\r\n   *   });\r\n   * });\r\n   * ```\r\n   *\r\n   */\r\n  fakeAsyncAutoFakeAsyncWhenClockPatched?: boolean;\r\n  /**\r\n   * Enable waiting for the unresolved promise in the `async()` test.\r\n   *\r\n   * In the `async()` test, `AsyncTestZone` waits for all the asynchronous tasks to finish. By\r\n   * default, if some promises remain unresolved, `AsyncTestZone` does not wait and reports that it\r\n   * received an unexpected result.\r\n   *\r\n   * Consider the following example:\r\n   *\r\n   * ```\r\n   * describe('wait never resolved promise', () => {\r\n   *   it('async with never resolved promise test', async(() => {\r\n   *     const p = new Promise(() => {});\r\n   *     p.then(() => {\r\n   *       // do some expectation.\r\n   *     });\r\n   *   }))\r\n   * });\r\n   * ```\r\n   *\r\n   * By default, this case passes, because the callback of `p.then()` is never called. Because `p`\r\n   * is an unresolved promise, there is no pending asynchronous task, which means the `async()`\r\n   * method does not wait.\r\n   *\r\n   * If you set `__zone_symbol__supportWaitUnResolvedChainedPromise = true`, the above case\r\n   * times out, because `async()` will wait for the unresolved promise.\r\n   */\r\n  supportWaitUnResolvedChainedPromise?: boolean;\r\n}\r\nexport type RxZoneTestSettingsConfigurationsKey =\r\n  keyof RxZoneTestSettingsConfigurations;\r\nexport const zoneTestSettingsConfigurationsKeys: RxZoneTestSettingsConfigurationsKey[] =\r\n  [\r\n    'fakeAsyncDisablePatchingClock',\r\n    'fakeAsyncAutoFakeAsyncWhenClockPatched',\r\n    'supportWaitUnResolvedChainedPromise',\r\n  ];\r\n\r\nexport interface RxZoneFlagsHelperFunctions {\r\n  /**\r\n   * Logs all zone.js configurations in the console.\r\n   */\r\n  __rxa_zone_config__log?: () => void;\r\n}\r\n","import {\n  RxZoneConfigConfiguration,\n  RxZoneConfigConvenienceMethods,\n} from './model/zone-config.types';\nimport { xhrEvents } from './event-names';\n\nexport const convenienceMethods = (\n  config: RxZoneConfigConfiguration\n): RxZoneConfigConvenienceMethods => ({\n  unpatchXHR: () => {\n    config.global.disable.XHR();\n    config.events.disable.UNPATCHED_EVENTS([...xhrEvents]);\n  },\n  useUnpatchedPassiveScrollEvents: () => {\n    config.events.disable.PASSIVE_EVENTS(['scroll']);\n    config.events.disable.UNPATCHED_EVENTS(['scroll']);\n  },\n});\n","import { ɵglobal } from '@angular/core';\r\nimport {\r\n  RxZoneFlagsHelperFunctions,\r\n  zoneGlobalDisableConfigurationsKeys,\r\n  zoneGlobalEventsConfigurationsKeys,\r\n  zoneGlobalSettingsConfigurationsKeys,\r\n  zoneRuntimeConfigurationsKeys,\r\n  zoneTestDisableConfigurationsKeys,\r\n  zoneTestSettingsConfigurationsKeys,\r\n} from './model/configurations.types';\r\nimport { RxZoneGlobalConfigurations } from './model/zone.configurations.api';\r\nimport {\r\n  RxZoneConfigConfiguration,\r\n  RxZoneConfig,\r\n  RxGlobalDisableConfigurationMethods,\r\n  RxTestDisableConfigurationMethods,\r\n  RxZoneGlobalEventsConfigurationsMethods,\r\n  RxRuntimeConfigurationMethods,\r\n} from './model/zone-config.types';\r\nimport { convenienceMethods } from './convenience-methods';\r\n\r\nconst zoneDisable = '__Zone_disable_';\r\nconst zoneSymbol = '__zone_symbol__';\r\n\r\n/**\r\n * https://angular.io/guide/zone#setting-up-zonejs\r\n **/\r\nfunction assertZoneConfig() {\r\n  if ((window as any).Zone !== undefined) {\r\n    // @TODO link to docs\r\n    console.error('zone-flags file needs to get imported before zone.js');\r\n  }\r\n}\r\n\r\nconst addDisableFlag = (prop: string) => ({\r\n  [prop]: () => {\r\n    assertZoneConfig();\r\n    return ((window as any)[zoneDisable + prop] = true);\r\n  },\r\n});\r\n\r\nconst addSymbolFlag = (prop: string) => ({\r\n  [prop]: () => {\r\n    assertZoneConfig();\r\n    return ((window as any)[zoneSymbol + prop] = true);\r\n  },\r\n});\r\n\r\nconst addArraySymbolFlag = (prop: string) => ({\r\n  [prop]: (eventNames: string[]) => {\r\n    assertZoneConfig();\r\n    const w: any = window as any;\r\n    return (w[zoneSymbol + prop] = [\r\n      ...(Array.isArray(w[zoneSymbol + prop]) ? w[zoneSymbol + prop] : []),\r\n      ...eventNames,\r\n    ]);\r\n  },\r\n});\r\n\r\nconst reduceToObject = <T>(methodsArray: any[]): T => {\r\n  return methodsArray.reduce((map, item) => ({ ...map, ...item }), {} as T);\r\n};\r\n\r\n/**\r\n * factory function to create a `RxZoneConfig` object.\r\n *\r\n * @Example\r\n * import { globalEvents,xhrEvent, zoneConfig} from '@rx-angular/cdk/zone-flags';\r\n *\r\n * const zoneConfig = createZoneFlagsConfigurator();\r\n *\r\n * zoneConfig.global.disable.requestAnimationFrame();\r\n * zoneConfig.global.disable.timers();\r\n * zoneConfig.events.disable.UNPATCHED_EVENTS([...globalEvents, ...xhrEvent]);\r\n *\r\n */\r\nfunction createZoneFlagsConfigurator(): RxZoneConfig {\r\n  const cfg = ɵglobal as unknown as RxZoneGlobalConfigurations;\r\n  const configProps = [\r\n    ...[\r\n      ...zoneGlobalDisableConfigurationsKeys,\r\n      ...zoneTestDisableConfigurationsKeys,\r\n    ].map((prop) => zoneDisable + prop),\r\n    ...[\r\n      ...zoneGlobalSettingsConfigurationsKeys,\r\n      ...zoneTestSettingsConfigurationsKeys,\r\n      ...zoneGlobalEventsConfigurationsKeys,\r\n      ...zoneRuntimeConfigurationsKeys,\r\n    ].map((prop) => zoneSymbol + prop),\r\n  ];\r\n\r\n  // append as global method for easy debugging\r\n  (cfg as RxZoneFlagsHelperFunctions).__rxa_zone_config__log = (): void => {\r\n    configProps.forEach((flag) => {\r\n      // tslint:disable-next-line:no-unused-expression\r\n      cfg[flag] && console.log(flag, cfg[flag]);\r\n    });\r\n  };\r\n\r\n  const zoneConfigObj: RxZoneConfigConfiguration = {\r\n    global: {\r\n      disable: reduceToObject<RxGlobalDisableConfigurationMethods>([\r\n        ...zoneGlobalDisableConfigurationsKeys.map(addDisableFlag),\r\n        ...zoneGlobalSettingsConfigurationsKeys.map(addSymbolFlag),\r\n      ]),\r\n    },\r\n    test: {\r\n      disable: reduceToObject<RxTestDisableConfigurationMethods>([\r\n        ...zoneTestDisableConfigurationsKeys.map(addDisableFlag),\r\n        ...zoneTestSettingsConfigurationsKeys.map(addSymbolFlag),\r\n      ]),\r\n    },\r\n    events: {\r\n      disable: reduceToObject<RxZoneGlobalEventsConfigurationsMethods>(\r\n        zoneGlobalEventsConfigurationsKeys.map(addArraySymbolFlag)\r\n      ),\r\n    },\r\n    runtime: {\r\n      disable: reduceToObject<RxRuntimeConfigurationMethods>(\r\n        zoneRuntimeConfigurationsKeys.map(addSymbolFlag)\r\n      ),\r\n    },\r\n  };\r\n\r\n  return {\r\n    ...zoneConfigObj,\r\n    ...convenienceMethods(zoneConfigObj),\r\n  };\r\n}\r\n\r\n/**\r\n * An object for typed zone-flags configuration.\r\n *\r\n * @Example\r\n *\r\n * create file `zone-flags.ts` parallel to your `polyfills.ts` and insert following content:\r\n * ```typescript\r\n * import { globalEvents, xhrEvent, zoneConfig} from '@rx-angular/cdk/zone-flags';\r\n *\r\n * zoneConfig.global.disable.requestAnimationFrame();\r\n * zoneConfig.global.disable.timers();\r\n * zoneConfig.events.disable.UNPATCHED_EVENTS([...globalEvents, ...xhrEvent]);\r\n * ```\r\n * In `polyfills.ts` above the zone import, import `zone-flags.ts`\r\n *\r\n * ```typescript\r\n * import './zone-flags';\r\n * // Zone JS is required by default for Angular itself.\r\n * import 'zone.js';\r\n * ```\r\n *\r\n */\r\nexport const zoneConfig = createZoneFlagsConfigurator();\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;AAAA;AAEA;MACa,WAAW,GAAG,CAAC,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,UAAU,EAAW;AAE7E;;;;MAIa,WAAW,GAAG;IACzB,WAAW;IACX,UAAU;IACV,YAAY;IACZ,YAAY;IACZ,WAAW;IACX,UAAU;IACV,WAAW;IACX,SAAS;IACT,OAAO;EACE;AAEX;;;;MAIa,WAAW,GAAG;;IAEzB,OAAO;IACP,YAAY;EACH;AAEX;MACa,WAAW,GAAG;IACzB,OAAO;IACP,SAAS;IACT,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,QAAQ;EACC;AAEX;;;MAGa,kBAAkB,GAAG,YAAY;AAE9C;MACa,cAAc,GAAG,CAAC,SAAS,EAAE,UAAU,EAAE,OAAO,EAAW;AAExE;MACa,QAAQ,GAAG;IACtB,mBAAmB;IACnB,eAAe;IACf,kBAAkB;IAClB,qBAAqB;IACrB,qBAAqB;IACrB,gBAAgB;IAChB,4BAA4B;IAC5B,8BAA8B;IAC9B,wBAAwB;EACf;AAEX;MACa,eAAe,GAAG;IAC7B,iBAAiB;IACjB,oBAAoB;IACpB,cAAc;IACd,eAAe;IACf,gBAAgB;IAChB,cAAc;IACd,gBAAgB;IAChB,iBAAiB;IACjB,eAAe;IACf,gBAAgB;IAChB,gBAAgB;IAChB,eAAe;IACf,cAAc;IACd,eAAe;IACf,aAAa;EACJ;AAEX;MACa,WAAW,GAAG,CAAC,YAAY,EAAE,aAAa,EAAW;AAClE;MACa,aAAa,GAAG,CAAC,SAAS,EAAE,QAAQ,EAAW;AAE5D;MACa,WAAW,GAAG;IACzB,SAAS;IACT,gBAAgB;IAChB,OAAO;IACP,MAAM;IACN,SAAS;IACT,cAAc;EACL;AAEX;MACa,iBAAiB,GAAG;IAC/B,kBAAkB;IAClB,mBAAmB;IACnB,gBAAgB;EACP;AAEX;;;;;MAKa,WAAW,GAAG;;IAEzB,aAAa;IACb,cAAc;IACd,aAAa;IACb,aAAa;;IAEb,WAAW;IACX,eAAe;IACf,YAAY;IACZ,cAAc;IACd,mBAAmB;IACnB,oBAAoB;IACpB,WAAW;;IAGX,YAAY;IACZ,UAAU;IACV,WAAW;IACX,aAAa;;IAGb,MAAM;IACN,SAAS;IACT,UAAU;IACV,WAAW;IACX,WAAW;IACX,UAAU;IACV,WAAW;IACX,MAAM;EACG;MAEE,YAAY,GAAG;IAC1B,aAAa;IACb,QAAQ;IACR,QAAQ;IAER,OAAO;IACP,MAAM;IACN,YAAY;IACZ,gBAAgB;IAChB,WAAW;IACX,QAAQ;IAER,OAAO;EACE;MAEE,eAAe,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM,EAAW;AAE9E;;;;;;AAMA;MACa,SAAS,GAAG,CAAC,MAAM,EAAE,OAAO,EAAW;AAEpD;MACa,YAAY,GAAG;IAC1B,yBAAyB;IACzB,gBAAgB;IAChB,SAAS;IACT,OAAO;IAEP,mBAAmB;IAEnB,YAAY;IAEZ,QAAQ;IACR,SAAS;IACT,SAAS;IAET,SAAS;IACT,YAAY;IACZ,SAAS;EACA;AAEX;;;MAGa,SAAS,GAAG,KAAK,CAAC,IAAI,CACjC,IAAI,GAAG,CAAC;IACN,GAAG,WAAW;IACd,GAAG,WAAW;IACd,GAAG,WAAW;IACd,GAAG,WAAW;IACd,GAAG,cAAc;IACjB,GAAG,WAAW;IACd,GAAG,QAAQ;IACX,GAAG,eAAe;IAClB,GAAG,WAAW;IACd,GAAG,aAAa;IAChB,GAAG,WAAW;IACd,GAAG,iBAAiB;IACpB,GAAG,WAAW;IACd,GAAG,YAAY;IACf,GAAG,eAAe;IAClB,GAAG,SAAS;IACZ,GAAG,YAAY;CAChB,CAAC;;ACqRG,MAAM,mCAAmC,GAC9C;IACE,cAAc;IACd,IAAI;IACJ,aAAa;IACb,UAAU;IACV,QAAQ;IACR,gBAAgB;IAChB,iBAAiB;IACjB,mBAAmB;IACnB,QAAQ;IACR,uBAAuB;IACvB,UAAU;IACV,aAAa;IACb,YAAY;IACZ,kBAAkB;IAClB,sBAAsB;IACtB,aAAa;IACb,gBAAgB;IAChB,KAAK;IACL,aAAa;IACb,QAAQ;IACR,kBAAkB;CACnB,CAAC;AAoCG,MAAM,kCAAkC,GAC7C,CAAC,kBAAkB,EAAE,gBAAgB,CAAC,CAAC;AAiBlC,MAAM,oCAAoC,GAC/C,CAAC,6CAA6C,CAAC,CAAC;AAO3C,MAAM,6BAA6B,GAAqC;IAC7E,iCAAiC;CAClC,CAAC;AA0DK,MAAM,iCAAiC,GAC5C,CAAC,SAAS,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;AAuHxB,MAAM,kCAAkC,GAC7C;IACE,+BAA+B;IAC/B,wCAAwC;IACxC,qCAAqC;CACtC;;AC7uBI,MAAM,kBAAkB,GAAG,CAChC,MAAiC,MACG;IACpC,UAAU,EAAE;QACV,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;KACxD;IACD,+BAA+B,EAAE;QAC/B,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;QACjD,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;KACpD;CACF,CAAC;;ACIF,MAAM,WAAW,GAAG,iBAAiB,CAAC;AACtC,MAAM,UAAU,GAAG,iBAAiB,CAAC;AAErC;;;AAGA,SAAS,gBAAgB;IACvB,IAAK,MAAc,CAAC,IAAI,KAAK,SAAS,EAAE;;QAEtC,OAAO,CAAC,KAAK,CAAC,sDAAsD,CAAC,CAAC;KACvE;AACH,CAAC;AAED,MAAM,cAAc,GAAG,CAAC,IAAY,MAAM;IACxC,CAAC,IAAI,GAAG;QACN,gBAAgB,EAAE,CAAC;QACnB,QAAS,MAAc,CAAC,WAAW,GAAG,IAAI,CAAC,GAAG,IAAI,EAAE;KACrD;CACF,CAAC,CAAC;;AAEH,MAAM,aAAa,GAAG,CAAC,IAAY,MAAM;IACvC,CAAC,IAAI,GAAG;QACN,gBAAgB,EAAE,CAAC;QACnB,QAAS,MAAc,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,IAAI,EAAE;KACpD;CACF,CAAC,CAAC;;AAEH,MAAM,kBAAkB,GAAG,CAAC,IAAY,MAAM;IAC5C,CAAC,IAAI,GAAG,CAAC,UAAoB;QAC3B,gBAAgB,EAAE,CAAC;QACnB,MAAM,CAAC,GAAQ,MAAa,CAAC;QAC7B,QAAQ,CAAC,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG;YAC7B,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,UAAU,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YACpE,GAAG,UAAU;SACd,EAAE;KACJ;CACF,CAAC,CAAC;;AAEH,MAAM,cAAc,GAAG,CAAI,YAAmB;IAC5C,OAAO,YAAY,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,sCAAW,GAAG,GAAK,IAAI,EAAG,EAAE,EAAO,CAAC,CAAC;AAC5E,CAAC,CAAC;;AAEF;;;;;;;;;;;;;AAaA,SAAS,2BAA2B;IAClC,MAAM,GAAG,GAAG,OAAgD,CAAC;IAC7D,MAAM,WAAW,GAAG;QAClB,GAAG;YACD,GAAG,mCAAmC;YACtC,GAAG,iCAAiC;SACrC,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,WAAW,GAAG,IAAI,CAAC;QACnC,GAAG;YACD,GAAG,oCAAoC;YACvC,GAAG,kCAAkC;YACrC,GAAG,kCAAkC;YACrC,GAAG,6BAA6B;SACjC,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,UAAU,GAAG,IAAI,CAAC;KACnC,CAAC;;IAGD,GAAkC,CAAC,sBAAsB,GAAG;QAC3D,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI;;YAEvB,GAAG,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;SAC3C,CAAC,CAAC;KACJ,CAAC;IAEF,MAAM,aAAa,GAA8B;QAC/C,MAAM,EAAE;YACN,OAAO,EAAE,cAAc,CAAsC;gBAC3D,GAAG,mCAAmC,CAAC,GAAG,CAAC,cAAc,CAAC;gBAC1D,GAAG,oCAAoC,CAAC,GAAG,CAAC,aAAa,CAAC;aAC3D,CAAC;SACH;QACD,IAAI,EAAE;YACJ,OAAO,EAAE,cAAc,CAAoC;gBACzD,GAAG,iCAAiC,CAAC,GAAG,CAAC,cAAc,CAAC;gBACxD,GAAG,kCAAkC,CAAC,GAAG,CAAC,aAAa,CAAC;aACzD,CAAC;SACH;QACD,MAAM,EAAE;YACN,OAAO,EAAE,cAAc,CACrB,kCAAkC,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAC3D;SACF;QACD,OAAO,EAAE;YACP,OAAO,EAAE,cAAc,CACrB,6BAA6B,CAAC,GAAG,CAAC,aAAa,CAAC,CACjD;SACF;KACF,CAAC;IAEF,uCACK,aAAa,GACb,kBAAkB,CAAC,aAAa,CAAC,EACpC;AACJ,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;MAsBa,UAAU,GAAG,2BAA2B;;ACxJrD;;;;;;"}