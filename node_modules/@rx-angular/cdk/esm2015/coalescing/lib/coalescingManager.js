export const coalescingManager = createCoalesceManager();
function hasKey(ctx, property) {
    return ctx[property] != null;
}
/*
 * createPropertiesWeakMap
 *
 * @param getDefaults: (o: O) => P
 * Example:
 *
 * export interface Properties {
 *   isCoalescing: boolean;
 * }
 *
 * const obj: object = {
 *   foo: 'bar',
 *   isCoalescing: 'weakMap version'
 * };
 *
 * const getDefaults = (ctx: object): Properties => ({isCoalescing: false});
 * const propsMap = createPropertiesWeakMap<object, Properties>(getDefaults);
 *
 * console.log('obj before:', obj);
 * // {foo: "bar", isCoalescing: "weakMap version"}
 * console.log('props before:', propsMap.getProps(obj));
 * // {isCoalescing: "weakMap version"}
 *
 * propsMap.setProps(obj, {isCoalescing: true});
 * console.log('obj after:', obj);
 * // {foo: "bar", isCoalescing: "weakMap version"}
 * console.log('props after:', propsMap.getProps(obj));
 * // {isCoalescing: "true"}
 * */
function createPropertiesWeakMap(getDefaults) {
    const propertyMap = new WeakMap();
    return {
        getProps: getProperties,
        setProps: setProperties,
    };
    function getProperties(ctx) {
        const defaults = getDefaults(ctx);
        const propertiesPresent = propertyMap.get(ctx);
        let properties;
        if (propertiesPresent !== undefined) {
            properties = propertiesPresent;
        }
        else {
            properties = {};
            Object.entries(defaults).forEach(([prop, value]) => {
                if (hasKey(ctx, prop)) {
                    properties[prop] = ctx[prop];
                }
                else {
                    properties[prop] = value;
                }
            });
            propertyMap.set(ctx, properties);
        }
        return properties;
    }
    function setProperties(ctx, props) {
        const properties = getProperties(ctx);
        Object.entries(props).forEach(([prop, value]) => {
            properties[prop] = value;
        });
        propertyMap.set(ctx, properties);
        return properties;
    }
}
const ɵ0 = (ctx) => ({
    numCoalescingSubscribers: 0,
});
const coalescingContextPropertiesMap = createPropertiesWeakMap(ɵ0);
/**
 * @describe createCoalesceManager
 *
 * returns a
 * Maintains a weak map of component references ans flags
 * them if the coalescing process is already started for them.
 *
 * Used in render aware internally.
 */
function createCoalesceManager() {
    return {
        remove: removeWork,
        add: addWork,
        isCoalescing,
    };
    // Increments the number of subscriptions in a scope e.g. a class instance
    function removeWork(scope) {
        const numCoalescingSubscribers = coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers -
            1;
        coalescingContextPropertiesMap.setProps(scope, {
            numCoalescingSubscribers: numCoalescingSubscribers >= 0 ? numCoalescingSubscribers : 0,
        });
    }
    // Decrements the number of subscriptions in a scope e.g. a class instance
    function addWork(scope) {
        const numCoalescingSubscribers = coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers +
            1;
        coalescingContextPropertiesMap.setProps(scope, {
            numCoalescingSubscribers,
        });
    }
    // Checks if anybody else is already coalescing atm
    function isCoalescing(scope) {
        return (coalescingContextPropertiesMap.getProps(scope).numCoalescingSubscribers >
            0);
    }
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29hbGVzY2luZ01hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL2Nkay9jb2FsZXNjaW5nL3NyYy9saWIvY29hbGVzY2luZ01hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBVUEsTUFBTSxDQUFDLE1BQU0saUJBQWlCLEdBQXNCLHFCQUFxQixFQUFFLENBQUM7QUFHNUUsU0FBUyxNQUFNLENBQUksR0FBTSxFQUFFLFFBQWtCO0lBQzNDLE9BQU8sR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksQ0FBQztBQUMvQixDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0E0Qks7QUFDTCxTQUFTLHVCQUF1QixDQUc5QixXQUF3QjtJQUV4QixNQUFNLFdBQVcsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO0lBRXhDLE9BQU87UUFDTCxRQUFRLEVBQUUsYUFBYTtRQUN2QixRQUFRLEVBQUUsYUFBYTtLQUN4QixDQUFDO0lBRUYsU0FBUyxhQUFhLENBQUMsR0FBTTtRQUMzQixNQUFNLFFBQVEsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEMsTUFBTSxpQkFBaUIsR0FBa0IsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM5RCxJQUFJLFVBQWEsQ0FBQztRQUVsQixJQUFJLGlCQUFpQixLQUFLLFNBQVMsRUFBRTtZQUNuQyxVQUFVLEdBQUcsaUJBQXNCLENBQUM7U0FDckM7YUFBTTtZQUNMLFVBQVUsR0FBRyxFQUFPLENBQUM7WUFFcEIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQWUsQ0FBQyxPQUFPLENBQzdDLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUF5QixFQUFRLEVBQUU7Z0JBQzlDLElBQUksTUFBTSxDQUFDLEdBQVEsRUFBRSxJQUFJLENBQUMsRUFBRTtvQkFDMUIsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFJLEdBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDckM7cUJBQU07b0JBQ0wsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQztpQkFDMUI7WUFDSCxDQUFDLENBQ0YsQ0FBQztZQUVGLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1NBQ2xDO1FBQ0QsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQztJQUVELFNBQVMsYUFBYSxDQUFDLEdBQU0sRUFBRSxLQUFpQjtRQUM5QyxNQUFNLFVBQVUsR0FBTSxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQWlCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUMvRCxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO1FBQzNCLENBQUMsQ0FBQyxDQUFDO1FBQ0gsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDakMsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQztBQUNILENBQUM7V0FLQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNWLHdCQUF3QixFQUFFLENBQUM7Q0FDNUIsQ0FBQztBQUxGLE1BQU0sOEJBQThCLEdBQUcsdUJBQXVCLElBSzNELENBQUM7QUFDSjs7Ozs7Ozs7R0FRRztBQUNILFNBQVMscUJBQXFCO0lBQzVCLE9BQU87UUFDTCxNQUFNLEVBQUUsVUFBVTtRQUNsQixHQUFHLEVBQUUsT0FBTztRQUNaLFlBQVk7S0FDYixDQUFDO0lBRUYsMEVBQTBFO0lBQzFFLFNBQVMsVUFBVSxDQUFDLEtBQThCO1FBQ2hELE1BQU0sd0JBQXdCLEdBQzVCLDhCQUE4QixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyx3QkFBd0I7WUFDdkUsQ0FBQyxDQUFDO1FBQ0osOEJBQThCLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRTtZQUM3Qyx3QkFBd0IsRUFDdEIsd0JBQXdCLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMvRCxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsMEVBQTBFO0lBQzFFLFNBQVMsT0FBTyxDQUFDLEtBQThCO1FBQzdDLE1BQU0sd0JBQXdCLEdBQzVCLDhCQUE4QixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyx3QkFBd0I7WUFDdkUsQ0FBQyxDQUFDO1FBQ0osOEJBQThCLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRTtZQUM3Qyx3QkFBd0I7U0FDekIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELG1EQUFtRDtJQUNuRCxTQUFTLFlBQVksQ0FBQyxLQUE4QjtRQUNsRCxPQUFPLENBQ0wsOEJBQThCLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLHdCQUF3QjtZQUN2RSxDQUFDLENBQ0YsQ0FBQztJQUNKLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW50ZXJmYWNlIENvYWxlc2NpbmdDb250ZXh0UHJvcHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XHJcbiAgbnVtQ29hbGVzY2luZ1N1YnNjcmliZXJzOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29hbGVzY2luZ01hbmFnZXIge1xyXG4gIHJlbW92ZTogKHNjb3BlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgPT4gdm9pZDtcclxuICBhZGQ6IChzY29wZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pID0+IHZvaWQ7XHJcbiAgaXNDb2FsZXNjaW5nOiAoc2NvcGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSA9PiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY29hbGVzY2luZ01hbmFnZXI6IENvYWxlc2NpbmdNYW5hZ2VyID0gY3JlYXRlQ29hbGVzY2VNYW5hZ2VyKCk7XHJcbnR5cGUgS2V5T2Y8Tz4gPSBrZXlvZiBPO1xyXG50eXBlIFZhbHVlT2Y8Tz4gPSBPW2tleW9mIE9dO1xyXG5mdW5jdGlvbiBoYXNLZXk8Tz4oY3R4OiBPLCBwcm9wZXJ0eTogS2V5T2Y8Tz4pOiBjdHggaXMgTyB7XHJcbiAgcmV0dXJuIGN0eFtwcm9wZXJ0eV0gIT0gbnVsbDtcclxufVxyXG4vKlxyXG4gKiBjcmVhdGVQcm9wZXJ0aWVzV2Vha01hcFxyXG4gKlxyXG4gKiBAcGFyYW0gZ2V0RGVmYXVsdHM6IChvOiBPKSA9PiBQXHJcbiAqIEV4YW1wbGU6XHJcbiAqXHJcbiAqIGV4cG9ydCBpbnRlcmZhY2UgUHJvcGVydGllcyB7XHJcbiAqICAgaXNDb2FsZXNjaW5nOiBib29sZWFuO1xyXG4gKiB9XHJcbiAqXHJcbiAqIGNvbnN0IG9iajogb2JqZWN0ID0ge1xyXG4gKiAgIGZvbzogJ2JhcicsXHJcbiAqICAgaXNDb2FsZXNjaW5nOiAnd2Vha01hcCB2ZXJzaW9uJ1xyXG4gKiB9O1xyXG4gKlxyXG4gKiBjb25zdCBnZXREZWZhdWx0cyA9IChjdHg6IG9iamVjdCk6IFByb3BlcnRpZXMgPT4gKHtpc0NvYWxlc2Npbmc6IGZhbHNlfSk7XHJcbiAqIGNvbnN0IHByb3BzTWFwID0gY3JlYXRlUHJvcGVydGllc1dlYWtNYXA8b2JqZWN0LCBQcm9wZXJ0aWVzPihnZXREZWZhdWx0cyk7XHJcbiAqXHJcbiAqIGNvbnNvbGUubG9nKCdvYmogYmVmb3JlOicsIG9iaik7XHJcbiAqIC8vIHtmb286IFwiYmFyXCIsIGlzQ29hbGVzY2luZzogXCJ3ZWFrTWFwIHZlcnNpb25cIn1cclxuICogY29uc29sZS5sb2coJ3Byb3BzIGJlZm9yZTonLCBwcm9wc01hcC5nZXRQcm9wcyhvYmopKTtcclxuICogLy8ge2lzQ29hbGVzY2luZzogXCJ3ZWFrTWFwIHZlcnNpb25cIn1cclxuICpcclxuICogcHJvcHNNYXAuc2V0UHJvcHMob2JqLCB7aXNDb2FsZXNjaW5nOiB0cnVlfSk7XHJcbiAqIGNvbnNvbGUubG9nKCdvYmogYWZ0ZXI6Jywgb2JqKTtcclxuICogLy8ge2ZvbzogXCJiYXJcIiwgaXNDb2FsZXNjaW5nOiBcIndlYWtNYXAgdmVyc2lvblwifVxyXG4gKiBjb25zb2xlLmxvZygncHJvcHMgYWZ0ZXI6JywgcHJvcHNNYXAuZ2V0UHJvcHMob2JqKSk7XHJcbiAqIC8vIHtpc0NvYWxlc2Npbmc6IFwidHJ1ZVwifVxyXG4gKiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVQcm9wZXJ0aWVzV2Vha01hcDxcclxuICBPIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXHJcbiAgUCBleHRlbmRzIE9cclxuPihnZXREZWZhdWx0czogKG86IE8pID0+IFApIHtcclxuICB0eXBlIEsgPSBLZXlPZjxQPjtcclxuICBjb25zdCBwcm9wZXJ0eU1hcCA9IG5ldyBXZWFrTWFwPE8sIFA+KCk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBnZXRQcm9wczogZ2V0UHJvcGVydGllcyxcclxuICAgIHNldFByb3BzOiBzZXRQcm9wZXJ0aWVzLFxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGdldFByb3BlcnRpZXMoY3R4OiBPKTogUCB7XHJcbiAgICBjb25zdCBkZWZhdWx0cyA9IGdldERlZmF1bHRzKGN0eCk7XHJcbiAgICBjb25zdCBwcm9wZXJ0aWVzUHJlc2VudDogUCB8IHVuZGVmaW5lZCA9IHByb3BlcnR5TWFwLmdldChjdHgpO1xyXG4gICAgbGV0IHByb3BlcnRpZXM6IFA7XHJcblxyXG4gICAgaWYgKHByb3BlcnRpZXNQcmVzZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXNQcmVzZW50IGFzIFA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcm9wZXJ0aWVzID0ge30gYXMgUDtcclxuXHJcbiAgICAgIChPYmplY3QuZW50cmllcyhkZWZhdWx0cykgYXMgdW5rbm93bltdKS5mb3JFYWNoKFxyXG4gICAgICAgIChbcHJvcCwgdmFsdWVdOiBbS2V5T2Y8UD4sIFZhbHVlT2Y8UD5dKTogdm9pZCA9PiB7XHJcbiAgICAgICAgICBpZiAoaGFzS2V5KGN0eCBhcyBQLCBwcm9wKSkge1xyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzW3Byb3BdID0gKGN0eCBhcyBQKVtwcm9wXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXNbcHJvcF0gPSB2YWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBwcm9wZXJ0eU1hcC5zZXQoY3R4LCBwcm9wZXJ0aWVzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0UHJvcGVydGllcyhjdHg6IE8sIHByb3BzOiBQYXJ0aWFsPFA+KTogUCB7XHJcbiAgICBjb25zdCBwcm9wZXJ0aWVzOiBQID0gZ2V0UHJvcGVydGllcyhjdHgpO1xyXG4gICAgKE9iamVjdC5lbnRyaWVzKHByb3BzKSBhcyBbSywgUFtLXV1bXSkuZm9yRWFjaCgoW3Byb3AsIHZhbHVlXSkgPT4ge1xyXG4gICAgICBwcm9wZXJ0aWVzW3Byb3BdID0gdmFsdWU7XHJcbiAgICB9KTtcclxuICAgIHByb3BlcnR5TWFwLnNldChjdHgsIHByb3BlcnRpZXMpO1xyXG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBjb2FsZXNjaW5nQ29udGV4dFByb3BlcnRpZXNNYXAgPSBjcmVhdGVQcm9wZXJ0aWVzV2Vha01hcDxcclxuICBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcclxuICBDb2FsZXNjaW5nQ29udGV4dFByb3BzXHJcbj4oKGN0eCkgPT4gKHtcclxuICBudW1Db2FsZXNjaW5nU3Vic2NyaWJlcnM6IDAsXHJcbn0pKTtcclxuLyoqXHJcbiAqIEBkZXNjcmliZSBjcmVhdGVDb2FsZXNjZU1hbmFnZXJcclxuICpcclxuICogcmV0dXJucyBhXHJcbiAqIE1haW50YWlucyBhIHdlYWsgbWFwIG9mIGNvbXBvbmVudCByZWZlcmVuY2VzIGFucyBmbGFnc1xyXG4gKiB0aGVtIGlmIHRoZSBjb2FsZXNjaW5nIHByb2Nlc3MgaXMgYWxyZWFkeSBzdGFydGVkIGZvciB0aGVtLlxyXG4gKlxyXG4gKiBVc2VkIGluIHJlbmRlciBhd2FyZSBpbnRlcm5hbGx5LlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQ29hbGVzY2VNYW5hZ2VyKCk6IENvYWxlc2NpbmdNYW5hZ2VyIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVtb3ZlOiByZW1vdmVXb3JrLFxyXG4gICAgYWRkOiBhZGRXb3JrLFxyXG4gICAgaXNDb2FsZXNjaW5nLFxyXG4gIH07XHJcblxyXG4gIC8vIEluY3JlbWVudHMgdGhlIG51bWJlciBvZiBzdWJzY3JpcHRpb25zIGluIGEgc2NvcGUgZS5nLiBhIGNsYXNzIGluc3RhbmNlXHJcbiAgZnVuY3Rpb24gcmVtb3ZlV29yayhzY29wZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB2b2lkIHtcclxuICAgIGNvbnN0IG51bUNvYWxlc2NpbmdTdWJzY3JpYmVycyA9XHJcbiAgICAgIGNvYWxlc2NpbmdDb250ZXh0UHJvcGVydGllc01hcC5nZXRQcm9wcyhzY29wZSkubnVtQ29hbGVzY2luZ1N1YnNjcmliZXJzIC1cclxuICAgICAgMTtcclxuICAgIGNvYWxlc2NpbmdDb250ZXh0UHJvcGVydGllc01hcC5zZXRQcm9wcyhzY29wZSwge1xyXG4gICAgICBudW1Db2FsZXNjaW5nU3Vic2NyaWJlcnM6XHJcbiAgICAgICAgbnVtQ29hbGVzY2luZ1N1YnNjcmliZXJzID49IDAgPyBudW1Db2FsZXNjaW5nU3Vic2NyaWJlcnMgOiAwLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBEZWNyZW1lbnRzIHRoZSBudW1iZXIgb2Ygc3Vic2NyaXB0aW9ucyBpbiBhIHNjb3BlIGUuZy4gYSBjbGFzcyBpbnN0YW5jZVxyXG4gIGZ1bmN0aW9uIGFkZFdvcmsoc2NvcGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdm9pZCB7XHJcbiAgICBjb25zdCBudW1Db2FsZXNjaW5nU3Vic2NyaWJlcnMgPVxyXG4gICAgICBjb2FsZXNjaW5nQ29udGV4dFByb3BlcnRpZXNNYXAuZ2V0UHJvcHMoc2NvcGUpLm51bUNvYWxlc2NpbmdTdWJzY3JpYmVycyArXHJcbiAgICAgIDE7XHJcbiAgICBjb2FsZXNjaW5nQ29udGV4dFByb3BlcnRpZXNNYXAuc2V0UHJvcHMoc2NvcGUsIHtcclxuICAgICAgbnVtQ29hbGVzY2luZ1N1YnNjcmliZXJzLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBDaGVja3MgaWYgYW55Ym9keSBlbHNlIGlzIGFscmVhZHkgY29hbGVzY2luZyBhdG1cclxuICBmdW5jdGlvbiBpc0NvYWxlc2Npbmcoc2NvcGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBjb2FsZXNjaW5nQ29udGV4dFByb3BlcnRpZXNNYXAuZ2V0UHJvcHMoc2NvcGUpLm51bUNvYWxlc2NpbmdTdWJzY3JpYmVycyA+XHJcbiAgICAgIDBcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiJdfQ==