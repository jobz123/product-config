import { Observable, Subscription, } from 'rxjs';
import { coalescingManager } from './coalescingManager';
/**
 * @description
 * Limits the number of synchronous emitted a value from the source Observable to
 * one emitted value per
 *   durationSelector e.g. [`AnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame), then repeats
 * this process for every tick of the browsers event loop.
 *
 * The coalesce operator is based on the [throttle](https://rxjs-dev.firebaseapp.com/api/operators/throttle) operator.
 * In addition to that is provides emitted values for the trailing end only, as well as maintaining a context to scope
 *   coalescing.
 *
 * @param {function(value: T): Observable} durationSelector - A function
 * that receives a value from the source Observable, for computing the silencing
 * duration for each source value, returned as an Observable or a Promise.
 * It defaults to `requestAnimationFrame` as durationSelector.
 * @param scope
 * Defaults to `{ leading: false, trailing: true }`. The default scoping is per subscriber.
 * @return {Observable<T>} An Observable that performs the coalesce operation to
 * limit the rate of emissions from the source.
 *
 * @usageNotes
 * Emit clicks at a rate of at most one click per second
 * ```typescript
 * import { fromEvent, animationFrames } from 'rxjs';
 * import { coalesce } from 'ngRx/component';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(coalesce(ev => animationFrames));
 * result.subscribe(x => console.log(x));
 * ```
 */
export function coalesceWith(durationSelector, scope) {
    const _scope = scope || {};
    return (source) => {
        return new Observable((observer) => {
            const rootSubscription = new Subscription();
            rootSubscription.add(source.subscribe(createInnerObserver(observer, rootSubscription)));
            return rootSubscription;
        });
        function createInnerObserver(outerObserver, rootSubscription) {
            let actionSubscription;
            let latestValue;
            const tryEmitLatestValue = () => {
                if (actionSubscription) {
                    // We only decrement the number if it is greater than 0 (isCoalescing)
                    coalescingManager.remove(_scope);
                    if (!coalescingManager.isCoalescing(_scope)) {
                        outerObserver.next(latestValue);
                    }
                }
            };
            return {
                complete: () => {
                    tryEmitLatestValue();
                    outerObserver.complete();
                },
                error: (error) => outerObserver.error(error),
                next: (value) => {
                    latestValue = value;
                    if (!actionSubscription) {
                        // tslint:disable-next-line:no-unused-expression
                        coalescingManager.add(_scope);
                        actionSubscription = durationSelector.subscribe({
                            error: (error) => outerObserver.error(error),
                            next: () => {
                                tryEmitLatestValue();
                                actionSubscription === null || actionSubscription === void 0 ? void 0 : actionSubscription.unsubscribe();
                                actionSubscription = undefined;
                            },
                            complete: () => {
                                tryEmitLatestValue();
                                actionSubscription = undefined;
                            },
                        });
                        rootSubscription.add(new Subscription(() => {
                            tryEmitLatestValue();
                            actionSubscription === null || actionSubscription === void 0 ? void 0 : actionSubscription.unsubscribe();
                            actionSubscription = undefined;
                        }));
                    }
                },
            };
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29hbGVzY2VXaXRoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9jZGsvY29hbGVzY2luZy9zcmMvbGliL2NvYWxlc2NlV2l0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsVUFBVSxFQUdWLFlBQVksR0FFYixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXhEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E4Qkc7QUFDSCxNQUFNLFVBQVUsWUFBWSxDQUMxQixnQkFBcUMsRUFDckMsS0FBK0I7SUFFL0IsTUFBTSxNQUFNLEdBQUcsS0FBSyxJQUFJLEVBQUUsQ0FBQztJQUUzQixPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUU7UUFDaEIsT0FBTyxJQUFJLFVBQVUsQ0FBSSxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ3BDLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztZQUM1QyxnQkFBZ0IsQ0FBQyxHQUFHLENBQ2xCLE1BQU0sQ0FBQyxTQUFTLENBQUMsbUJBQW1CLENBQUMsUUFBUSxFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FDbEUsQ0FBQztZQUNGLE9BQU8sZ0JBQWdCLENBQUM7UUFDMUIsQ0FBQyxDQUFDLENBQUM7UUFFSCxTQUFTLG1CQUFtQixDQUMxQixhQUE0QixFQUM1QixnQkFBOEI7WUFFOUIsSUFBSSxrQkFBa0MsQ0FBQztZQUN2QyxJQUFJLFdBQTBCLENBQUM7WUFFL0IsTUFBTSxrQkFBa0IsR0FBRyxHQUFHLEVBQUU7Z0JBQzlCLElBQUksa0JBQWtCLEVBQUU7b0JBQ3RCLHNFQUFzRTtvQkFDdEUsaUJBQWlCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUNqQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFO3dCQUMzQyxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO3FCQUNqQztpQkFDRjtZQUNILENBQUMsQ0FBQztZQUNGLE9BQU87Z0JBQ0wsUUFBUSxFQUFFLEdBQUcsRUFBRTtvQkFDYixrQkFBa0IsRUFBRSxDQUFDO29CQUNyQixhQUFhLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQzNCLENBQUM7Z0JBQ0QsS0FBSyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztnQkFDNUMsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7b0JBQ2QsV0FBVyxHQUFHLEtBQUssQ0FBQztvQkFDcEIsSUFBSSxDQUFDLGtCQUFrQixFQUFFO3dCQUN2QixnREFBZ0Q7d0JBQ2hELGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDOUIsa0JBQWtCLEdBQUcsZ0JBQWdCLENBQUMsU0FBUyxDQUFDOzRCQUM5QyxLQUFLLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDOzRCQUM1QyxJQUFJLEVBQUUsR0FBRyxFQUFFO2dDQUNULGtCQUFrQixFQUFFLENBQUM7Z0NBQ3JCLGtCQUFrQixhQUFsQixrQkFBa0IsdUJBQWxCLGtCQUFrQixDQUFFLFdBQVcsRUFBRSxDQUFDO2dDQUNsQyxrQkFBa0IsR0FBRyxTQUFTLENBQUM7NEJBQ2pDLENBQUM7NEJBQ0QsUUFBUSxFQUFFLEdBQUcsRUFBRTtnQ0FDYixrQkFBa0IsRUFBRSxDQUFDO2dDQUNyQixrQkFBa0IsR0FBRyxTQUFTLENBQUM7NEJBQ2pDLENBQUM7eUJBQ0YsQ0FBQyxDQUFDO3dCQUNILGdCQUFnQixDQUFDLEdBQUcsQ0FDbEIsSUFBSSxZQUFZLENBQUMsR0FBRyxFQUFFOzRCQUNwQixrQkFBa0IsRUFBRSxDQUFDOzRCQUNyQixrQkFBa0IsYUFBbEIsa0JBQWtCLHVCQUFsQixrQkFBa0IsQ0FBRSxXQUFXLEVBQUUsQ0FBQzs0QkFDbEMsa0JBQWtCLEdBQUcsU0FBUyxDQUFDO3dCQUNqQyxDQUFDLENBQUMsQ0FDSCxDQUFDO3FCQUNIO2dCQUNILENBQUM7YUFDRixDQUFDO1FBQ0osQ0FBQztJQUNILENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbixcclxuICBPYnNlcnZhYmxlLFxyXG4gIE9ic2VydmVyLFxyXG4gIFN1YnNjcmliZXIsXHJcbiAgU3Vic2NyaXB0aW9uLFxyXG4gIFVuc3Vic2NyaWJhYmxlLFxyXG59IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBjb2FsZXNjaW5nTWFuYWdlciB9IGZyb20gJy4vY29hbGVzY2luZ01hbmFnZXInO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBMaW1pdHMgdGhlIG51bWJlciBvZiBzeW5jaHJvbm91cyBlbWl0dGVkIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgdG9cclxuICogb25lIGVtaXR0ZWQgdmFsdWUgcGVyXHJcbiAqICAgZHVyYXRpb25TZWxlY3RvciBlLmcuIFtgQW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksIHRoZW4gcmVwZWF0c1xyXG4gKiB0aGlzIHByb2Nlc3MgZm9yIGV2ZXJ5IHRpY2sgb2YgdGhlIGJyb3dzZXJzIGV2ZW50IGxvb3AuXHJcbiAqXHJcbiAqIFRoZSBjb2FsZXNjZSBvcGVyYXRvciBpcyBiYXNlZCBvbiB0aGUgW3Rocm90dGxlXShodHRwczovL3J4anMtZGV2LmZpcmViYXNlYXBwLmNvbS9hcGkvb3BlcmF0b3JzL3Rocm90dGxlKSBvcGVyYXRvci5cclxuICogSW4gYWRkaXRpb24gdG8gdGhhdCBpcyBwcm92aWRlcyBlbWl0dGVkIHZhbHVlcyBmb3IgdGhlIHRyYWlsaW5nIGVuZCBvbmx5LCBhcyB3ZWxsIGFzIG1haW50YWluaW5nIGEgY29udGV4dCB0byBzY29wZVxyXG4gKiAgIGNvYWxlc2NpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQpOiBPYnNlcnZhYmxlfSBkdXJhdGlvblNlbGVjdG9yIC0gQSBmdW5jdGlvblxyXG4gKiB0aGF0IHJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIGZvciBjb21wdXRpbmcgdGhlIHNpbGVuY2luZ1xyXG4gKiBkdXJhdGlvbiBmb3IgZWFjaCBzb3VyY2UgdmFsdWUsIHJldHVybmVkIGFzIGFuIE9ic2VydmFibGUgb3IgYSBQcm9taXNlLlxyXG4gKiBJdCBkZWZhdWx0cyB0byBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhcyBkdXJhdGlvblNlbGVjdG9yLlxyXG4gKiBAcGFyYW0gc2NvcGVcclxuICogRGVmYXVsdHMgdG8gYHsgbGVhZGluZzogZmFsc2UsIHRyYWlsaW5nOiB0cnVlIH1gLiBUaGUgZGVmYXVsdCBzY29waW5nIGlzIHBlciBzdWJzY3JpYmVyLlxyXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgdGhlIGNvYWxlc2NlIG9wZXJhdGlvbiB0b1xyXG4gKiBsaW1pdCB0aGUgcmF0ZSBvZiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlLlxyXG4gKlxyXG4gKiBAdXNhZ2VOb3Rlc1xyXG4gKiBFbWl0IGNsaWNrcyBhdCBhIHJhdGUgb2YgYXQgbW9zdCBvbmUgY2xpY2sgcGVyIHNlY29uZFxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7IGZyb21FdmVudCwgYW5pbWF0aW9uRnJhbWVzIH0gZnJvbSAncnhqcyc7XHJcbiAqIGltcG9ydCB7IGNvYWxlc2NlIH0gZnJvbSAnbmdSeC9jb21wb25lbnQnO1xyXG4gKlxyXG4gKiBjb25zdCBjbGlja3MgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xyXG4gKiBjb25zdCByZXN1bHQgPSBjbGlja3MucGlwZShjb2FsZXNjZShldiA9PiBhbmltYXRpb25GcmFtZXMpKTtcclxuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29hbGVzY2VXaXRoPFQ+KFxyXG4gIGR1cmF0aW9uU2VsZWN0b3I6IE9ic2VydmFibGU8dW5rbm93bj4sXHJcbiAgc2NvcGU/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxyXG4pOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD4ge1xyXG4gIGNvbnN0IF9zY29wZSA9IHNjb3BlIHx8IHt9O1xyXG5cclxuICByZXR1cm4gKHNvdXJjZSkgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlPFQ+KChvYnNlcnZlcikgPT4ge1xyXG4gICAgICBjb25zdCByb290U3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xyXG4gICAgICByb290U3Vic2NyaXB0aW9uLmFkZChcclxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKGNyZWF0ZUlubmVyT2JzZXJ2ZXIob2JzZXJ2ZXIsIHJvb3RTdWJzY3JpcHRpb24pKVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcm9vdFN1YnNjcmlwdGlvbjtcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUlubmVyT2JzZXJ2ZXIoXHJcbiAgICAgIG91dGVyT2JzZXJ2ZXI6IFN1YnNjcmliZXI8VD4sXHJcbiAgICAgIHJvb3RTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblxyXG4gICAgKTogT2JzZXJ2ZXI8VD4ge1xyXG4gICAgICBsZXQgYWN0aW9uU3Vic2NyaXB0aW9uOiBVbnN1YnNjcmliYWJsZTtcclxuICAgICAgbGV0IGxhdGVzdFZhbHVlOiBUIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgY29uc3QgdHJ5RW1pdExhdGVzdFZhbHVlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChhY3Rpb25TdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgIC8vIFdlIG9ubHkgZGVjcmVtZW50IHRoZSBudW1iZXIgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDAgKGlzQ29hbGVzY2luZylcclxuICAgICAgICAgIGNvYWxlc2NpbmdNYW5hZ2VyLnJlbW92ZShfc2NvcGUpO1xyXG4gICAgICAgICAgaWYgKCFjb2FsZXNjaW5nTWFuYWdlci5pc0NvYWxlc2NpbmcoX3Njb3BlKSkge1xyXG4gICAgICAgICAgICBvdXRlck9ic2VydmVyLm5leHQobGF0ZXN0VmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgdHJ5RW1pdExhdGVzdFZhbHVlKCk7XHJcbiAgICAgICAgICBvdXRlck9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcjogKGVycm9yKSA9PiBvdXRlck9ic2VydmVyLmVycm9yKGVycm9yKSxcclxuICAgICAgICBuZXh0OiAodmFsdWUpID0+IHtcclxuICAgICAgICAgIGxhdGVzdFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICBpZiAoIWFjdGlvblN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cclxuICAgICAgICAgICAgY29hbGVzY2luZ01hbmFnZXIuYWRkKF9zY29wZSk7XHJcbiAgICAgICAgICAgIGFjdGlvblN1YnNjcmlwdGlvbiA9IGR1cmF0aW9uU2VsZWN0b3Iuc3Vic2NyaWJlKHtcclxuICAgICAgICAgICAgICBlcnJvcjogKGVycm9yKSA9PiBvdXRlck9ic2VydmVyLmVycm9yKGVycm9yKSxcclxuICAgICAgICAgICAgICBuZXh0OiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnlFbWl0TGF0ZXN0VmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIGFjdGlvblN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgICAgIGFjdGlvblN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnlFbWl0TGF0ZXN0VmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIGFjdGlvblN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcm9vdFN1YnNjcmlwdGlvbi5hZGQoXHJcbiAgICAgICAgICAgICAgbmV3IFN1YnNjcmlwdGlvbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnlFbWl0TGF0ZXN0VmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIGFjdGlvblN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgICAgIGFjdGlvblN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG4iXX0=