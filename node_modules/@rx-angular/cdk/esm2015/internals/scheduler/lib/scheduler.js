// see https://raw.githubusercontent.com/facebook/react/master/packages/scheduler/src/forks/SchedulerDOM.js
import { ɵglobal } from '@angular/core';
import { enableIsInputPending } from './schedulerFeatureFlags';
import { peek, pop, push } from './schedulerMinHeap';
let getCurrentTime;
const hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';
if (hasPerformanceNow) {
    const localPerformance = performance;
    getCurrentTime = () => localPerformance.now();
}
else {
    const localDate = Date;
    const initialTime = localDate.now();
    getCurrentTime = () => localDate.now() - initialTime;
}
// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
const maxSigned31BitInt = 1073741823;
// Times out immediately
const IMMEDIATE_PRIORITY_TIMEOUT = -1;
// Eventually times out
const USER_BLOCKING_PRIORITY_TIMEOUT = 250;
const NORMAL_PRIORITY_TIMEOUT = 5000;
const LOW_PRIORITY_TIMEOUT = 10000;
// Never times out
const IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
// Tasks are stored on a min heap
const taskQueue = [];
const timerQueue = [];
// Incrementing id counter. Used to maintain insertion order.
let taskIdCounter = 1;
// Pausing the scheduler is useful for debugging.
let isSchedulerPaused = false;
let currentTask = null;
let currentPriorityLevel = 3 /* NormalPriority */;
// This is set while performing work, to prevent re-entrancy.
let isPerformingWork = false;
let isHostCallbackScheduled = false;
let isHostTimeoutScheduled = false;
// Capture local references to native APIs, in case a polyfill overrides them.
const setTimeout = ɵglobal.setTimeout;
const clearTimeout = ɵglobal.clearTimeout;
const setImmediate = ɵglobal.setImmediate; // IE and Node.js + jsdom
const messageChannel = ɵglobal.MessageChannel;
function advanceTimers(currentTime) {
    // Check for tasks that are no longer delayed and add them to the queue.
    let timer = peek(timerQueue);
    while (timer !== null) {
        if (timer.callback === null) {
            // Timer was cancelled.
            pop(timerQueue);
        }
        else if (timer.startTime <= currentTime) {
            // Timer fired. Transfer to the task queue.
            pop(timerQueue);
            timer.sortIndex = timer.expirationTime;
            push(taskQueue, timer);
        }
        else {
            // Remaining timers are pending.
            return;
        }
        timer = peek(timerQueue);
    }
}
function handleTimeout(currentTime) {
    isHostTimeoutScheduled = false;
    advanceTimers(currentTime);
    if (!isHostCallbackScheduled) {
        if (peek(taskQueue) !== null) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
        }
        else {
            const firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
        }
    }
}
function flushWork(hasTimeRemaining, initialTime) {
    // We'll need a host callback the next time work is scheduled.
    isHostCallbackScheduled = false;
    if (isHostTimeoutScheduled) {
        // We scheduled a timeout but it's no longer needed. Cancel it.
        isHostTimeoutScheduled = false;
        cancelHostTimeout();
    }
    isPerformingWork = true;
    const previousPriorityLevel = currentPriorityLevel;
    try {
        return workLoop(hasTimeRemaining, initialTime);
    }
    finally {
        currentTask = null;
        currentPriorityLevel = previousPriorityLevel;
        isPerformingWork = false;
    }
}
function workLoop(hasTimeRemaining, initialTime) {
    let currentTime = initialTime;
    advanceTimers(currentTime);
    currentTask = peek(taskQueue);
    while (currentTask !== null && !isSchedulerPaused) {
        if (currentTask.expirationTime > currentTime &&
            (!hasTimeRemaining || shouldYieldToHost())) {
            // This currentTask hasn't expired, and we've reached the deadline.
            break;
        }
        const callback = currentTask.callback;
        if (typeof callback === 'function') {
            currentTask.callback = null;
            currentPriorityLevel = currentTask.priorityLevel;
            const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
            const continuationCallback = callback(didUserCallbackTimeout);
            currentTime = getCurrentTime();
            if (typeof continuationCallback === 'function') {
                currentTask.callback = continuationCallback;
            }
            else {
                if (currentTask === peek(taskQueue)) {
                    pop(taskQueue);
                }
            }
            advanceTimers(currentTime);
        }
        else {
            pop(taskQueue);
        }
        currentTask = peek(taskQueue);
    }
    // Return whether there's additional work
    if (currentTask !== null) {
        return true;
    }
    else {
        const firstTimer = peek(timerQueue);
        if (firstTimer !== null) {
            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
        return false;
    }
}
function runWithPriority(priorityLevel, eventHandler) {
    switch (priorityLevel) {
        case 1 /* ImmediatePriority */:
        case 2 /* UserBlockingPriority */:
        case 3 /* NormalPriority */:
        case 4 /* LowPriority */:
        case 5 /* IdlePriority */:
            break;
        default:
            priorityLevel = 3 /* NormalPriority */;
    }
    const previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;
    try {
        return eventHandler();
    }
    finally {
        currentPriorityLevel = previousPriorityLevel;
    }
}
function next(eventHandler) {
    let priorityLevel;
    switch (currentPriorityLevel) {
        case 1 /* ImmediatePriority */:
        case 2 /* UserBlockingPriority */:
        case 3 /* NormalPriority */:
            // Shift down to normal priority
            priorityLevel = 3 /* NormalPriority */;
            break;
        default:
            // Anything lower than normal priority should remain at the current level.
            priorityLevel = currentPriorityLevel;
            break;
    }
    const previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;
    try {
        return eventHandler();
    }
    finally {
        currentPriorityLevel = previousPriorityLevel;
    }
}
function wrapCallback(callback) {
    const parentPriorityLevel = currentPriorityLevel;
    return () => {
        // This is a fork of runWithPriority, inlined for performance.
        const previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
            // eslint-disable-next-line prefer-rest-params
            return callback.apply(this, arguments);
        }
        finally {
            currentPriorityLevel = previousPriorityLevel;
        }
    };
}
function scheduleCallback(priorityLevel, callback, options) {
    const currentTime = getCurrentTime();
    let startTime;
    if (typeof options === 'object' && options !== null) {
        const delay = options.delay;
        if (typeof delay === 'number' && delay > 0) {
            startTime = currentTime + delay;
        }
        else {
            startTime = currentTime;
        }
    }
    else {
        startTime = currentTime;
    }
    let timeout;
    switch (priorityLevel) {
        case 1 /* ImmediatePriority */:
            timeout = IMMEDIATE_PRIORITY_TIMEOUT;
            break;
        case 2 /* UserBlockingPriority */:
            timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
            break;
        case 5 /* IdlePriority */:
            timeout = IDLE_PRIORITY_TIMEOUT;
            break;
        case 4 /* LowPriority */:
            timeout = LOW_PRIORITY_TIMEOUT;
            break;
        case 3 /* NormalPriority */:
        default:
            timeout = NORMAL_PRIORITY_TIMEOUT;
            break;
    }
    const expirationTime = startTime + timeout;
    const newTask = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime,
        expirationTime,
        sortIndex: -1,
    };
    if (startTime > currentTime) {
        // This is a delayed task.
        newTask.sortIndex = startTime;
        push(timerQueue, newTask);
        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
            // All tasks are delayed, and this is the task with the earliest delay.
            if (isHostTimeoutScheduled) {
                // Cancel an existing timeout.
                cancelHostTimeout();
            }
            else {
                isHostTimeoutScheduled = true;
            }
            // Schedule a timeout.
            requestHostTimeout(handleTimeout, startTime - currentTime);
        }
    }
    else {
        newTask.sortIndex = expirationTime;
        push(taskQueue, newTask);
        // Schedule a host callback, if needed. If we're already performing work,
        // wait until the next time we yield.
        if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
        }
    }
    return newTask;
}
function pauseExecution() {
    isSchedulerPaused = true;
}
function continueExecution() {
    isSchedulerPaused = false;
    if (!isHostCallbackScheduled && !isPerformingWork) {
        isHostCallbackScheduled = true;
        requestHostCallback(flushWork);
    }
}
function getFirstCallbackNode() {
    return peek(taskQueue);
}
function cancelCallback(task) {
    // Null out the callback to indicate the task has been canceled. (Can't
    // remove from the queue because you can't remove arbitrary nodes from an
    // array based heap, only the first one.)
    task.callback = null;
}
function getCurrentPriorityLevel() {
    return currentPriorityLevel;
}
let isMessageLoopRunning = false;
let scheduledHostCallback = null;
let taskTimeoutID = -1;
// Scheduler periodically yields in case there is other work on the main
// thread, like user events. By default, it yields multiple times per frame.
// It does not attempt to align with frame boundaries, since most tasks don't
// need to be frame aligned; for those that do, use requestAnimationFrame.
let yieldInterval = 16;
let deadline = 0;
// TODO: Make this configurable
// TODO: Adjust this based on priority?
const maxYieldInterval = 300;
let needsPaint = false;
function shouldYieldToHost() {
    if (enableIsInputPending &&
        navigator !== undefined &&
        navigator.scheduling !== undefined &&
        navigator.scheduling.isInputPending !== undefined) {
        const scheduling = navigator.scheduling;
        const currentTime = getCurrentTime();
        if (currentTime >= deadline) {
            // There's no time left. We may want to yield control of the main
            // thread, so the browser can perform high priority tasks. The main ones
            // are painting and user input. If there's a pending paint or a pending
            // input, then we should yield. But if there's neither, then we can
            // yield less often while remaining responsive. We'll eventually yield
            // regardless, since there could be a pending paint that wasn't
            // accompanied by a call to `requestPaint`, or other main thread tasks
            // like network events.
            if (needsPaint || scheduling.isInputPending()) {
                // There is either a pending paint or a pending input.
                return true;
            }
            // There's no pending input. Only yield if we've reached the max
            // yield interval.
            return currentTime >= maxYieldInterval;
        }
        else {
            // There's still time left in the frame.
            return false;
        }
    }
    else {
        // `isInputPending` is not available. Since we have no way of knowing if
        // there's pending input, always yield at the end of the frame.
        return getCurrentTime() >= deadline;
    }
}
function requestPaint() {
    if (enableIsInputPending &&
        navigator !== undefined &&
        navigator.scheduling !== undefined &&
        navigator.scheduling.isInputPending !== undefined) {
        needsPaint = true;
    }
    // Since we yield every frame regardless, `requestPaint` has no effect.
}
function forceFrameRate(fps) {
    if (fps < 0 || fps > 125) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            console.error('forceFrameRate takes a positive int between 0 and 125, ' +
                'forcing frame rates higher than 125 fps is not supported');
        }
        return;
    }
    if (fps > 0) {
        yieldInterval = Math.floor(1000 / fps);
    }
    else {
        // reset the framerate
        yieldInterval = 5;
    }
}
const performWorkUntilDeadline = () => {
    if (scheduledHostCallback !== null) {
        const currentTime = getCurrentTime();
        // Yield after `yieldInterval` ms, regardless of where we are in the vsync
        // cycle. This means there's always time remaining at the beginning of
        // the message event.
        deadline = currentTime + yieldInterval;
        const hasTimeRemaining = true;
        // If a scheduler task throws, exit the current browser task so the
        // error can be observed.
        //
        // Intentionally not using a try-catch, since that makes some debugging
        // techniques harder. Instead, if `scheduledHostCallback` errors, then
        // `hasMoreWork` will remain true, and we'll continue the work loop.
        let hasMoreWork = true;
        try {
            hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
        }
        finally {
            if (hasMoreWork) {
                // If there's more work, schedule the next message event at the end
                // of the preceding one.
                schedulePerformWorkUntilDeadline();
            }
            else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
            }
        }
    }
    else {
        isMessageLoopRunning = false;
    }
    // Yielding to the browser will give it a chance to paint, so we can
    // reset this.
    needsPaint = false;
};
const ɵ0 = performWorkUntilDeadline;
let schedulePerformWorkUntilDeadline;
if (typeof setImmediate === 'function') {
    // Node.js and old IE.
    // There's a few reasons for why we prefer setImmediate.
    //
    // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.
    // (Even though this is a DOM fork of the Scheduler, you could get here
    // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)
    // https://github.com/facebook/react/issues/20756
    //
    // But also, it runs earlier which is the semantic we want.
    // If other browsers ever implement it, it's better to use it.
    // Although both of these would be inferior to native scheduling.
    schedulePerformWorkUntilDeadline = () => {
        setImmediate(performWorkUntilDeadline);
    };
}
else if (typeof messageChannel !== 'undefined') {
    const channel = new messageChannel();
    const port = channel.port2;
    channel.port1.onmessage = performWorkUntilDeadline;
    schedulePerformWorkUntilDeadline = () => {
        port.postMessage(null);
    };
}
else {
    // We should only fallback here in non-browser environments.
    schedulePerformWorkUntilDeadline = () => {
        setTimeout(performWorkUntilDeadline, 0);
    };
}
function requestHostCallback(callback) {
    scheduledHostCallback = callback;
    if (!isMessageLoopRunning) {
        isMessageLoopRunning = true;
        schedulePerformWorkUntilDeadline();
    }
}
function requestHostTimeout(callback, ms) {
    taskTimeoutID = setTimeout(() => {
        callback(getCurrentTime());
    }, ms);
}
function cancelHostTimeout() {
    clearTimeout(taskTimeoutID);
    taskTimeoutID = -1;
}
const _requestPaint = requestPaint;
export { runWithPriority, next, scheduleCallback, cancelCallback, wrapCallback, getCurrentPriorityLevel, shouldYieldToHost as shouldYield, _requestPaint as requestPaint, continueExecution, pauseExecution, getFirstCallbackNode, getCurrentTime as now, forceFrameRate as forceFrameRate, };
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZWR1bGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9jZGsvaW50ZXJuYWxzL3NjaGVkdWxlci9zcmMvbGliL3NjaGVkdWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyR0FBMkc7QUFFM0csT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4QyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQXNCLE1BQU0sb0JBQW9CLENBQUM7QUFVekUsSUFBSSxjQUE0QixDQUFDO0FBQ2pDLE1BQU0saUJBQWlCLEdBQ3JCLE9BQU8sV0FBVyxLQUFLLFFBQVEsSUFBSSxPQUFPLFdBQVcsQ0FBQyxHQUFHLEtBQUssVUFBVSxDQUFDO0FBRTNFLElBQUksaUJBQWlCLEVBQUU7SUFDckIsTUFBTSxnQkFBZ0IsR0FBRyxXQUFXLENBQUM7SUFDckMsY0FBYyxHQUFHLEdBQUcsRUFBRSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsRUFBRSxDQUFDO0NBQy9DO0tBQU07SUFDTCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUM7SUFDdkIsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ3BDLGNBQWMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLEdBQUcsV0FBVyxDQUFDO0NBQ3REO0FBRUQscUVBQXFFO0FBQ3JFLHNCQUFzQjtBQUN0QixtQ0FBbUM7QUFDbkMsTUFBTSxpQkFBaUIsR0FBRyxVQUFVLENBQUM7QUFFckMsd0JBQXdCO0FBQ3hCLE1BQU0sMEJBQTBCLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDdEMsdUJBQXVCO0FBQ3ZCLE1BQU0sOEJBQThCLEdBQUcsR0FBRyxDQUFDO0FBQzNDLE1BQU0sdUJBQXVCLEdBQUcsSUFBSSxDQUFD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RCxTQUFTLGlCQUFpQjtJQUN4QixZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDNUIsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3JCLENBQUM7QUFFRCxNQUFNLGFBQWEsR0FBRyxZQUFZLENBQUM7QUFFbkMsT0FBTyxFQUNMLGVBQWUsRUFDZixJQUFJLEVBQ0osZ0JBQWdCLEVBQ2hCLGNBQWMsRUFDZCxZQUFZLEVBQ1osdUJBQXVCLEVBQ3ZCLGlCQUFpQixJQUFJLFdBQVcsRUFDaEMsYUFBYSxJQUFJLFlBQVksRUFDN0IsaUJBQWlCLEVBQ2pCLGNBQWMsRUFDZCxvQkFBb0IsRUFDcEIsY0FBYyxJQUFJLEdBQUcsRUFDckIsY0FBYyxJQUFJLGNBQWMsR0FDakMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZmFjZWJvb2svcmVhY3QvbWFzdGVyL3BhY2thZ2VzL3NjaGVkdWxlci9zcmMvZm9ya3MvU2NoZWR1bGVyRE9NLmpzXHJcblxyXG5pbXBvcnQgeyDJtWdsb2JhbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBlbmFibGVJc0lucHV0UGVuZGluZyB9IGZyb20gJy4vc2NoZWR1bGVyRmVhdHVyZUZsYWdzJztcclxuaW1wb3J0IHsgcGVlaywgcG9wLCBwdXNoLCBSZWFjdFNjaGVkdWxlclRhc2sgfSBmcm9tICcuL3NjaGVkdWxlck1pbkhlYXAnO1xyXG5cclxuaW1wb3J0IHsgUHJpb3JpdHlMZXZlbCB9IGZyb20gJy4vc2NoZWR1bGVyUHJpb3JpdGllcyc7XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uIFdpbGwgYmUgcHJvdmlkZWQgdGhyb3VnaCBUZXJzZXIgZ2xvYmFsIGRlZmluaXRpb25zIGJ5IEFuZ3VsYXIgQ0xJXHJcbiAqIGR1cmluZyB0aGUgcHJvZHVjdGlvbiBidWlsZC5cclxuICovXHJcbmRlY2xhcmUgY29uc3QgbmdEZXZNb2RlOiBib29sZWFuO1xyXG5cclxubGV0IGdldEN1cnJlbnRUaW1lOiAoKSA9PiBudW1iZXI7XHJcbmNvbnN0IGhhc1BlcmZvcm1hbmNlTm93ID1cclxuICB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XHJcblxyXG5pZiAoaGFzUGVyZm9ybWFuY2VOb3cpIHtcclxuICBjb25zdCBsb2NhbFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XHJcbiAgZ2V0Q3VycmVudFRpbWUgPSAoKSA9PiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xyXG59IGVsc2Uge1xyXG4gIGNvbnN0IGxvY2FsRGF0ZSA9IERhdGU7XHJcbiAgY29uc3QgaW5pdGlhbFRpbWUgPSBsb2NhbERhdGUubm93KCk7XHJcbiAgZ2V0Q3VycmVudFRpbWUgPSAoKSA9PiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcclxufVxyXG5cclxuLy8gTWF4IDMxIGJpdCBpbnRlZ2VyLiBUaGUgbWF4IGludGVnZXIgc2l6ZSBpbiBWOCBmb3IgMzItYml0IHN5c3RlbXMuXHJcbi8vIE1hdGgucG93KDIsIDMwKSAtIDFcclxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcclxuY29uc3QgbWF4U2lnbmVkMzFCaXRJbnQgPSAxMDczNzQxODIzO1xyXG5cclxuLy8gVGltZXMgb3V0IGltbWVkaWF0ZWx5XHJcbmNvbnN0IElNTUVESUFURV9QUklPUklUWV9USU1FT1VUID0gLTE7XHJcbi8vIEV2ZW50dWFsbHkgdGltZXMgb3V0XHJcbmNvbnN0IFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVCA9IDI1MDtcclxuY29uc3QgTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQgPSA1MDAwO1xyXG5jb25zdCBMT1dfUFJJT1JJVFlfVElNRU9VVCA9IDEwMDAwO1xyXG4vLyBOZXZlciB0aW1lcyBvdXRcclxuY29uc3QgSURMRV9QUklPUklUWV9USU1FT1VUID0gbWF4U2lnbmVkMzFCaXRJbnQ7XHJcblxyXG4vLyBUYXNrcyBhcmUgc3RvcmVkIG9uIGEgbWluIGhlYXBcclxuY29uc3QgdGFza1F1ZXVlID0gW107XHJcbmNvbnN0IHRpbWVyUXVldWUgPSBbXTtcclxuXHJcbi8vIEluY3JlbWVudGluZyBpZCBjb3VudGVyLiBVc2VkIHRvIG1haW50YWluIGluc2VydGlvbiBvcmRlci5cclxubGV0IHRhc2tJZENvdW50ZXIgPSAxO1xyXG5cclxuLy8gUGF1c2luZyB0aGUgc2NoZWR1bGVyIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxyXG5sZXQgaXNTY2hlZHVsZXJQYXVzZWQgPSBmYWxzZTtcclxuXHJcbmxldCBjdXJyZW50VGFzayA9IG51bGw7XHJcbmxldCBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IFByaW9yaXR5TGV2ZWwuTm9ybWFsUHJpb3JpdHk7XHJcblxyXG4vLyBUaGlzIGlzIHNldCB3aGlsZSBwZXJmb3JtaW5nIHdvcmssIHRvIHByZXZlbnQgcmUtZW50cmFuY3kuXHJcbmxldCBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XHJcblxyXG5sZXQgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcclxubGV0IGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcclxuXHJcbi8vIENhcHR1cmUgbG9jYWwgcmVmZXJlbmNlcyB0byBuYXRpdmUgQVBJcywgaW4gY2FzZSBhIHBvbHlmaWxsIG92ZXJyaWRlcyB0aGVtLlxyXG5jb25zdCBzZXRUaW1lb3V0ID0gybVnbG9iYWwuc2V0VGltZW91dDtcclxuY29uc3QgY2xlYXJUaW1lb3V0ID0gybVnbG9iYWwuY2xlYXJUaW1lb3V0O1xyXG5jb25zdCBzZXRJbW1lZGlhdGUgPSDJtWdsb2JhbC5zZXRJbW1lZGlhdGU7IC8vIElFIGFuZCBOb2RlLmpzICsganNkb21cclxuY29uc3QgbWVzc2FnZUNoYW5uZWwgPSDJtWdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcclxuXHJcbmZ1bmN0aW9uIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpIHtcclxuICAvLyBDaGVjayBmb3IgdGFza3MgdGhhdCBhcmUgbm8gbG9uZ2VyIGRlbGF5ZWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBxdWV1ZS5cclxuICBsZXQgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xyXG4gIHdoaWxlICh0aW1lciAhPT0gbnVsbCkge1xyXG4gICAgaWYgKHRpbWVyLmNhbGxiYWNrID09PSBudWxsKSB7XHJcbiAgICAgIC8vIFRpbWVyIHdhcyBjYW5jZWxsZWQuXHJcbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcclxuICAgIH0gZWxzZSBpZiAodGltZXIuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XHJcbiAgICAgIC8vIFRpbWVyIGZpcmVkLiBUcmFuc2ZlciB0byB0aGUgdGFzayBxdWV1ZS5cclxuICAgICAgcG9wKHRpbWVyUXVldWUpO1xyXG4gICAgICB0aW1lci5zb3J0SW5kZXggPSB0aW1lci5leHBpcmF0aW9uVGltZTtcclxuICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFJlbWFpbmluZyB0aW1lcnMgYXJlIHBlbmRpbmcuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoY3VycmVudFRpbWUpIHtcclxuICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XHJcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XHJcblxyXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpIHtcclxuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgIT09IG51bGwpIHtcclxuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xyXG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcclxuICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcclxuICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZsdXNoV29yayhoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xyXG4gIC8vIFdlJ2xsIG5lZWQgYSBob3N0IGNhbGxiYWNrIHRoZSBuZXh0IHRpbWUgd29yayBpcyBzY2hlZHVsZWQuXHJcbiAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcclxuICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xyXG4gICAgLy8gV2Ugc2NoZWR1bGVkIGEgdGltZW91dCBidXQgaXQncyBubyBsb25nZXIgbmVlZGVkLiBDYW5jZWwgaXQuXHJcbiAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XHJcbiAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xyXG4gIH1cclxuXHJcbiAgaXNQZXJmb3JtaW5nV29yayA9IHRydWU7XHJcbiAgY29uc3QgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSk7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIGN1cnJlbnRUYXNrID0gbnVsbDtcclxuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xyXG4gICAgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcclxuICBsZXQgY3VycmVudFRpbWUgPSBpbml0aWFsVGltZTtcclxuICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcclxuICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcclxuICB3aGlsZSAoY3VycmVudFRhc2sgIT09IG51bGwgJiYgIWlzU2NoZWR1bGVyUGF1c2VkKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiZcclxuICAgICAgKCFoYXNUaW1lUmVtYWluaW5nIHx8IHNob3VsZFlpZWxkVG9Ib3N0KCkpXHJcbiAgICApIHtcclxuICAgICAgLy8gVGhpcyBjdXJyZW50VGFzayBoYXNuJ3QgZXhwaXJlZCwgYW5kIHdlJ3ZlIHJlYWNoZWQgdGhlIGRlYWRsaW5lLlxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGNvbnN0IGNhbGxiYWNrID0gY3VycmVudFRhc2suY2FsbGJhY2s7XHJcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50VGFzay5wcmlvcml0eUxldmVsO1xyXG4gICAgICBjb25zdCBkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0ID0gY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWU7XHJcbiAgICAgIGNvbnN0IGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soZGlkVXNlckNhbGxiYWNrVGltZW91dCk7XHJcbiAgICAgIGN1cnJlbnRUaW1lID0gZ2V0Q3VycmVudFRpbWUoKTtcclxuICAgICAgaWYgKHR5cGVvZiBjb250aW51YXRpb25DYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gY29udGludWF0aW9uQ2FsbGJhY2s7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrID09PSBwZWVrKHRhc2tRdWV1ZSkpIHtcclxuICAgICAgICAgIHBvcCh0YXNrUXVldWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBvcCh0YXNrUXVldWUpO1xyXG4gICAgfVxyXG4gICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XHJcbiAgfVxyXG4gIC8vIFJldHVybiB3aGV0aGVyIHRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrXHJcbiAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XHJcbiAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xyXG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZXZlbnRIYW5kbGVyKSB7XHJcbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XHJcbiAgICBjYXNlIFByaW9yaXR5TGV2ZWwuSW1tZWRpYXRlUHJpb3JpdHk6XHJcbiAgICBjYXNlIFByaW9yaXR5TGV2ZWwuVXNlckJsb2NraW5nUHJpb3JpdHk6XHJcbiAgICBjYXNlIFByaW9yaXR5TGV2ZWwuTm9ybWFsUHJpb3JpdHk6XHJcbiAgICBjYXNlIFByaW9yaXR5TGV2ZWwuTG93UHJpb3JpdHk6XHJcbiAgICBjYXNlIFByaW9yaXR5TGV2ZWwuSWRsZVByaW9yaXR5OlxyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBQcmlvcml0eUxldmVsLk5vcm1hbFByaW9yaXR5O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XHJcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xyXG5cclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHQoZXZlbnRIYW5kbGVyKSB7XHJcbiAgbGV0IHByaW9yaXR5TGV2ZWw7XHJcbiAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xyXG4gICAgY2FzZSBQcmlvcml0eUxldmVsLkltbWVkaWF0ZVByaW9yaXR5OlxyXG4gICAgY2FzZSBQcmlvcml0eUxldmVsLlVzZXJCbG9ja2luZ1ByaW9yaXR5OlxyXG4gICAgY2FzZSBQcmlvcml0eUxldmVsLk5vcm1hbFByaW9yaXR5OlxyXG4gICAgICAvLyBTaGlmdCBkb3duIHRvIG5vcm1hbCBwcmlvcml0eVxyXG4gICAgICBwcmlvcml0eUxldmVsID0gUHJpb3JpdHlMZXZlbC5Ob3JtYWxQcmlvcml0eTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICAvLyBBbnl0aGluZyBsb3dlciB0aGFuIG5vcm1hbCBwcmlvcml0eSBzaG91bGQgcmVtYWluIGF0IHRoZSBjdXJyZW50IGxldmVsLlxyXG4gICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XHJcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xyXG5cclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyYXBDYWxsYmFjayhjYWxsYmFjazogVm9pZEZ1bmN0aW9uKSB7XHJcbiAgY29uc3QgcGFyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xyXG4gIHJldHVybiAoKSA9PiB7XHJcbiAgICAvLyBUaGlzIGlzIGEgZm9yayBvZiBydW5XaXRoUHJpb3JpdHksIGlubGluZWQgZm9yIHBlcmZvcm1hbmNlLlxyXG4gICAgY29uc3QgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XHJcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHBhcmVudFByaW9yaXR5TGV2ZWw7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xyXG4gICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmludGVyZmFjZSBTY2hlZHVsZUNhbGxiYWNrT3B0aW9ucyB7XHJcbiAgZGVsYXk6IG51bWJlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhcclxuICBwcmlvcml0eUxldmVsOiBQcmlvcml0eUxldmVsLFxyXG4gIGNhbGxiYWNrOiBWb2lkRnVuY3Rpb24sXHJcbiAgb3B0aW9ucz86IFNjaGVkdWxlQ2FsbGJhY2tPcHRpb25zXHJcbik6IFJlYWN0U2NoZWR1bGVyVGFzayB7XHJcbiAgY29uc3QgY3VycmVudFRpbWUgPSBnZXRDdXJyZW50VGltZSgpO1xyXG5cclxuICBsZXQgc3RhcnRUaW1lOiBudW1iZXI7XHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XHJcbiAgICBjb25zdCBkZWxheSA9IG9wdGlvbnMuZGVsYXk7XHJcbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJyAmJiBkZWxheSA+IDApIHtcclxuICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcclxuICB9XHJcblxyXG4gIGxldCB0aW1lb3V0OiBudW1iZXI7XHJcbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XHJcbiAgICBjYXNlIFByaW9yaXR5TGV2ZWwuSW1tZWRpYXRlUHJpb3JpdHk6XHJcbiAgICAgIHRpbWVvdXQgPSBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFByaW9yaXR5TGV2ZWwuVXNlckJsb2NraW5nUHJpb3JpdHk6XHJcbiAgICAgIHRpbWVvdXQgPSBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQ7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBQcmlvcml0eUxldmVsLklkbGVQcmlvcml0eTpcclxuICAgICAgdGltZW91dCA9IElETEVfUFJJT1JJVFlfVElNRU9VVDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFByaW9yaXR5TGV2ZWwuTG93UHJpb3JpdHk6XHJcbiAgICAgIHRpbWVvdXQgPSBMT1dfUFJJT1JJVFlfVElNRU9VVDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFByaW9yaXR5TGV2ZWwuTm9ybWFsUHJpb3JpdHk6XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aW1lb3V0ID0gTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQ7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZXhwaXJhdGlvblRpbWUgPSBzdGFydFRpbWUgKyB0aW1lb3V0O1xyXG5cclxuICBjb25zdCBuZXdUYXNrOiBSZWFjdFNjaGVkdWxlclRhc2sgPSB7XHJcbiAgICBpZDogdGFza0lkQ291bnRlcisrLFxyXG4gICAgY2FsbGJhY2ssXHJcbiAgICBwcmlvcml0eUxldmVsLFxyXG4gICAgc3RhcnRUaW1lLFxyXG4gICAgZXhwaXJhdGlvblRpbWUsXHJcbiAgICBzb3J0SW5kZXg6IC0xLFxyXG4gIH07XHJcblxyXG4gIGlmIChzdGFydFRpbWUgPiBjdXJyZW50VGltZSkge1xyXG4gICAgLy8gVGhpcyBpcyBhIGRlbGF5ZWQgdGFzay5cclxuICAgIG5ld1Rhc2suc29ydEluZGV4ID0gc3RhcnRUaW1lO1xyXG4gICAgcHVzaCh0aW1lclF1ZXVlLCBuZXdUYXNrKTtcclxuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgPT09IG51bGwgJiYgbmV3VGFzayA9PT0gcGVlayh0aW1lclF1ZXVlKSkge1xyXG4gICAgICAvLyBBbGwgdGFza3MgYXJlIGRlbGF5ZWQsIGFuZCB0aGlzIGlzIHRoZSB0YXNrIHdpdGggdGhlIGVhcmxpZXN0IGRlbGF5LlxyXG4gICAgICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xyXG4gICAgICAgIC8vIENhbmNlbCBhbiBleGlzdGluZyB0aW1lb3V0LlxyXG4gICAgICAgIGNhbmNlbEhvc3RUaW1lb3V0KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gU2NoZWR1bGUgYSB0aW1lb3V0LlxyXG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IGV4cGlyYXRpb25UaW1lO1xyXG4gICAgcHVzaCh0YXNrUXVldWUsIG5ld1Rhc2spO1xyXG4gICAgLy8gU2NoZWR1bGUgYSBob3N0IGNhbGxiYWNrLCBpZiBuZWVkZWQuIElmIHdlJ3JlIGFscmVhZHkgcGVyZm9ybWluZyB3b3JrLFxyXG4gICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV4dCB0aW1lIHdlIHlpZWxkLlxyXG4gICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xyXG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XHJcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZXdUYXNrO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXVzZUV4ZWN1dGlvbigpIHtcclxuICBpc1NjaGVkdWxlclBhdXNlZCA9IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnRpbnVlRXhlY3V0aW9uKCkge1xyXG4gIGlzU2NoZWR1bGVyUGF1c2VkID0gZmFsc2U7XHJcbiAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xyXG4gICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xyXG4gICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Rmlyc3RDYWxsYmFja05vZGUoKSB7XHJcbiAgcmV0dXJuIHBlZWsodGFza1F1ZXVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2FuY2VsQ2FsbGJhY2sodGFzaykge1xyXG4gIC8vIE51bGwgb3V0IHRoZSBjYWxsYmFjayB0byBpbmRpY2F0ZSB0aGUgdGFzayBoYXMgYmVlbiBjYW5jZWxlZC4gKENhbid0XHJcbiAgLy8gcmVtb3ZlIGZyb20gdGhlIHF1ZXVlIGJlY2F1c2UgeW91IGNhbid0IHJlbW92ZSBhcmJpdHJhcnkgbm9kZXMgZnJvbSBhblxyXG4gIC8vIGFycmF5IGJhc2VkIGhlYXAsIG9ubHkgdGhlIGZpcnN0IG9uZS4pXHJcbiAgdGFzay5jYWxsYmFjayA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCkge1xyXG4gIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcclxufVxyXG5cclxubGV0IGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XHJcbmxldCBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xyXG5sZXQgdGFza1RpbWVvdXRJRCA9IC0xO1xyXG5cclxuLy8gU2NoZWR1bGVyIHBlcmlvZGljYWxseSB5aWVsZHMgaW4gY2FzZSB0aGVyZSBpcyBvdGhlciB3b3JrIG9uIHRoZSBtYWluXHJcbi8vIHRocmVhZCwgbGlrZSB1c2VyIGV2ZW50cy4gQnkgZGVmYXVsdCwgaXQgeWllbGRzIG11bHRpcGxlIHRpbWVzIHBlciBmcmFtZS5cclxuLy8gSXQgZG9lcyBub3QgYXR0ZW1wdCB0byBhbGlnbiB3aXRoIGZyYW1lIGJvdW5kYXJpZXMsIHNpbmNlIG1vc3QgdGFza3MgZG9uJ3RcclxuLy8gbmVlZCB0byBiZSBmcmFtZSBhbGlnbmVkOyBmb3IgdGhvc2UgdGhhdCBkbywgdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cclxubGV0IHlpZWxkSW50ZXJ2YWwgPSAxNjtcclxubGV0IGRlYWRsaW5lID0gMDtcclxuXHJcbi8vIFRPRE86IE1ha2UgdGhpcyBjb25maWd1cmFibGVcclxuLy8gVE9ETzogQWRqdXN0IHRoaXMgYmFzZWQgb24gcHJpb3JpdHk/XHJcbmNvbnN0IG1heFlpZWxkSW50ZXJ2YWwgPSAzMDA7XHJcbmxldCBuZWVkc1BhaW50ID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcclxuICBpZiAoXHJcbiAgICBlbmFibGVJc0lucHV0UGVuZGluZyAmJlxyXG4gICAgbmF2aWdhdG9yICE9PSB1bmRlZmluZWQgJiZcclxuICAgIChuYXZpZ2F0b3IgYXMgYW55KS5zY2hlZHVsaW5nICE9PSB1bmRlZmluZWQgJiZcclxuICAgIChuYXZpZ2F0b3IgYXMgYW55KS5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nICE9PSB1bmRlZmluZWRcclxuICApIHtcclxuICAgIGNvbnN0IHNjaGVkdWxpbmcgPSAobmF2aWdhdG9yIGFzIGFueSkuc2NoZWR1bGluZztcclxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gZ2V0Q3VycmVudFRpbWUoKTtcclxuICAgIGlmIChjdXJyZW50VGltZSA+PSBkZWFkbGluZSkge1xyXG4gICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdC4gV2UgbWF5IHdhbnQgdG8geWllbGQgY29udHJvbCBvZiB0aGUgbWFpblxyXG4gICAgICAvLyB0aHJlYWQsIHNvIHRoZSBicm93c2VyIGNhbiBwZXJmb3JtIGhpZ2ggcHJpb3JpdHkgdGFza3MuIFRoZSBtYWluIG9uZXNcclxuICAgICAgLy8gYXJlIHBhaW50aW5nIGFuZCB1c2VyIGlucHV0LiBJZiB0aGVyZSdzIGEgcGVuZGluZyBwYWludCBvciBhIHBlbmRpbmdcclxuICAgICAgLy8gaW5wdXQsIHRoZW4gd2Ugc2hvdWxkIHlpZWxkLiBCdXQgaWYgdGhlcmUncyBuZWl0aGVyLCB0aGVuIHdlIGNhblxyXG4gICAgICAvLyB5aWVsZCBsZXNzIG9mdGVuIHdoaWxlIHJlbWFpbmluZyByZXNwb25zaXZlLiBXZSdsbCBldmVudHVhbGx5IHlpZWxkXHJcbiAgICAgIC8vIHJlZ2FyZGxlc3MsIHNpbmNlIHRoZXJlIGNvdWxkIGJlIGEgcGVuZGluZyBwYWludCB0aGF0IHdhc24ndFxyXG4gICAgICAvLyBhY2NvbXBhbmllZCBieSBhIGNhbGwgdG8gYHJlcXVlc3RQYWludGAsIG9yIG90aGVyIG1haW4gdGhyZWFkIHRhc2tzXHJcbiAgICAgIC8vIGxpa2UgbmV0d29yayBldmVudHMuXHJcbiAgICAgIGlmIChuZWVkc1BhaW50IHx8IHNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcoKSkge1xyXG4gICAgICAgIC8vIFRoZXJlIGlzIGVpdGhlciBhIHBlbmRpbmcgcGFpbnQgb3IgYSBwZW5kaW5nIGlucHV0LlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gcGVuZGluZyBpbnB1dC4gT25seSB5aWVsZCBpZiB3ZSd2ZSByZWFjaGVkIHRoZSBtYXhcclxuICAgICAgLy8geWllbGQgaW50ZXJ2YWwuXHJcbiAgICAgIHJldHVybiBjdXJyZW50VGltZSA+PSBtYXhZaWVsZEludGVydmFsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gVGhlcmUncyBzdGlsbCB0aW1lIGxlZnQgaW4gdGhlIGZyYW1lLlxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIGBpc0lucHV0UGVuZGluZ2AgaXMgbm90IGF2YWlsYWJsZS4gU2luY2Ugd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZyBpZlxyXG4gICAgLy8gdGhlcmUncyBwZW5kaW5nIGlucHV0LCBhbHdheXMgeWllbGQgYXQgdGhlIGVuZCBvZiB0aGUgZnJhbWUuXHJcbiAgICByZXR1cm4gZ2V0Q3VycmVudFRpbWUoKSA+PSBkZWFkbGluZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcXVlc3RQYWludCgpIHtcclxuICBpZiAoXHJcbiAgICBlbmFibGVJc0lucHV0UGVuZGluZyAmJlxyXG4gICAgbmF2aWdhdG9yICE9PSB1bmRlZmluZWQgJiZcclxuICAgIChuYXZpZ2F0b3IgYXMgYW55KS5zY2hlZHVsaW5nICE9PSB1bmRlZmluZWQgJiZcclxuICAgIChuYXZpZ2F0b3IgYXMgYW55KS5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nICE9PSB1bmRlZmluZWRcclxuICApIHtcclxuICAgIG5lZWRzUGFpbnQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gU2luY2Ugd2UgeWllbGQgZXZlcnkgZnJhbWUgcmVnYXJkbGVzcywgYHJlcXVlc3RQYWludGAgaGFzIG5vIGVmZmVjdC5cclxufVxyXG5cclxuZnVuY3Rpb24gZm9yY2VGcmFtZVJhdGUoZnBzKSB7XHJcbiAgaWYgKGZwcyA8IDAgfHwgZnBzID4gMTI1KSB7XHJcbiAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgJ2ZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCAnICtcclxuICAgICAgICAgICdmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZCdcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGZwcyA+IDApIHtcclxuICAgIHlpZWxkSW50ZXJ2YWwgPSBNYXRoLmZsb29yKDEwMDAgLyBmcHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyByZXNldCB0aGUgZnJhbWVyYXRlXHJcbiAgICB5aWVsZEludGVydmFsID0gNTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9ICgpID0+IHtcclxuICBpZiAoc2NoZWR1bGVkSG9zdENhbGxiYWNrICE9PSBudWxsKSB7XHJcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IGdldEN1cnJlbnRUaW1lKCk7XHJcbiAgICAvLyBZaWVsZCBhZnRlciBgeWllbGRJbnRlcnZhbGAgbXMsIHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgd2UgYXJlIGluIHRoZSB2c3luY1xyXG4gICAgLy8gY3ljbGUuIFRoaXMgbWVhbnMgdGhlcmUncyBhbHdheXMgdGltZSByZW1haW5pbmcgYXQgdGhlIGJlZ2lubmluZyBvZlxyXG4gICAgLy8gdGhlIG1lc3NhZ2UgZXZlbnQuXHJcbiAgICBkZWFkbGluZSA9IGN1cnJlbnRUaW1lICsgeWllbGRJbnRlcnZhbDtcclxuICAgIGNvbnN0IGhhc1RpbWVSZW1haW5pbmcgPSB0cnVlO1xyXG5cclxuICAgIC8vIElmIGEgc2NoZWR1bGVyIHRhc2sgdGhyb3dzLCBleGl0IHRoZSBjdXJyZW50IGJyb3dzZXIgdGFzayBzbyB0aGVcclxuICAgIC8vIGVycm9yIGNhbiBiZSBvYnNlcnZlZC5cclxuICAgIC8vXHJcbiAgICAvLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBhIHRyeS1jYXRjaCwgc2luY2UgdGhhdCBtYWtlcyBzb21lIGRlYnVnZ2luZ1xyXG4gICAgLy8gdGVjaG5pcXVlcyBoYXJkZXIuIEluc3RlYWQsIGlmIGBzY2hlZHVsZWRIb3N0Q2FsbGJhY2tgIGVycm9ycywgdGhlblxyXG4gICAgLy8gYGhhc01vcmVXb3JrYCB3aWxsIHJlbWFpbiB0cnVlLCBhbmQgd2UnbGwgY29udGludWUgdGhlIHdvcmsgbG9vcC5cclxuICAgIGxldCBoYXNNb3JlV29yayA9IHRydWU7XHJcbiAgICB0cnkge1xyXG4gICAgICBoYXNNb3JlV29yayA9IHNjaGVkdWxlZEhvc3RDYWxsYmFjayhoYXNUaW1lUmVtYWluaW5nLCBjdXJyZW50VGltZSk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBpZiAoaGFzTW9yZVdvcmspIHtcclxuICAgICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgd29yaywgc2NoZWR1bGUgdGhlIG5leHQgbWVzc2FnZSBldmVudCBhdCB0aGUgZW5kXHJcbiAgICAgICAgLy8gb2YgdGhlIHByZWNlZGluZyBvbmUuXHJcbiAgICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcclxuICB9XHJcbiAgLy8gWWllbGRpbmcgdG8gdGhlIGJyb3dzZXIgd2lsbCBnaXZlIGl0IGEgY2hhbmNlIHRvIHBhaW50LCBzbyB3ZSBjYW5cclxuICAvLyByZXNldCB0aGlzLlxyXG4gIG5lZWRzUGFpbnQgPSBmYWxzZTtcclxufTtcclxuXHJcbmxldCBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcclxuaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAvLyBOb2RlLmpzIGFuZCBvbGQgSUUuXHJcbiAgLy8gVGhlcmUncyBhIGZldyByZWFzb25zIGZvciB3aHkgd2UgcHJlZmVyIHNldEltbWVkaWF0ZS5cclxuICAvL1xyXG4gIC8vIFVubGlrZSBNZXNzYWdlQ2hhbm5lbCwgaXQgZG9lc24ndCBwcmV2ZW50IGEgTm9kZS5qcyBwcm9jZXNzIGZyb20gZXhpdGluZy5cclxuICAvLyAoRXZlbiB0aG91Z2ggdGhpcyBpcyBhIERPTSBmb3JrIG9mIHRoZSBTY2hlZHVsZXIsIHlvdSBjb3VsZCBnZXQgaGVyZVxyXG4gIC8vIHdpdGggYSBtaXggb2YgTm9kZS5qcyAxNSssIHdoaWNoIGhhcyBhIE1lc3NhZ2VDaGFubmVsLCBhbmQganNkb20uKVxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjA3NTZcclxuICAvL1xyXG4gIC8vIEJ1dCBhbHNvLCBpdCBydW5zIGVhcmxpZXIgd2hpY2ggaXMgdGhlIHNlbWFudGljIHdlIHdhbnQuXHJcbiAgLy8gSWYgb3RoZXIgYnJvd3NlcnMgZXZlciBpbXBsZW1lbnQgaXQsIGl0J3MgYmV0dGVyIHRvIHVzZSBpdC5cclxuICAvLyBBbHRob3VnaCBib3RoIG9mIHRoZXNlIHdvdWxkIGJlIGluZmVyaW9yIHRvIG5hdGl2ZSBzY2hlZHVsaW5nLlxyXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gKCkgPT4ge1xyXG4gICAgc2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XHJcbiAgfTtcclxufSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgY29uc3QgY2hhbm5lbDogTWVzc2FnZUNoYW5uZWwgPSBuZXcgbWVzc2FnZUNoYW5uZWwoKTtcclxuICBjb25zdCBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcclxuXHJcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XHJcbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSAoKSA9PiB7XHJcbiAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xyXG4gIH07XHJcbn0gZWxzZSB7XHJcbiAgLy8gV2Ugc2hvdWxkIG9ubHkgZmFsbGJhY2sgaGVyZSBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMuXHJcbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSAoKSA9PiB7XHJcbiAgICBzZXRUaW1lb3V0KHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSwgMCk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWVzdEhvc3RDYWxsYmFjayhjYWxsYmFjaykge1xyXG4gIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gIGlmICghaXNNZXNzYWdlTG9vcFJ1bm5pbmcpIHtcclxuICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gdHJ1ZTtcclxuICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1ZXN0SG9zdFRpbWVvdXQoY2FsbGJhY2ssIG1zKSB7XHJcbiAgdGFza1RpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgY2FsbGJhY2soZ2V0Q3VycmVudFRpbWUoKSk7XHJcbiAgfSwgbXMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYW5jZWxIb3N0VGltZW91dCgpIHtcclxuICBjbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCk7XHJcbiAgdGFza1RpbWVvdXRJRCA9IC0xO1xyXG59XHJcblxyXG5jb25zdCBfcmVxdWVzdFBhaW50ID0gcmVxdWVzdFBhaW50O1xyXG5cclxuZXhwb3J0IHtcclxuICBydW5XaXRoUHJpb3JpdHksXHJcbiAgbmV4dCxcclxuICBzY2hlZHVsZUNhbGxiYWNrLFxyXG4gIGNhbmNlbENhbGxiYWNrLFxyXG4gIHdyYXBDYWxsYmFjayxcclxuICBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCxcclxuICBzaG91bGRZaWVsZFRvSG9zdCBhcyBzaG91bGRZaWVsZCxcclxuICBfcmVxdWVzdFBhaW50IGFzIHJlcXVlc3RQYWludCxcclxuICBjb250aW51ZUV4ZWN1dGlvbixcclxuICBwYXVzZUV4ZWN1dGlvbixcclxuICBnZXRGaXJzdENhbGxiYWNrTm9kZSxcclxuICBnZXRDdXJyZW50VGltZSBhcyBub3csXHJcbiAgZm9yY2VGcmFtZVJhdGUgYXMgZm9yY2VGcmFtZVJhdGUsXHJcbn07XHJcbiJdfQ==