export function push(heap, node) {
    const index = heap.length;
    heap.push(node);
    siftUp(heap, node, index);
}
export function peek(heap) {
    const first = heap[0];
    return first === undefined ? null : first;
}
export function pop(heap) {
    const first = heap[0];
    if (first !== undefined) {
        const last = heap.pop();
        if (last !== first) {
            heap[0] = last;
            siftDown(heap, last, 0);
        }
        return first;
    }
    else {
        return null;
    }
}
function siftUp(heap, node, i) {
    let index = i;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        // tslint:disable-next-line:no-bitwise
        const parentIndex = (index - 1) >>> 1;
        const parent = heap[parentIndex];
        if (parent !== undefined && compare(parent, node) > 0) {
            // The parent is larger. Swap positions.
            heap[parentIndex] = node;
            heap[index] = parent;
            index = parentIndex;
        }
        else {
            // The parent is smaller. Exit.
            return;
        }
    }
}
function siftDown(heap, node, i) {
    let index = i;
    const length = heap.length;
    while (index < length) {
        const leftIndex = (index + 1) * 2 - 1;
        const left = heap[leftIndex];
        const rightIndex = leftIndex + 1;
        const right = heap[rightIndex];
        // If the left or right node is smaller, swap with the smaller of those.
        if (left !== undefined && compare(left, node) < 0) {
            if (right !== undefined && compare(right, left) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
            }
            else {
                heap[index] = left;
                heap[leftIndex] = node;
                index = leftIndex;
            }
        }
        else if (right !== undefined && compare(right, node) < 0) {
            heap[index] = right;
            heap[rightIndex] = node;
            index = rightIndex;
        }
        else {
            // Neither child is smaller. Exit.
            return;
        }
    }
}
function compare(a, b) {
    // Compare sort index first, then task id.
    const diff = a.sortIndex - b.sortIndex;
    return diff !== 0 ? diff : a.id - b.id;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZWR1bGVyTWluSGVhcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvY2RrL2ludGVybmFscy9zY2hlZHVsZXIvc3JjL2xpYi9zY2hlZHVsZXJNaW5IZWFwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNBLE1BQU0sVUFBVSxJQUFJLENBQUMsSUFBVSxFQUFFLElBQXdCO0lBQ3ZELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoQixNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztBQUM1QixDQUFDO0FBRUQsTUFBTSxVQUFVLElBQUksQ0FBQyxJQUFVO0lBQzdCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0QixPQUFPLEtBQUssS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQzVDLENBQUM7QUFFRCxNQUFNLFVBQVUsR0FBRyxDQUFDLElBQVU7SUFDNUIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3RCLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtRQUN2QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDeEIsSUFBSSxJQUFJLEtBQUssS0FBSyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7WUFDZixRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztTQUN6QjtRQUNELE9BQU8sS0FBSyxDQUFDO0tBQ2Q7U0FBTTtRQUNMLE9BQU8sSUFBSSxDQUFDO0tBQ2I7QUFDSCxDQUFDO0FBRUQsU0FBUyxNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDO0lBQzNCLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNkLGlEQUFpRDtJQUNqRCxPQUFPLElBQUksRUFBRTtRQUNYLHNDQUFzQztRQUN0QyxNQUFNLFdBQVcsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2pDLElBQUksTUFBTSxLQUFLLFNBQVMsSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNyRCx3Q0FBd0M7WUFDeEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUN6QixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsTUFBTSxDQUFDO1lBQ3JCLEtBQUssR0FBRyxXQUFXLENBQUM7U0FDckI7YUFBTTtZQUNMLCtCQUErQjtZQUMvQixPQUFPO1NBQ1I7S0FDRjtBQUNILENBQUM7QUFFRCxTQUFTLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDN0IsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2QsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUMzQixPQUFPLEtBQUssR0FBRyxNQUFNLEVBQUU7UUFDckIsTUFBTSxTQUFTLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDN0IsTUFBTSxVQUFVLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQztRQUNqQyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFL0Isd0VBQXdFO1FBQ3hFLElBQUksSUFBSSxLQUFLLFNBQVMsSUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNqRCxJQUFJLEtBQUssS0FBSyxTQUFTLElBQUksT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ25ELElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7Z0JBQ3BCLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxJQUFJLENBQUM7Z0JBQ3hCLEtBQUssR0FBRyxVQUFVLENBQUM7YUFDcEI7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQztnQkFDbkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQztnQkFDdkIsS0FBSyxHQUFHLFNBQVMsQ0FBQzthQUNuQjtTQUNGO2FBQU0sSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLE9BQU8sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzFELElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7WUFDcEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUN4QixLQUFLLEdBQUcsVUFBVSxDQUFDO1NBQ3BCO2FBQU07WUFDTCxrQ0FBa0M7WUFDbEMsT0FBTztTQUNSO0tBQ0Y7QUFDSCxDQUFDO0FBRUQsU0FBUyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDbkIsMENBQTBDO0lBQzFDLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQztJQUN2QyxPQUFPLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQ3pDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcmlvcml0eUxldmVsIH0gZnJvbSAnLi9zY2hlZHVsZXJQcmlvcml0aWVzJztcclxuXHJcbnR5cGUgSGVhcCA9IEFycmF5PFJlYWN0U2NoZWR1bGVyVGFzaz47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJlYWN0U2NoZWR1bGVyVGFzayB7XHJcbiAgaWQ6IG51bWJlcjtcclxuICBzb3J0SW5kZXg6IG51bWJlcjtcclxuICBjYWxsYmFjazogVm9pZEZ1bmN0aW9uO1xyXG4gIHByaW9yaXR5TGV2ZWw6IFByaW9yaXR5TGV2ZWw7XHJcbiAgc3RhcnRUaW1lOiBudW1iZXI7XHJcbiAgZXhwaXJhdGlvblRpbWU6IG51bWJlcjtcclxuICBpc1F1ZXVlZD86IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwdXNoKGhlYXA6IEhlYXAsIG5vZGU6IFJlYWN0U2NoZWR1bGVyVGFzayk6IHZvaWQge1xyXG4gIGNvbnN0IGluZGV4ID0gaGVhcC5sZW5ndGg7XHJcbiAgaGVhcC5wdXNoKG5vZGUpO1xyXG4gIHNpZnRVcChoZWFwLCBub2RlLCBpbmRleCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwZWVrKGhlYXA6IEhlYXApOiBSZWFjdFNjaGVkdWxlclRhc2sgfCBudWxsIHtcclxuICBjb25zdCBmaXJzdCA9IGhlYXBbMF07XHJcbiAgcmV0dXJuIGZpcnN0ID09PSB1bmRlZmluZWQgPyBudWxsIDogZmlyc3Q7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwb3AoaGVhcDogSGVhcCk6IFJlYWN0U2NoZWR1bGVyVGFzayB8IG51bGwge1xyXG4gIGNvbnN0IGZpcnN0ID0gaGVhcFswXTtcclxuICBpZiAoZmlyc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgY29uc3QgbGFzdCA9IGhlYXAucG9wKCk7XHJcbiAgICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcclxuICAgICAgaGVhcFswXSA9IGxhc3Q7XHJcbiAgICAgIHNpZnREb3duKGhlYXAsIGxhc3QsIDApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZpcnN0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpZnRVcChoZWFwLCBub2RlLCBpKSB7XHJcbiAgbGV0IGluZGV4ID0gaTtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXHJcbiAgd2hpbGUgKHRydWUpIHtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXHJcbiAgICBjb25zdCBwYXJlbnRJbmRleCA9IChpbmRleCAtIDEpID4+PiAxO1xyXG4gICAgY29uc3QgcGFyZW50ID0gaGVhcFtwYXJlbnRJbmRleF07XHJcbiAgICBpZiAocGFyZW50ICE9PSB1bmRlZmluZWQgJiYgY29tcGFyZShwYXJlbnQsIG5vZGUpID4gMCkge1xyXG4gICAgICAvLyBUaGUgcGFyZW50IGlzIGxhcmdlci4gU3dhcCBwb3NpdGlvbnMuXHJcbiAgICAgIGhlYXBbcGFyZW50SW5kZXhdID0gbm9kZTtcclxuICAgICAgaGVhcFtpbmRleF0gPSBwYXJlbnQ7XHJcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBUaGUgcGFyZW50IGlzIHNtYWxsZXIuIEV4aXQuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpZnREb3duKGhlYXAsIG5vZGUsIGkpIHtcclxuICBsZXQgaW5kZXggPSBpO1xyXG4gIGNvbnN0IGxlbmd0aCA9IGhlYXAubGVuZ3RoO1xyXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgY29uc3QgbGVmdEluZGV4ID0gKGluZGV4ICsgMSkgKiAyIC0gMTtcclxuICAgIGNvbnN0IGxlZnQgPSBoZWFwW2xlZnRJbmRleF07XHJcbiAgICBjb25zdCByaWdodEluZGV4ID0gbGVmdEluZGV4ICsgMTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTtcclxuXHJcbiAgICAvLyBJZiB0aGUgbGVmdCBvciByaWdodCBub2RlIGlzIHNtYWxsZXIsIHN3YXAgd2l0aCB0aGUgc21hbGxlciBvZiB0aG9zZS5cclxuICAgIGlmIChsZWZ0ICE9PSB1bmRlZmluZWQgJiYgY29tcGFyZShsZWZ0LCBub2RlKSA8IDApIHtcclxuICAgICAgaWYgKHJpZ2h0ICE9PSB1bmRlZmluZWQgJiYgY29tcGFyZShyaWdodCwgbGVmdCkgPCAwKSB7XHJcbiAgICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcclxuICAgICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcclxuICAgICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaGVhcFtpbmRleF0gPSBsZWZ0O1xyXG4gICAgICAgIGhlYXBbbGVmdEluZGV4XSA9IG5vZGU7XHJcbiAgICAgICAgaW5kZXggPSBsZWZ0SW5kZXg7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAocmlnaHQgIT09IHVuZGVmaW5lZCAmJiBjb21wYXJlKHJpZ2h0LCBub2RlKSA8IDApIHtcclxuICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcclxuICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XHJcbiAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE5laXRoZXIgY2hpbGQgaXMgc21hbGxlci4gRXhpdC5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XHJcbiAgLy8gQ29tcGFyZSBzb3J0IGluZGV4IGZpcnN0LCB0aGVuIHRhc2sgaWQuXHJcbiAgY29uc3QgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XHJcbiAgcmV0dXJuIGRpZmYgIT09IDAgPyBkaWZmIDogYS5pZCAtIGIuaWQ7XHJcbn1cclxuIl19