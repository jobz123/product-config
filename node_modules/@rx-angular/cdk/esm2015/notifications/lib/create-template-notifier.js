import { from, isObservable, NEVER, of, ReplaySubject } from 'rxjs';
import { distinctUntilChanged, filter, map, startWith, switchMap, } from 'rxjs/operators';
import { rxMaterialize } from './rx-materialize';
import { toRxSuspenseNotification } from './notification-transforms';
const calcWithSuspenseTpl = (withSuspenseTpl) => withSuspenseTpl && withSuspenseTpl();
const ɵ0 = calcWithSuspenseTpl;
/**
 * @description
 * Sends value and an initial `undefined` as value With a NEVER.
 * This is needed to render the suspense template and avoid completing (and render the complete template).
 * @param value
 */
const emitAndDontComplete = (value) => NEVER.pipe(startWith(value));
const ɵ1 = emitAndDontComplete;
/**
* @description
* Flags the first run.
* This is important as we want to create laziness in the template.
* If no value ever is emitted we dont want to create/render the value (next template).
* In case a suspense template is given (calculated by `withSuspense` param) we render the suspense template on the first run.
*/
const mapFirst = (transformation) => (o$) => {
    let firstRun = true;
    return o$.pipe(map((value) => {
        if (!firstRun) {
            return value;
        }
        const result = transformation(value);
        firstRun = false;
        return result;
    }));
};
const ɵ2 = mapFirst;
/**
 * This helper is responsible for turning a stream of materialized notifications
 * (next error, complete as object in the next stream) into an enriched version with an additional suspense notification type.
 *
 * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.
 * This value is important in the template to show an e.g. error and also have access to the last emitted value of next.
 * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner in case of the suspense state.
 *
 * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification
 * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification
 * and assign it as new value to the notification
 */
const handleSuspenseAndLastValueInNotifications = () => {
    // Used to store the last value per handleSuspenseAndLastValueInNotifications call
    let latestNextValue;
    // returns a projection function with a lastValue cache
    return (notification) => {
        // if it the notification is of type next we take its value
        // otherwise we keep the existing last value
        if (notification.kind === "next" /* Next */) {
            latestNextValue = notification.value;
        }
        // If a next notification enters with a value of undefined we turn it into a suspense notification
        if (notification.kind === "next" /* Next */ &&
            notification.value === undefined) {
            return toRxSuspenseNotification(undefined);
        }
        // If a Notification of type error, complete or suspense enters we assign the latest last value to them.
        // This is needed to access the old value in case of error or complete.
        // Next notifications will pass as they are.
        if (notification.kind === "error" /* Error */ ||
            notification.kind === "complete" /* Complete */ ||
            notification.kind === "suspense" /* Suspense */) {
            notification.value = latestNextValue;
        }
        return notification;
    };
};
const ɵ3 = handleSuspenseAndLastValueInNotifications;
/**
 * @internal
 *
 * @description
 * This factory function returns an object that can be driven imperatively over a `next` method.
 * Internally it prepares the incoming values for rendering by turning them into "template notifications",
 * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing or suspense states.
 *
 * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.
 * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the display of
 * the default template as well as the suspense, error, complete templates.
 */
export function createTemplateNotifier(withSuspenseTpl) {
    // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties
    const observablesSubject = new ReplaySubject(1);
    const values$ = observablesSubject.pipe(distinctUntilChanged(), 
    // Handle initialization edge cases
    mapFirst((value) => {
        const isUndefined = value === undefined;
        const isNEVER = value === NEVER;
        // If it is a `NEVER` Observable we know it will never emit a value nor complete or error.
        // Therefore we emit directly undefined to signal a suspense state
        if ((isUndefined || isNEVER)) {
            // Determines if a suspense notification is needed
            const isSuspenseTemplateGiven = calcWithSuspenseTpl(withSuspenseTpl);
            // Render suspense template if given. Otherwise do nothing (later undefined are filtered out)
            return isSuspenseTemplateGiven ? emitAndDontComplete(undefined) : undefined;
        }
        const isNull = value === null;
        if (isNull) {
            // We return the value and no undefined as first value
            // as we dont need to render the suspense template for null values (it is considered as not used)
            return of(null);
        }
        return value;
    }), 
    // `undefined` values are only processed once at beginning to initialize lazy. After that they are filtered out.
    filter((v) => v !== undefined), 
    // handle static values inc null assignment and new Observable or Promises
    map((observable$) => {
        const isNull = observable$ === null;
        const isPromiseOrObs = typeof observable$.then === 'function' || isObservable(observable$);
        // A value is considered as static value if it is `null`, or any other value than `undefined`, `Promise`, `Observable`
        const isStaticValue = !isPromiseOrObs && !(observable$ === undefined) || isNull;
        const isNEVER = observable$ === NEVER;
        // If it is a `NEVER` Observable we know it will never emit a value nor complete or error.
        // Therefore we emit directly undefined to signal a suspense state
        if (isNEVER) {
            // Render suspense template for null values (it is considered as not used)
            return emitAndDontComplete(undefined);
        }
        // If it is a static value forward directly
        if (isStaticValue) {
            // Render next template for static values (it is considered as kinda sync)
            return emitAndDontComplete(observable$);
        }
        return from(observable$).pipe((o$) => {
            // Determines if a suspense notification is needed
            const isSuspenseTemplateGiven = calcWithSuspenseTpl(withSuspenseTpl);
            if (isSuspenseTemplateGiven) {
                // Render suspense template
                return o$.pipe(startWith(undefined));
            }
            return o$;
        });
    }), switchMap((o) => {
        return o.pipe(distinctUntilChanged(), rxMaterialize(), map(handleSuspenseAndLastValueInNotifications()));
    }));
    return {
        next(observable) {
            observablesSubject.next(observable);
        },
        values$,
    };
}
export { ɵ0, ɵ1, ɵ2, ɵ3 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlLXRlbXBsYXRlLW5vdGlmaWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9jZGsvbm90aWZpY2F0aW9ucy9zcmMvbGliL2NyZWF0ZS10ZW1wbGF0ZS1ub3RpZmllci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsSUFBSSxFQUNKLFlBQVksRUFDWixLQUFLLEVBR0wsRUFBRSxFQUNGLGFBQWEsRUFDZCxNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsTUFBTSxFQUNOLEdBQUcsRUFDSCxTQUFTLEVBQ1QsU0FBUyxHQUNWLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEIsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRWpELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRXJFLE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxlQUErQixFQUFXLEVBQUUsQ0FBQyxlQUFlLElBQUksZUFBZSxFQUFFLENBQUM7O0FBRS9HOzs7OztHQUtHO0FBQ0gsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzs7QUFDcEU7Ozs7OztFQU1FO0FBQ0YsTUFBTSxRQUFRLEdBQUcsQ0FBSSxjQUFtQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQWlCLEVBQWlCLEVBQUU7SUFDaEcsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDO0lBQ3BCLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FDWixHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtRQUNaLElBQUcsQ0FBQyxRQUFRLEVBQUU7WUFDWixPQUFPLEtBQUssQ0FBQztTQUNkO1FBQ0QsTUFBTSxNQUFNLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JDLFFB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WUFDWCwwRUFBMEU7WUFDMUUsT0FBTyxtQkFBbUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUN2QztRQUVELDJDQUEyQztRQUMzQyxJQUFJLGFBQWEsRUFBRTtZQUNqQiwwRUFBMEU7WUFDMUUsT0FBTyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUN6QztRQUVELE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FDM0IsQ0FBQyxFQUFFLEVBQUUsRUFBRTtZQUNMLGtEQUFrRDtZQUNsRCxNQUFNLHVCQUF1QixHQUFHLG1CQUFtQixDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBRXJFLElBQUksdUJBQXVCLEVBQUU7Z0JBQzNCLDJCQUEyQjtnQkFDM0IsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2FBQ3RDO1lBQ0QsT0FBTyxFQUFFLENBQUM7UUFDWixDQUFDLENBQ0YsQ0FBQztJQUNKLENBQUMsQ0FBQyxFQUNGLFNBQVMsQ0FBQyxDQUFDLENBQWdCLEVBQUUsRUFBRTtRQUM3QixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQ1gsb0JBQW9CLEVBQUUsRUFDdEIsYUFBYSxFQUFFLEVBQ2YsR0FBRyxDQUFDLHlDQUF5QyxFQUFLLENBQUMsQ0FDcEQsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUNILENBQUM7SUFFRixPQUFPO1FBQ0wsSUFBSSxDQUFDLFVBQThCO1lBQ2pDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN0QyxDQUFDO1FBQ0QsT0FBTztLQUNSLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBmcm9tLFxyXG4gIGlzT2JzZXJ2YWJsZSxcclxuICBORVZFUixcclxuICBPYnNlcnZhYmxlLFxyXG4gIE9ic2VydmFibGVJbnB1dCxcclxuICBvZixcclxuICBSZXBsYXlTdWJqZWN0XHJcbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7XHJcbiAgZGlzdGluY3RVbnRpbENoYW5nZWQsXHJcbiAgZmlsdGVyLFxyXG4gIG1hcCxcclxuICBzdGFydFdpdGgsXHJcbiAgc3dpdGNoTWFwLFxyXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IHJ4TWF0ZXJpYWxpemUgfSBmcm9tICcuL3J4LW1hdGVyaWFsaXplJztcclxuaW1wb3J0IHsgUnhOb3RpZmljYXRpb24sIFJ4Tm90aWZpY2F0aW9uS2luZCB9IGZyb20gJy4vbW9kZWwnO1xyXG5pbXBvcnQgeyB0b1J4U3VzcGVuc2VOb3RpZmljYXRpb24gfSBmcm9tICcuL25vdGlmaWNhdGlvbi10cmFuc2Zvcm1zJztcclxuXHJcbmNvbnN0IGNhbGNXaXRoU3VzcGVuc2VUcGwgPSAod2l0aFN1c3BlbnNlVHBsPzogKCkgPT4gYm9vbGVhbik6IGJvb2xlYW4gPT4gd2l0aFN1c3BlbnNlVHBsICYmIHdpdGhTdXNwZW5zZVRwbCgpO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTZW5kcyB2YWx1ZSBhbmQgYW4gaW5pdGlhbCBgdW5kZWZpbmVkYCBhcyB2YWx1ZSBXaXRoIGEgTkVWRVIuXHJcbiAqIFRoaXMgaXMgbmVlZGVkIHRvIHJlbmRlciB0aGUgc3VzcGVuc2UgdGVtcGxhdGUgYW5kIGF2b2lkIGNvbXBsZXRpbmcgKGFuZCByZW5kZXIgdGhlIGNvbXBsZXRlIHRlbXBsYXRlKS5cclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xyXG5jb25zdCBlbWl0QW5kRG9udENvbXBsZXRlID0gKHZhbHVlKSA9PiBORVZFUi5waXBlKHN0YXJ0V2l0aCh2YWx1ZSkpO1xyXG4vKipcclxuKiBAZGVzY3JpcHRpb25cclxuKiBGbGFncyB0aGUgZmlyc3QgcnVuLlxyXG4qIFRoaXMgaXMgaW1wb3J0YW50IGFzIHdlIHdhbnQgdG8gY3JlYXRlIGxhemluZXNzIGluIHRoZSB0ZW1wbGF0ZS5cclxuKiBJZiBubyB2YWx1ZSBldmVyIGlzIGVtaXR0ZWQgd2UgZG9udCB3YW50IHRvIGNyZWF0ZS9yZW5kZXIgdGhlIHZhbHVlIChuZXh0IHRlbXBsYXRlKS5cclxuKiBJbiBjYXNlIGEgc3VzcGVuc2UgdGVtcGxhdGUgaXMgZ2l2ZW4gKGNhbGN1bGF0ZWQgYnkgYHdpdGhTdXNwZW5zZWAgcGFyYW0pIHdlIHJlbmRlciB0aGUgc3VzcGVuc2UgdGVtcGxhdGUgb24gdGhlIGZpcnN0IHJ1bi5cclxuKi9cclxuY29uc3QgbWFwRmlyc3QgPSA8VD4odHJhbnNmb3JtYXRpb246ICh2YWx1ZTogYW55KSA9PiBhbnkpID0+IChvJDogT2JzZXJ2YWJsZTxUPik6IE9ic2VydmFibGU8VD4gPT4ge1xyXG4gIGxldCBmaXJzdFJ1biA9IHRydWU7XHJcbiAgcmV0dXJuIG8kLnBpcGUoXHJcbiAgICBtYXAoKHZhbHVlKSA9PiB7XHJcbiAgICAgIGlmKCFmaXJzdFJ1bikge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCByZXN1bHQgPSB0cmFuc2Zvcm1hdGlvbih2YWx1ZSk7XHJcbiAgICAgIGZpcnN0UnVuID0gZmFsc2U7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9KVxyXG4gIClcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaGVscGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0dXJuaW5nIGEgc3RyZWFtIG9mIG1hdGVyaWFsaXplZCBub3RpZmljYXRpb25zXHJcbiAqIChuZXh0IGVycm9yLCBjb21wbGV0ZSBhcyBvYmplY3QgaW4gdGhlIG5leHQgc3RyZWFtKSBpbnRvIGFuIGVucmljaGVkIHZlcnNpb24gd2l0aCBhbiBhZGRpdGlvbmFsIHN1c3BlbnNlIG5vdGlmaWNhdGlvbiB0eXBlLlxyXG4gKlxyXG4gKiBJZiBhIG5vdGlmaWNhdGlvbiBlbnRlcnMgYW5kIGlzIG9mIHR5cGUgbmV4dCB3ZSBzdG9yZSB0bmUgdmFsdWUgb2YgYG5vdGlmaWNhdGlvbi5uZXh0YCBhcyBsYXN0IHZhbHVlIGVtaXR0ZWQuXHJcbiAqIFRoaXMgdmFsdWUgaXMgaW1wb3J0YW50IGluIHRoZSB0ZW1wbGF0ZSB0byBzaG93IGFuIGUuZy4gZXJyb3IgYW5kIGFsc28gaGF2ZSBhY2Nlc3MgdG8gdGhlIGxhc3QgZW1pdHRlZCB2YWx1ZSBvZiBuZXh0LlxyXG4gKiBUaGUgdmFsdWUgY2FuIGJlIHZlcnkgdXNlZnVsIGluIGVycm9yIG9yIGNvbXBsZXRlIG1lc3NhZ2VzIG9yIHRvIGRpc3BsYXkgdGhlIG9sZCB2YWx1ZSBvdmVybGF5cyBieSBhIGxvYWRpbmcgc3Bpbm5lciBpbiBjYXNlIG9mIHRoZSBzdXNwZW5zZSBzdGF0ZS5cclxuICpcclxuICogSWYgYSBub3RpZmljYXRpb24gb2Yga2luZCBgbmV4dGAgZW50ZXJzIGFuZCBpdHMgdmFsdWUgaXMgdW5kZWZpbmVkIHdlIHR1cm4gaXQgaW50byBhIHN1c3BlbnNlIG5vdGlmaWNhdGlvblxyXG4gKiBJZiBhIG5vdGlmaWNhdGlvbiBvZiBraW5kIGBlcnJvcmAsIGBjb21wbGV0ZWAsIGBzdXNwZW5zZWAgZW50ZXJzIHdlIHRha2UgdGhlIGxhc3QgdmFsdWUgZnJvbSBvZiBhIG5leHQgbm90aWZpY2F0aW9uXHJcbiAqIGFuZCBhc3NpZ24gaXQgYXMgbmV3IHZhbHVlIHRvIHRoZSBub3RpZmljYXRpb25cclxuICovXHJcbmNvbnN0IGhhbmRsZVN1c3BlbnNlQW5kTGFzdFZhbHVlSW5Ob3RpZmljYXRpb25zID0gPFQ+KCkgPT4ge1xyXG4gIC8vIFVzZWQgdG8gc3RvcmUgdGhlIGxhc3QgdmFsdWUgcGVyIGhhbmRsZVN1c3BlbnNlQW5kTGFzdFZhbHVlSW5Ob3RpZmljYXRpb25zIGNhbGxcclxuICBsZXQgIGxhdGVzdE5leHRWYWx1ZTogVDtcclxuXHJcbiAgLy8gcmV0dXJucyBhIHByb2plY3Rpb24gZnVuY3Rpb24gd2l0aCBhIGxhc3RWYWx1ZSBjYWNoZVxyXG4gIHJldHVybiAobm90aWZpY2F0aW9uOiBSeE5vdGlmaWNhdGlvbjxUPik6IFJ4Tm90aWZpY2F0aW9uPFQ+ID0+IHtcclxuICAgIC8vIGlmIGl0IHRoZSBub3RpZmljYXRpb24gaXMgb2YgdHlwZSBuZXh0IHdlIHRha2UgaXRzIHZhbHVlXHJcbiAgICAvLyBvdGhlcndpc2Ugd2Uga2VlcCB0aGUgZXhpc3RpbmcgbGFzdCB2YWx1ZVxyXG4gICAgaWYobm90aWZpY2F0aW9uLmtpbmQgPT09IFJ4Tm90aWZpY2F0aW9uS2luZC5OZXh0KSB7XHJcbiAgICAgIGxhdGVzdE5leHRWYWx1ZSA9IG5vdGlmaWNhdGlvbi52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBhIG5leHQgbm90aWZpY2F0aW9uIGVudGVycyB3aXRoIGEgdmFsdWUgb2YgdW5kZWZpbmVkIHdlIHR1cm4gaXQgaW50byBhIHN1c3BlbnNlIG5vdGlmaWNhdGlvblxyXG4gICAgaWYgKFxyXG4gICAgICBub3RpZmljYXRpb24ua2luZCA9PT0gUnhOb3RpZmljYXRpb25LaW5kLk5leHQgJiZcclxuICAgICAgbm90aWZpY2F0aW9uLnZhbHVlID09PSB1bmRlZmluZWRcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gdG9SeFN1c3BlbnNlTm90aWZpY2F0aW9uKHVuZGVmaW5lZCkgYXMgUnhOb3RpZmljYXRpb248VD47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgYSBOb3RpZmljYXRpb24gb2YgdHlwZSBlcnJvciwgY29tcGxldGUgb3Igc3VzcGVuc2UgZW50ZXJzIHdlIGFzc2lnbiB0aGUgbGF0ZXN0IGxhc3QgdmFsdWUgdG8gdGhlbS5cclxuICAgIC8vIFRoaXMgaXMgbmVlZGVkIHRvIGFjY2VzcyB0aGUgb2xkIHZhbHVlIGluIGNhc2Ugb2YgZXJyb3Igb3IgY29tcGxldGUuXHJcbiAgICAvLyBOZXh0IG5vdGlmaWNhdGlvbnMgd2lsbCBwYXNzIGFzIHRoZXkgYXJlLlxyXG4gICAgaWYoXHJcbiAgICAgIG5vdGlmaWNhdGlvbi5raW5kID09PSBSeE5vdGlmaWNhdGlvbktpbmQuRXJyb3IgfHxcclxuICAgICAgbm90aWZpY2F0aW9uLmtpbmQgPT09IFJ4Tm90aWZpY2F0aW9uS2luZC5Db21wbGV0ZSB8fFxyXG4gICAgICBub3RpZmljYXRpb24ua2luZCA9PT0gUnhOb3RpZmljYXRpb25LaW5kLlN1c3BlbnNlKSB7XHJcbiAgICAgIG5vdGlmaWNhdGlvbi52YWx1ZSA9IGxhdGVzdE5leHRWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbm90aWZpY2F0aW9uIGFzIFJ4Tm90aWZpY2F0aW9uPFQ+O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhpcyBmYWN0b3J5IGZ1bmN0aW9uIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIGRyaXZlbiBpbXBlcmF0aXZlbHkgb3ZlciBhIGBuZXh0YCBtZXRob2QuXHJcbiAqIEludGVybmFsbHkgaXQgcHJlcGFyZXMgdGhlIGluY29taW5nIHZhbHVlcyBmb3IgcmVuZGVyaW5nIGJ5IHR1cm5pbmcgdGhlbSBpbnRvIFwidGVtcGxhdGUgbm90aWZpY2F0aW9uc1wiLFxyXG4gKiBhbiBleHRlbmRlZCBgT2JzZXJ2YWJsZU5vdGlmaWNhdGlvbmAgb2JqZWN0IHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSByZXNwZWN0aXZlIHRlbXBsYXRlIGZvciB2YWx1ZXMsIGVycm9ycywgY29tcGxldGluZyBvciBzdXNwZW5zZSBzdGF0ZXMuXHJcbiAqXHJcbiAqIEludGVybmFsbHkgaXQgaGFuZGxlcyBkaWZmZXJlbnQgZWRnZSBjYXNlcyBmb3IgaW5pdGlhbCBlbWl0cy4gVGhpcyBoZWxwcyB0byBoYXZlIG9yIHRlbXBsYXRlIGNyZWF0aW9uIGxhenkuXHJcbiAqIEFsc28gaXQgbWFwcyBhbnkgT2JzZXJ2YWJsZSB0byBSeE5vdGlmaWNhdGlvbnMuIFRoZXNlIG5vdGlmaWNhdGlvbnMgYXJlIGJvdW5kIHRvIHRoZSB2aWV3IGxhdGVyIGFuZCBoYW5kbGUgdGhlIGRpc3BsYXkgb2ZcclxuICogdGhlIGRlZmF1bHQgdGVtcGxhdGUgYXMgd2VsbCBhcyB0aGUgc3VzcGVuc2UsIGVycm9yLCBjb21wbGV0ZSB0ZW1wbGF0ZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVOb3RpZmllcjxVPih3aXRoU3VzcGVuc2VUcGw/OiAoKSA9PiBib29sZWFuKToge1xyXG4gIHZhbHVlcyQ6IE9ic2VydmFibGU8UnhOb3RpZmljYXRpb248VT4+O1xyXG4gIG5leHQob2JzZXJ2YWJsZTogT2JzZXJ2YWJsZUlucHV0PFU+IHwgVSk6IHZvaWQ7XHJcbn0ge1xyXG4gIC8vIEEgU3ViamVjdCBkcml2ZW4gZnJvbSB0aGUgb3V0c2lkZSwgaXQgY2FuIGNvbnRhaW4gT2JzZXJ2YWJsZXMsIHN0YXRpYyB2YWx1ZXMgbnVsbCBhbmQgdW5kZWZpbmVkIG9uIHB1cnBvc2Ugb2YgZnJvbSB1bmFzc2lnbmVkIHByb3BlcnRpZXNcclxuICBjb25zdCBvYnNlcnZhYmxlc1N1YmplY3QgPSBuZXcgUmVwbGF5U3ViamVjdDxPYnNlcnZhYmxlSW5wdXQ8VT4+KDEpO1xyXG5cclxuXHJcbiAgY29uc3QgdmFsdWVzJCA9IG9ic2VydmFibGVzU3ViamVjdC5waXBlKFxyXG4gICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcclxuICAgIC8vIEhhbmRsZSBpbml0aWFsaXphdGlvbiBlZGdlIGNhc2VzXHJcbiAgICBtYXBGaXJzdCgodmFsdWUpID0+IHtcclxuXHJcbiAgICAgIGNvbnN0IGlzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBpc05FVkVSID0gdmFsdWUgPT09IE5FVkVSO1xyXG4gICAgICAgIC8vIElmIGl0IGlzIGEgYE5FVkVSYCBPYnNlcnZhYmxlIHdlIGtub3cgaXQgd2lsbCBuZXZlciBlbWl0IGEgdmFsdWUgbm9yIGNvbXBsZXRlIG9yIGVycm9yLlxyXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBlbWl0IGRpcmVjdGx5IHVuZGVmaW5lZCB0byBzaWduYWwgYSBzdXNwZW5zZSBzdGF0ZVxyXG5cclxuICAgICAgaWYoKGlzVW5kZWZpbmVkIHx8IGlzTkVWRVIpKSB7XHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lcyBpZiBhIHN1c3BlbnNlIG5vdGlmaWNhdGlvbiBpcyBuZWVkZWRcclxuICAgICAgICBjb25zdCBpc1N1c3BlbnNlVGVtcGxhdGVHaXZlbiA9IGNhbGNXaXRoU3VzcGVuc2VUcGwod2l0aFN1c3BlbnNlVHBsKTtcclxuXHJcbiAgICAgICAgLy8gUmVuZGVyIHN1c3BlbnNlIHRlbXBsYXRlIGlmIGdpdmVuLiBPdGhlcndpc2UgZG8gbm90aGluZyAobGF0ZXIgdW5kZWZpbmVkIGFyZSBmaWx0ZXJlZCBvdXQpXHJcbiAgICAgICAgcmV0dXJuIGlzU3VzcGVuc2VUZW1wbGF0ZUdpdmVuID8gZW1pdEFuZERvbnRDb21wbGV0ZSh1bmRlZmluZWQpIDogdW5kZWZpbmVkXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGlzTnVsbCA9IHZhbHVlID09PSBudWxsO1xyXG5cclxuICAgICAgaWYgKGlzTnVsbCkge1xyXG4gICAgICAgIC8vIFdlIHJldHVybiB0aGUgdmFsdWUgYW5kIG5vIHVuZGVmaW5lZCBhcyBmaXJzdCB2YWx1ZVxyXG4gICAgICAgIC8vIGFzIHdlIGRvbnQgbmVlZCB0byByZW5kZXIgdGhlIHN1c3BlbnNlIHRlbXBsYXRlIGZvciBudWxsIHZhbHVlcyAoaXQgaXMgY29uc2lkZXJlZCBhcyBub3QgdXNlZClcclxuICAgICAgICByZXR1cm4gb2YobnVsbCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0pLFxyXG4gICAgLy8gYHVuZGVmaW5lZGAgdmFsdWVzIGFyZSBvbmx5IHByb2Nlc3NlZCBvbmNlIGF0IGJlZ2lubmluZyB0byBpbml0aWFsaXplIGxhenkuIEFmdGVyIHRoYXQgdGhleSBhcmUgZmlsdGVyZWQgb3V0LlxyXG4gICAgZmlsdGVyKCh2KSA9PiB2ICE9PSB1bmRlZmluZWQpLFxyXG4gICAgLy8gaGFuZGxlIHN0YXRpYyB2YWx1ZXMgaW5jIG51bGwgYXNzaWdubWVudCBhbmQgbmV3IE9ic2VydmFibGUgb3IgUHJvbWlzZXNcclxuICAgIG1hcCgob2JzZXJ2YWJsZSQpOiBPYnNlcnZhYmxlPE9ic2VydmFibGVJbnB1dDxVPiB8IFU+ID0+IHtcclxuICAgICAgY29uc3QgaXNOdWxsID0gb2JzZXJ2YWJsZSQgPT09IG51bGw7XHJcbiAgICAgIGNvbnN0IGlzUHJvbWlzZU9yT2JzID0gdHlwZW9mIChvYnNlcnZhYmxlJCBhcyBhbnkpLnRoZW4gPT09ICdmdW5jdGlvbicgfHwgaXNPYnNlcnZhYmxlKG9ic2VydmFibGUkKTtcclxuICAgICAgLy8gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFzIHN0YXRpYyB2YWx1ZSBpZiBpdCBpcyBgbnVsbGAsIG9yIGFueSBvdGhlciB2YWx1ZSB0aGFuIGB1bmRlZmluZWRgLCBgUHJvbWlzZWAsIGBPYnNlcnZhYmxlYFxyXG4gICAgICBjb25zdCBpc1N0YXRpY1ZhbHVlID0gIWlzUHJvbWlzZU9yT2JzICYmICEob2JzZXJ2YWJsZSQgPT09IHVuZGVmaW5lZCkgfHwgaXNOdWxsO1xyXG5cclxuICAgICAgY29uc3QgaXNORVZFUiA9IG9ic2VydmFibGUkID09PSBORVZFUjtcclxuICAgICAgLy8gSWYgaXQgaXMgYSBgTkVWRVJgIE9ic2VydmFibGUgd2Uga25vdyBpdCB3aWxsIG5ldmVyIGVtaXQgYSB2YWx1ZSBub3IgY29tcGxldGUgb3IgZXJyb3IuXHJcbiAgICAgIC8vIFRoZXJlZm9yZSB3ZSBlbWl0IGRpcmVjdGx5IHVuZGVmaW5lZCB0byBzaWduYWwgYSBzdXNwZW5zZSBzdGF0ZVxyXG4gICAgICBpZiAoaXNORVZFUikge1xyXG4gICAgICAgIC8vIFJlbmRlciBzdXNwZW5zZSB0ZW1wbGF0ZSBmb3IgbnVsbCB2YWx1ZXMgKGl0IGlzIGNvbnNpZGVyZWQgYXMgbm90IHVzZWQpXHJcbiAgICAgICAgcmV0dXJuIGVtaXRBbmREb250Q29tcGxldGUodW5kZWZpbmVkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgaXQgaXMgYSBzdGF0aWMgdmFsdWUgZm9yd2FyZCBkaXJlY3RseVxyXG4gICAgICBpZiAoaXNTdGF0aWNWYWx1ZSkge1xyXG4gICAgICAgIC8vIFJlbmRlciBuZXh0IHRlbXBsYXRlIGZvciBzdGF0aWMgdmFsdWVzIChpdCBpcyBjb25zaWRlcmVkIGFzIGtpbmRhIHN5bmMpXHJcbiAgICAgICAgcmV0dXJuIGVtaXRBbmREb250Q29tcGxldGUob2JzZXJ2YWJsZSQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZnJvbShvYnNlcnZhYmxlJCkucGlwZShcclxuICAgICAgICAobyQpID0+IHtcclxuICAgICAgICAgIC8vIERldGVybWluZXMgaWYgYSBzdXNwZW5zZSBub3RpZmljYXRpb24gaXMgbmVlZGVkXHJcbiAgICAgICAgICBjb25zdCBpc1N1c3BlbnNlVGVtcGxhdGVHaXZlbiA9IGNhbGNXaXRoU3VzcGVuc2VUcGwod2l0aFN1c3BlbnNlVHBsKTtcclxuXHJcbiAgICAgICAgICBpZiAoaXNTdXNwZW5zZVRlbXBsYXRlR2l2ZW4pIHtcclxuICAgICAgICAgICAgLy8gUmVuZGVyIHN1c3BlbnNlIHRlbXBsYXRlXHJcbiAgICAgICAgICAgIHJldHVybiBvJC5waXBlKHN0YXJ0V2l0aCh1bmRlZmluZWQpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBvJDtcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcbiAgICB9KSxcclxuICAgIHN3aXRjaE1hcCgobzogT2JzZXJ2YWJsZTxVPikgPT4ge1xyXG4gICAgICByZXR1cm4gby5waXBlKFxyXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXHJcbiAgICAgICAgcnhNYXRlcmlhbGl6ZSgpLFxyXG4gICAgICAgIG1hcChoYW5kbGVTdXNwZW5zZUFuZExhc3RWYWx1ZUluTm90aWZpY2F0aW9uczxVPigpKVxyXG4gICAgICApO1xyXG4gICAgfSlcclxuICApO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmV4dChvYnNlcnZhYmxlOiBPYnNlcnZhYmxlSW5wdXQ8VT4pIHtcclxuICAgICAgb2JzZXJ2YWJsZXNTdWJqZWN0Lm5leHQob2JzZXJ2YWJsZSk7XHJcbiAgICB9LFxyXG4gICAgdmFsdWVzJCxcclxuICB9O1xyXG59XHJcbiJdfQ==