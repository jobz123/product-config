import { coalesceWith } from '@rx-angular/cdk/coalescing';
import { Promise } from '@rx-angular/cdk/zone-less';
import { combineLatest, from } from 'rxjs';
import { distinctUntilChanged, filter, map, shareReplay } from 'rxjs/operators';
const resolvedPromise = Promise.resolve();
const resolvedPromise$ = from(resolvedPromise);
/**
 * @internal
 *
 * Used for typing
 */
function getEntriesToObjectReducerFn(keys) {
    return (accumulator, currentValue, currentIndex) => {
        return Object.assign(Object.assign({}, accumulator), { [keys[currentIndex]]: currentValue });
    };
}
/**
 * This Observable creation function helps to accumulate an object of key & Observable of values to
 * an Observable of objects of key & value.
 * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.
 *
 * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.
 *
 * @example
 *
 * Default usage:
 *
 * const object$: Observable<{
 *   prop1: number,
 *   prop2: string,
 *   prop3: string
 * }> = accumulateObservables({
 *   prop1: interval(42),
 *   prop2: of('lorem'),
 *   prop3: 'test'
 * });
 *
 * Usage with custom duration selector:
 *
 * const object$: Observable<{
 *   prop1: number,
 *   prop2: string,
 *   prop3: string
 * }> = accumulateObservables({
 *   prop1: interval(42),
 *   prop2: of('lorem'),
 *   prop3: 'test'
 * }, timer(0, 20));
 *
 * @param obj - An object of key & Observable values pairs
 * @param durationSelector - An Observable determining the duration for the internal coalescing method
 */
export function accumulateObservables(
// @TODO type static or Observable to enable mixing of imperative and reatctive values
obj, durationSelector = resolvedPromise$) {
    const keys = Object.keys(obj);
    // @TODO better typing to enable static values => coerceObservable(obj[key])
    const observables = keys.map((key) => obj[key].pipe(
    // we avoid using the nullish operator later ;)
    filter((v) => v !== undefined), 
    // state "changes" differ from each other, this operator ensures distinct values
    distinctUntilChanged()));
    return combineLatest(observables).pipe(
    // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions
    // together
    coalesceWith(durationSelector), 
    // mapping array of values to object
    map((values) => values.reduce(getEntriesToObjectReducerFn(keys), {})), 
    // by using shareReplay we share the last composition work done to create the accumulated object
    shareReplay(1));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjdW11bGF0ZU9ic2VydmFibGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9jZGsvc3RhdGUvc3JjL2xpYi9hY2N1bXVsYXRlT2JzZXJ2YWJsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzFELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsYUFBYSxFQUFFLElBQUksRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUN2RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUdoRixNQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDMUMsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7QUFFL0M7Ozs7R0FJRztBQUNILFNBQVMsMkJBQTJCLENBQ2xDLElBQW1CO0lBRW5CLE9BQU8sQ0FDTCxXQUFjLEVBQ2QsWUFBMEIsRUFDMUIsWUFBcUIsRUFDbEIsRUFBRTtRQUNMLHVDQUNLLFdBQVcsS0FDZCxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLFlBQVksSUFDbEM7SUFDSixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUNHO0FBQ0gsTUFBTSxVQUFVLHFCQUFxQjtBQUNuQyxzRkFBc0Y7QUFDdEYsR0FBTSxFQUNOLG1CQUFvQyxnQkFBZ0I7SUFFcEQsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQWdCLENBQUM7SUFDN0MsNEVBQTRFO0lBQzVFLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUNuQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSTtJQUNYLCtDQUErQztJQUMvQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUM7SUFDOUIsZ0ZBQWdGO0lBQ2hGLG9CQUFvQixFQUFFLENBQ3ZCLENBQ0YsQ0FBQztJQUNGLE9BQU8sYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUk7SUFDcEMsNEdBQTRHO0lBQzVHLFdBQVc7SUFDWCxZQUFZLENBQUMsZ0JBQWdCLENBQUM7SUFDOUIsb0NBQW9DO0lBQ3BDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQ2IsTUFBTSxDQUFDLE1BQU0sQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFTLENBQUMsQ0FDNUQ7SUFDRCxnR0FBZ0c7SUFDaEcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUNmLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29hbGVzY2VXaXRoIH0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL2NvYWxlc2NpbmcnO1xyXG5pbXBvcnQgeyBQcm9taXNlIH0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL3pvbmUtbGVzcyc7XHJcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QsIGZyb20sIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIGZpbHRlciwgbWFwLCBzaGFyZVJlcGxheSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgQXJyYXlSZWR1Y2VyRm4sIEV4dHJhY3RPYnNlcnZhYmxlVmFsdWUsIE5vdEVtcHR5LCBPYnNlcnZhYmxlTWFwLCBQcm9wTmFtZSwgUHJvcFR5cGUgfSBmcm9tICcuL21vZGVsJztcclxuXHJcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5jb25zdCByZXNvbHZlZFByb21pc2UkID0gZnJvbShyZXNvbHZlZFByb21pc2UpO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKlxyXG4gKiBVc2VkIGZvciB0eXBpbmdcclxuICovXHJcbmZ1bmN0aW9uIGdldEVudHJpZXNUb09iamVjdFJlZHVjZXJGbjxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4oXHJcbiAga2V5czogUHJvcE5hbWU8VD5bXVxyXG4pOiBBcnJheVJlZHVjZXJGbjxUPiB7XHJcbiAgcmV0dXJuIChcclxuICAgIGFjY3VtdWxhdG9yOiBULFxyXG4gICAgY3VycmVudFZhbHVlPzogUHJvcFR5cGU8VD4sXHJcbiAgICBjdXJyZW50SW5kZXg/OiBudW1iZXJcclxuICApOiBUID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLmFjY3VtdWxhdG9yLFxyXG4gICAgICBba2V5c1tjdXJyZW50SW5kZXhdXTogY3VycmVudFZhbHVlXHJcbiAgICB9O1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIE9ic2VydmFibGUgY3JlYXRpb24gZnVuY3Rpb24gaGVscHMgdG8gYWNjdW11bGF0ZSBhbiBvYmplY3Qgb2Yga2V5ICYgT2JzZXJ2YWJsZSBvZiB2YWx1ZXMgdG9cclxuICogYW4gT2JzZXJ2YWJsZSBvZiBvYmplY3RzIG9mIGtleSAmIHZhbHVlLlxyXG4gKiBUaGlzIGNvbWVzIGluIGhhbmR5IGlmIHlvdSBxdWlja2x5IHdhbnQgdG8gY3JlYXRlIHN1YnNldHMgYXMgb2JqZWN0cy9zdGF0ZS1zbGljZXMgb2YgZGlmZmVyZW50IE9ic2VydmFibGVzLlxyXG4gKlxyXG4gKiBUaGUgcmVzdWx0aW5nIE9ic2VydmFibGUgZmlsdGVycyBvdXQgdW5kZWZpbmVkIHZhbHVlcyBmb3J3YXJkcyBvbmx5IGRpc3RpbmN0IHZhbHVlcyBhbmQgc2hhcmVkIHRoZSBhZ2dyZWdhdGVkIG91dHB1dC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogRGVmYXVsdCB1c2FnZTpcclxuICpcclxuICogY29uc3Qgb2JqZWN0JDogT2JzZXJ2YWJsZTx7XHJcbiAqICAgcHJvcDE6IG51bWJlcixcclxuICogICBwcm9wMjogc3RyaW5nLFxyXG4gKiAgIHByb3AzOiBzdHJpbmdcclxuICogfT4gPSBhY2N1bXVsYXRlT2JzZXJ2YWJsZXMoe1xyXG4gKiAgIHByb3AxOiBpbnRlcnZhbCg0MiksXHJcbiAqICAgcHJvcDI6IG9mKCdsb3JlbScpLFxyXG4gKiAgIHByb3AzOiAndGVzdCdcclxuICogfSk7XHJcbiAqXHJcbiAqIFVzYWdlIHdpdGggY3VzdG9tIGR1cmF0aW9uIHNlbGVjdG9yOlxyXG4gKlxyXG4gKiBjb25zdCBvYmplY3QkOiBPYnNlcnZhYmxlPHtcclxuICogICBwcm9wMTogbnVtYmVyLFxyXG4gKiAgIHByb3AyOiBzdHJpbmcsXHJcbiAqICAgcHJvcDM6IHN0cmluZ1xyXG4gKiB9PiA9IGFjY3VtdWxhdGVPYnNlcnZhYmxlcyh7XHJcbiAqICAgcHJvcDE6IGludGVydmFsKDQyKSxcclxuICogICBwcm9wMjogb2YoJ2xvcmVtJyksXHJcbiAqICAgcHJvcDM6ICd0ZXN0J1xyXG4gKiB9LCB0aW1lcigwLCAyMCkpO1xyXG4gKlxyXG4gKiBAcGFyYW0gb2JqIC0gQW4gb2JqZWN0IG9mIGtleSAmIE9ic2VydmFibGUgdmFsdWVzIHBhaXJzXHJcbiAqIEBwYXJhbSBkdXJhdGlvblNlbGVjdG9yIC0gQW4gT2JzZXJ2YWJsZSBkZXRlcm1pbmluZyB0aGUgZHVyYXRpb24gZm9yIHRoZSBpbnRlcm5hbCBjb2FsZXNjaW5nIG1ldGhvZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFjY3VtdWxhdGVPYnNlcnZhYmxlczxUIGV4dGVuZHMgT2JzZXJ2YWJsZU1hcCAmIE5vdEVtcHR5PFQ+PihcclxuICAvLyBAVE9ETyB0eXBlIHN0YXRpYyBvciBPYnNlcnZhYmxlIHRvIGVuYWJsZSBtaXhpbmcgb2YgaW1wZXJhdGl2ZSBhbmQgcmVhdGN0aXZlIHZhbHVlc1xyXG4gIG9iajogVCxcclxuICBkdXJhdGlvblNlbGVjdG9yOiBPYnNlcnZhYmxlPGFueT4gPSByZXNvbHZlZFByb21pc2UkXHJcbik6IE9ic2VydmFibGU8eyBbSyBpbiBrZXlvZiBUXTogRXh0cmFjdE9ic2VydmFibGVWYWx1ZTxUW0tdPiB9PiB7XHJcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaikgYXMgKGtleW9mIFQpW107XHJcbiAgLy8gQFRPRE8gYmV0dGVyIHR5cGluZyB0byBlbmFibGUgc3RhdGljIHZhbHVlcyA9PiBjb2VyY2VPYnNlcnZhYmxlKG9ialtrZXldKVxyXG4gIGNvbnN0IG9ic2VydmFibGVzID0ga2V5cy5tYXAoKGtleSkgPT5cclxuICAgIG9ialtrZXldLnBpcGUoXHJcbiAgICAgIC8vIHdlIGF2b2lkIHVzaW5nIHRoZSBudWxsaXNoIG9wZXJhdG9yIGxhdGVyIDspXHJcbiAgICAgIGZpbHRlcigodikgPT4gdiAhPT0gdW5kZWZpbmVkKSxcclxuICAgICAgLy8gc3RhdGUgXCJjaGFuZ2VzXCIgZGlmZmVyIGZyb20gZWFjaCBvdGhlciwgdGhpcyBvcGVyYXRvciBlbnN1cmVzIGRpc3RpbmN0IHZhbHVlc1xyXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXHJcbiAgICApXHJcbiAgKTtcclxuICByZXR1cm4gY29tYmluZUxhdGVzdChvYnNlcnZhYmxlcykucGlwZShcclxuICAgIC8vIEFzIGNvbWJpbmVMYXRlc3Qgd2lsbCBlbWl0IG11bHRpcGxlIHRpbWVzIGZvciBhIGNoYW5nZSBpbiBtdWx0aXBsZSBwcm9wZXJ0aWVzIHdlIGNvYWxlc2NlIHRob3NlIGVtaXNzaW9uc1xyXG4gICAgLy8gdG9nZXRoZXJcclxuICAgIGNvYWxlc2NlV2l0aChkdXJhdGlvblNlbGVjdG9yKSxcclxuICAgIC8vIG1hcHBpbmcgYXJyYXkgb2YgdmFsdWVzIHRvIG9iamVjdFxyXG4gICAgbWFwKCh2YWx1ZXMpID0+XHJcbiAgICAgIHZhbHVlcy5yZWR1Y2UoZ2V0RW50cmllc1RvT2JqZWN0UmVkdWNlckZuKGtleXMpLCB7fSBhcyBhbnkpXHJcbiAgICApLFxyXG4gICAgLy8gYnkgdXNpbmcgc2hhcmVSZXBsYXkgd2Ugc2hhcmUgdGhlIGxhc3QgY29tcG9zaXRpb24gd29yayBkb25lIHRvIGNyZWF0ZSB0aGUgYWNjdW11bGF0ZWQgb2JqZWN0XHJcbiAgICBzaGFyZVJlcGxheSgxKVxyXG4gICk7XHJcbn1cclxuIl19