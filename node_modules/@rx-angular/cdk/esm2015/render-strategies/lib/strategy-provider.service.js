import { Inject, Injectable, Optional, } from '@angular/core';
import { BehaviorSubject, fromEvent, } from 'rxjs';
import { map, shareReplay, switchMap, takeUntil } from 'rxjs/operators';
import { mergeDefaultConfig, RX_ANGULAR_CONFIG } from './config';
import { onStrategy } from './onStrategy';
import * as i0 from "@angular/core";
import * as i1 from "./config";
/**
 * @description
 * RxStrategyProvider is a wrapper service that you can use to consume strategies and schedule your code execution.
 *
 * @example
 * Component({
 *   selector: 'app-service-communicator',
 *   template: ``
 * });
 * export class ServiceCommunicationComponent {
 *   private currentUserSettings;
 *
 *   constructor(
 *     private strategyProvider: RxStrategyProvider,
 *     private userService: UserService,
 *     private backgroundSync: BackgroundSyncService
 *   ) {
 *     this.userService.fetchCurrentUserSettings
 *       .pipe(
 *         tap(settings => (this.currentUserSettings = settings)),
 *         this.strategyProvider.scheduleWith(
 *           settings => this.backgroundSync.openConnection(settings),
 *           { strategy: 'idle' }
 *         )
 *       )
 *       .subscribe();
 *   }
 * }
 *
 * @docsCategory RxStrategyProvider
 * @docsPage RxStrategyProvider
 */
export class RxStrategyProvider {
    /**
     * @internal
     */
    constructor(cfg) {
        this._strategies$ = new BehaviorSubject(undefined);
        this._primaryStrategy$ = new BehaviorSubject(undefined);
        /**
         * @description
         * Current strategy of the service as an observable.
         */
        this.primaryStrategy$ = this._primaryStrategy$.asObservable();
        /**
         * @description
         * Returns observable of an object that contains key-value pairs of strategy names and their credentials (settings) that are available in the service.
         */
        this.strategies$ = this._strategies$.asObservable();
        /**
         * @description
         * Returns an observable of an array of strategy names available in the service.
         */
        this.strategyNames$ = this.strategies$.pipe(map((strategies) => Object.values(strategies).map((s) => s.name)), shareReplay({ bufferSize: 1, refCount: true }));
        this._cfg = mergeDefaultConfig(cfg);
        this._strategies$.next(this._cfg.customStrategies);
        this.primaryStrategy = this.config.primaryStrategy;
    }
    /**
     * @description
     * Returns current `RxAngularConfig` used in the service.
     * Config includes:
     * - strategy that currently in use - `primaryStrategy`
     * - array of custom user defined strategies - `customStrategies`
     * - setting that is responsible for running in our outside of the zone.js - `patchZone`
     */
    get config() {
        return this._cfg;
    }
    /**
     * @description
     * Returns object that contains key-value pairs of strategy names and their credentials (settings) that are available in the service.
     */
    get strategies() {
        return this._strategies$.getValue();
    }
    /**
     * @description
     * Returns an array of strategy names available in the service.
     */
    get strategyNames() {
        return Object.values(this.strategies).map((s) => s.name);
    }
    /**
     * @description
     * Returns current strategy of the service.
     */
    get primaryStrategy() {
        return this._primaryStrategy$.getValue().name;
    }
    /**
     * @description
     * Set's the strategy that will be used by the service.
     */
    set primaryStrategy(strategyName) {
        this._primaryStrategy$.next(this.strategies[strategyName]);
    }
    /**
     * @description
     * Allows to schedule a work inside rxjs `pipe`. Accepts the work and configuration options object.
     * - work is any function that should be executed
     * - (optional) options includes strategy, patchZone and scope
     *
     * Scope is by default a subscription but you can also pass `this` and then the scope will be current component.
     * Scope setup is useful if your work is some of the methods of `ChangeDetectorRef`. Only one change detection will be triggered if you have multiple schedules of change detection methods and scope is set to `this`.
     *
     * @example
     * myObservable$.pipe(
     *    this.strategyProvider.scheduleWith(() => myWork(), {strategy: 'idle', patchZone: false})
     * ).subscribe();
     *
     * @return MonoTypeOperatorFunction<R>
     */
    scheduleWith(work, options) {
        const strategy = this.strategies[(options === null || options === void 0 ? void 0 : options.strategy) || this.primaryStrategy];
        const scope = (options === null || options === void 0 ? void 0 : options.scope) || {};
        const _work = getWork(work, options === null || options === void 0 ? void 0 : options.patchZone);
        return (o$) => o$.pipe(switchMap((v) => onStrategy(v, strategy, (_v) => {
            _work(_v);
        }, { scope })));
    }
    /**
     * @description
     * Allows to schedule a work as an observable. Accepts the work and configuration options object.
     * - work is any function that should be executed
     * - (optional) options includes strategy, patchZone and scope
     *
     * Scope is by default a subscription but you can also pass `this` and then the scope will be current component.
     * Scope setup is especially useful if you provide work that will trigger a change detection.
     *
     * @example
     * this.strategyProvider.schedule(() => myWork(), {strategy: 'idle', patchZone: false}).subscribe();
     *
     * @return Observable<R>
     */
    schedule(work, options) {
        const strategy = this.strategies[(options === null || options === void 0 ? void 0 : options.strategy) || this.primaryStrategy];
        const scope = (options === null || options === void 0 ? void 0 : options.scope) || {};
        const _work = getWork(work, options === null || options === void 0 ? void 0 : options.patchZone);
        let returnVal;
        return onStrategy(null, strategy, () => {
            returnVal = _work();
        }, { scope }).pipe(map(() => returnVal));
    }
    /**
     * @description
     * Allows to schedule a change detection cycle. Accepts the ChangeDetectorRef and configuration options object.
     * Options include:
     * - afterCD which is the work that should be executed after change detection cycle.
     * - abortCtrl is an AbortController that you can use to cancel the scheduled cycle.
     *
     * @example
     * this.strategyProvider.scheduleCd(this.changeDetectorRef, {afterCD: myWork()});
     *
     * @return AbortController
     */
    scheduleCD(cdRef, options) {
        const strategy = this.strategies[(options === null || options === void 0 ? void 0 : options.strategy) || this.primaryStrategy];
        const scope = (options === null || options === void 0 ? void 0 : options.scope) || cdRef;
        const abC = (options === null || options === void 0 ? void 0 : options.abortCtrl) || new AbortController();
        const work = getWork(() => {
            strategy.work(cdRef, scope);
            if (options === null || options === void 0 ? void 0 : options.afterCD) {
                options.afterCD();
            }
        }, options.patchZone);
        onStrategy(null, strategy, () => {
            work();
        }, { scope })
            .pipe(takeUntil(fromEvent(abC.signal, 'abort')))
            .subscribe();
        return abC;
    }
}
/** @nocollapse */ RxStrategyProvider.ɵprov = i0.ɵɵdefineInjectable({ factory: function RxStrategyProvider_Factory() { return new RxStrategyProvider(i0.ɵɵinject(i1.RX_ANGULAR_CONFIG, 8)); }, token: RxStrategyProvider, providedIn: "root" });
/** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
RxStrategyProvider.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/**
 * @type {function(): !Array<(null|{
 *   type: ?,
 *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),
 * })>}
 * @nocollapse
 */
RxStrategyProvider.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [RX_ANGULAR_CONFIG,] }] }
];
function getWork(work, patchZone) {
    let _work = work;
    if (patchZone) {
        _work = (args) => patchZone.run(() => work(args));
    }
    return _work;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyYXRlZ3ktcHJvdmlkZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvY2RrL3JlbmRlci1zdHJhdGVnaWVzL3NyYy9saWIvc3RyYXRlZ3ktcHJvdmlkZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsTUFBTSxFQUNOLFVBQVUsRUFFVixRQUFRLEdBQ1QsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNMLGVBQWUsRUFDZixTQUFTLEdBR1YsTUFBTSxNQUFNLENBQUM7QUFDZCxPQUFPLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFtQixNQUFNLFVBQVUsQ0FBQztBQUNsRixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7QUFHMUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErQkc7QUFFSCxNQUFNLE9BQU8sa0JBQWtCO0lBNkU5Qjs7T0FFRztJQUNGLFlBR0UsR0FBdUI7UUFsRmpCLGlCQUFZLEdBQUcsSUFBSSxlQUFlLENBQWtCLFNBQVMsQ0FBQyxDQUFDO1FBQy9ELHNCQUFpQixHQUFHLElBQUksZUFBZSxDQUU3QyxTQUFTLENBQUMsQ0FBQztRQW1EYjs7O1dBR0c7UUFDTSxxQkFBZ0IsR0FDdkIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO1FBRXhDOzs7V0FHRztRQUNNLGdCQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUV4RDs7O1dBR0c7UUFDTSxtQkFBYyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUM3QyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFN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LENBQUMsQ0FBQzthQUMvQyxTQUFTLEVBQUUsQ0FBQztRQUNmLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQzs7Ozs7WUF4TUYsVUFBVSxTQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTs7Ozs7Ozs7Ozs0Q0FrRjdCLFFBQVEsWUFDUixNQUFNLFNBQUMsaUJBQWlCOztBQXdIN0IsU0FBUyxPQUFPLENBQ2QsSUFBdUIsRUFDdkIsU0FBMEI7SUFFMUIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDO0lBQ2pCLElBQUksU0FBUyxFQUFFO1FBQ2IsS0FBSyxHQUFHLENBQUMsSUFBVSxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0tBQ3pEO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICBJbmplY3QsXHJcbiAgSW5qZWN0YWJsZSxcclxuICBOZ1pvbmUsXHJcbiAgT3B0aW9uYWwsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7XHJcbiAgQmVoYXZpb3JTdWJqZWN0LFxyXG4gIGZyb21FdmVudCxcclxuICBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24sXHJcbiAgT2JzZXJ2YWJsZSxcclxufSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgbWFwLCBzaGFyZVJlcGxheSwgc3dpdGNoTWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IG1lcmdlRGVmYXVsdENvbmZpZywgUlhfQU5HVUxBUl9DT05GSUcsIFJ4QW5ndWxhckNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0IHsgb25TdHJhdGVneSB9IGZyb20gJy4vb25TdHJhdGVneSc7XHJcbmltcG9ydCB7IFJ4U3RyYXRlZ2llcywgUnhTdHJhdGVneUNyZWRlbnRpYWxzLCBSeFN0cmF0ZWd5TmFtZXMsIFNjaGVkdWxlT25TdHJhdGVneU9wdGlvbnMgfSBmcm9tICcuL21vZGVsJztcclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogUnhTdHJhdGVneVByb3ZpZGVyIGlzIGEgd3JhcHBlciBzZXJ2aWNlIHRoYXQgeW91IGNhbiB1c2UgdG8gY29uc3VtZSBzdHJhdGVnaWVzIGFuZCBzY2hlZHVsZSB5b3VyIGNvZGUgZXhlY3V0aW9uLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBDb21wb25lbnQoe1xyXG4gKiAgIHNlbGVjdG9yOiAnYXBwLXNlcnZpY2UtY29tbXVuaWNhdG9yJyxcclxuICogICB0ZW1wbGF0ZTogYGBcclxuICogfSk7XHJcbiAqIGV4cG9ydCBjbGFzcyBTZXJ2aWNlQ29tbXVuaWNhdGlvbkNvbXBvbmVudCB7XHJcbiAqICAgcHJpdmF0ZSBjdXJyZW50VXNlclNldHRpbmdzO1xyXG4gKlxyXG4gKiAgIGNvbnN0cnVjdG9yKFxyXG4gKiAgICAgcHJpdmF0ZSBzdHJhdGVneVByb3ZpZGVyOiBSeFN0cmF0ZWd5UHJvdmlkZXIsXHJcbiAqICAgICBwcml2YXRlIHVzZXJTZXJ2aWNlOiBVc2VyU2VydmljZSxcclxuICogICAgIHByaXZhdGUgYmFja2dyb3VuZFN5bmM6IEJhY2tncm91bmRTeW5jU2VydmljZVxyXG4gKiAgICkge1xyXG4gKiAgICAgdGhpcy51c2VyU2VydmljZS5mZXRjaEN1cnJlbnRVc2VyU2V0dGluZ3NcclxuICogICAgICAgLnBpcGUoXHJcbiAqICAgICAgICAgdGFwKHNldHRpbmdzID0+ICh0aGlzLmN1cnJlbnRVc2VyU2V0dGluZ3MgPSBzZXR0aW5ncykpLFxyXG4gKiAgICAgICAgIHRoaXMuc3RyYXRlZ3lQcm92aWRlci5zY2hlZHVsZVdpdGgoXHJcbiAqICAgICAgICAgICBzZXR0aW5ncyA9PiB0aGlzLmJhY2tncm91bmRTeW5jLm9wZW5Db25uZWN0aW9uKHNldHRpbmdzKSxcclxuICogICAgICAgICAgIHsgc3RyYXRlZ3k6ICdpZGxlJyB9XHJcbiAqICAgICAgICAgKVxyXG4gKiAgICAgICApXHJcbiAqICAgICAgIC5zdWJzY3JpYmUoKTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogQGRvY3NDYXRlZ29yeSBSeFN0cmF0ZWd5UHJvdmlkZXJcclxuICogQGRvY3NQYWdlIFJ4U3RyYXRlZ3lQcm92aWRlclxyXG4gKi9cclxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcclxuZXhwb3J0IGNsYXNzIFJ4U3RyYXRlZ3lQcm92aWRlcjxUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XHJcbiAgcHJpdmF0ZSBfc3RyYXRlZ2llcyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFJ4U3RyYXRlZ2llczxUPj4odW5kZWZpbmVkKTtcclxuICBwcml2YXRlIF9wcmltYXJ5U3RyYXRlZ3kkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxcclxuICAgIFJ4U3RyYXRlZ3lDcmVkZW50aWFsczxSeFN0cmF0ZWd5TmFtZXM8VD4+XHJcbiAgPih1bmRlZmluZWQpO1xyXG5cclxuICBwcml2YXRlIF9jZmc6IFJlcXVpcmVkPFJ4QW5ndWxhckNvbmZpZzxUPj47XHJcblxyXG4gIC8qKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFJldHVybnMgY3VycmVudCBgUnhBbmd1bGFyQ29uZmlnYCB1c2VkIGluIHRoZSBzZXJ2aWNlLlxyXG4gICAqIENvbmZpZyBpbmNsdWRlczpcclxuICAgKiAtIHN0cmF0ZWd5IHRoYXQgY3VycmVudGx5IGluIHVzZSAtIGBwcmltYXJ5U3RyYXRlZ3lgXHJcbiAgICogLSBhcnJheSBvZiBjdXN0b20gdXNlciBkZWZpbmVkIHN0cmF0ZWdpZXMgLSBgY3VzdG9tU3RyYXRlZ2llc2BcclxuICAgKiAtIHNldHRpbmcgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgcnVubmluZyBpbiBvdXIgb3V0c2lkZSBvZiB0aGUgem9uZS5qcyAtIGBwYXRjaFpvbmVgXHJcbiAgICovXHJcbiAgZ2V0IGNvbmZpZygpOiBSZXF1aXJlZDxSeEFuZ3VsYXJDb25maWc8VD4+IHtcclxuICAgIHJldHVybiB0aGlzLl9jZmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBSZXR1cm5zIG9iamVjdCB0aGF0IGNvbnRhaW5zIGtleS12YWx1ZSBwYWlycyBvZiBzdHJhdGVneSBuYW1lcyBhbmQgdGhlaXIgY3JlZGVudGlhbHMgKHNldHRpbmdzKSB0aGF0IGFyZSBhdmFpbGFibGUgaW4gdGhlIHNlcnZpY2UuXHJcbiAgICovXHJcbiAgZ2V0IHN0cmF0ZWdpZXMoKTogUnhTdHJhdGVnaWVzPFQ+IHtcclxuICAgIHJldHVybiB0aGlzLl9zdHJhdGVnaWVzJC5nZXRWYWx1ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBzdHJhdGVneSBuYW1lcyBhdmFpbGFibGUgaW4gdGhlIHNlcnZpY2UuXHJcbiAgICovXHJcbiAgZ2V0IHN0cmF0ZWd5TmFtZXMoKTogc3RyaW5nW10ge1xyXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5zdHJhdGVnaWVzKS5tYXAoKHMpID0+IHMubmFtZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBSZXR1cm5zIGN1cnJlbnQgc3RyYXRlZ3kgb2YgdGhlIHNlcnZpY2UuXHJcbiAgICovXHJcbiAgZ2V0IHByaW1hcnlTdHJhdGVneSgpOiBSeFN0cmF0ZWd5TmFtZXM8VD4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3ByaW1hcnlTdHJhdGVneSQuZ2V0VmFsdWUoKS5uYW1lO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFNldCdzIHRoZSBzdHJhdGVneSB0aGF0IHdpbGwgYmUgdXNlZCBieSB0aGUgc2VydmljZS5cclxuICAgKi9cclxuICBzZXQgcHJpbWFyeVN0cmF0ZWd5KHN0cmF0ZWd5TmFtZTogUnhTdHJhdGVneU5hbWVzPFQ+KSB7XHJcbiAgICB0aGlzLl9wcmltYXJ5U3RyYXRlZ3kkLm5leHQoXHJcbiAgICAgIDxSeFN0cmF0ZWd5Q3JlZGVudGlhbHM8UnhTdHJhdGVneU5hbWVzPFQ+Pj50aGlzLnN0cmF0ZWdpZXNbc3RyYXRlZ3lOYW1lXVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIEN1cnJlbnQgc3RyYXRlZ3kgb2YgdGhlIHNlcnZpY2UgYXMgYW4gb2JzZXJ2YWJsZS5cclxuICAgKi9cclxuICByZWFkb25seSBwcmltYXJ5U3RyYXRlZ3kkOiBPYnNlcnZhYmxlPFJ4U3RyYXRlZ3lDcmVkZW50aWFscz4gPVxyXG4gICAgdGhpcy5fcHJpbWFyeVN0cmF0ZWd5JC5hc09ic2VydmFibGUoKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogUmV0dXJucyBvYnNlcnZhYmxlIG9mIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGtleS12YWx1ZSBwYWlycyBvZiBzdHJhdGVneSBuYW1lcyBhbmQgdGhlaXIgY3JlZGVudGlhbHMgKHNldHRpbmdzKSB0aGF0IGFyZSBhdmFpbGFibGUgaW4gdGhlIHNlcnZpY2UuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgc3RyYXRlZ2llcyQgPSB0aGlzLl9zdHJhdGVnaWVzJC5hc09ic2VydmFibGUoKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIG9mIGFuIGFycmF5IG9mIHN0cmF0ZWd5IG5hbWVzIGF2YWlsYWJsZSBpbiB0aGUgc2VydmljZS5cclxuICAgKi9cclxuICByZWFkb25seSBzdHJhdGVneU5hbWVzJCA9IHRoaXMuc3RyYXRlZ2llcyQucGlwZShcclxuICAgIG1hcCgoc3RyYXRlZ2llcykgPT4gT2JqZWN0LnZhbHVlcyhzdHJhdGVnaWVzKS5tYXAoKHMpID0+IHMubmFtZSkpLFxyXG4gICAgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KVxyXG4gICk7XHJcblxyXG4gLyoqXHJcbiAgKiBAaW50ZXJuYWxcclxuICAqL1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBJbmplY3QoUlhfQU5HVUxBUl9DT05GSUcpXHJcbiAgICBjZmc6IFJ4QW5ndWxhckNvbmZpZzxUPlxyXG4gICkge1xyXG4gICAgdGhpcy5fY2ZnID0gbWVyZ2VEZWZhdWx0Q29uZmlnKGNmZyk7XHJcbiAgICB0aGlzLl9zdHJhdGVnaWVzJC5uZXh0KHRoaXMuX2NmZy5jdXN0b21TdHJhdGVnaWVzIGFzIGFueSk7XHJcbiAgICB0aGlzLnByaW1hcnlTdHJhdGVneSA9IHRoaXMuY29uZmlnLnByaW1hcnlTdHJhdGVneTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIEFsbG93cyB0byBzY2hlZHVsZSBhIHdvcmsgaW5zaWRlIHJ4anMgYHBpcGVgLiBBY2NlcHRzIHRoZSB3b3JrIGFuZCBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAqIC0gd29yayBpcyBhbnkgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWRcclxuICAgKiAtIChvcHRpb25hbCkgb3B0aW9ucyBpbmNsdWRlcyBzdHJhdGVneSwgcGF0Y2hab25lIGFuZCBzY29wZVxyXG4gICAqXHJcbiAgICogU2NvcGUgaXMgYnkgZGVmYXVsdCBhIHN1YnNjcmlwdGlvbiBidXQgeW91IGNhbiBhbHNvIHBhc3MgYHRoaXNgIGFuZCB0aGVuIHRoZSBzY29wZSB3aWxsIGJlIGN1cnJlbnQgY29tcG9uZW50LlxyXG4gICAqIFNjb3BlIHNldHVwIGlzIHVzZWZ1bCBpZiB5b3VyIHdvcmsgaXMgc29tZSBvZiB0aGUgbWV0aG9kcyBvZiBgQ2hhbmdlRGV0ZWN0b3JSZWZgLiBPbmx5IG9uZSBjaGFuZ2UgZGV0ZWN0aW9uIHdpbGwgYmUgdHJpZ2dlcmVkIGlmIHlvdSBoYXZlIG11bHRpcGxlIHNjaGVkdWxlcyBvZiBjaGFuZ2UgZGV0ZWN0aW9uIG1ldGhvZHMgYW5kIHNjb3BlIGlzIHNldCB0byBgdGhpc2AuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIG15T2JzZXJ2YWJsZSQucGlwZShcclxuICAgKiAgICB0aGlzLnN0cmF0ZWd5UHJvdmlkZXIuc2NoZWR1bGVXaXRoKCgpID0+IG15V29yaygpLCB7c3RyYXRlZ3k6ICdpZGxlJywgcGF0Y2hab25lOiBmYWxzZX0pXHJcbiAgICogKS5zdWJzY3JpYmUoKTtcclxuICAgKlxyXG4gICAqIEByZXR1cm4gTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFI+XHJcbiAgICovXHJcbiAgc2NoZWR1bGVXaXRoPFI+KFxyXG4gICAgd29yazogKHY/OiBSKSA9PiB2b2lkLFxyXG4gICAgb3B0aW9ucz86IFNjaGVkdWxlT25TdHJhdGVneU9wdGlvbnNcclxuICApOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248Uj4ge1xyXG4gICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLnN0cmF0ZWdpZXNbb3B0aW9ucz8uc3RyYXRlZ3kgfHwgdGhpcy5wcmltYXJ5U3RyYXRlZ3ldO1xyXG4gICAgY29uc3Qgc2NvcGUgPSBvcHRpb25zPy5zY29wZSB8fCB7fTtcclxuICAgIGNvbnN0IF93b3JrID0gZ2V0V29yayh3b3JrLCBvcHRpb25zPy5wYXRjaFpvbmUpO1xyXG4gICAgcmV0dXJuIChvJCkgPT5cclxuICAgICAgbyQucGlwZShcclxuICAgICAgICBzd2l0Y2hNYXAoKHYpID0+XHJcbiAgICAgICAgICBvblN0cmF0ZWd5KFxyXG4gICAgICAgICAgICB2LFxyXG4gICAgICAgICAgICBzdHJhdGVneSxcclxuICAgICAgICAgICAgKF92KSA9PiB7XHJcbiAgICAgICAgICAgICAgX3dvcmsoX3YpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7IHNjb3BlIH1cclxuICAgICAgICAgIClcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBBbGxvd3MgdG8gc2NoZWR1bGUgYSB3b3JrIGFzIGFuIG9ic2VydmFibGUuIEFjY2VwdHMgdGhlIHdvcmsgYW5kIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvYmplY3QuXHJcbiAgICogLSB3b3JrIGlzIGFueSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBleGVjdXRlZFxyXG4gICAqIC0gKG9wdGlvbmFsKSBvcHRpb25zIGluY2x1ZGVzIHN0cmF0ZWd5LCBwYXRjaFpvbmUgYW5kIHNjb3BlXHJcbiAgICpcclxuICAgKiBTY29wZSBpcyBieSBkZWZhdWx0IGEgc3Vic2NyaXB0aW9uIGJ1dCB5b3UgY2FuIGFsc28gcGFzcyBgdGhpc2AgYW5kIHRoZW4gdGhlIHNjb3BlIHdpbGwgYmUgY3VycmVudCBjb21wb25lbnQuXHJcbiAgICogU2NvcGUgc2V0dXAgaXMgZXNwZWNpYWxseSB1c2VmdWwgaWYgeW91IHByb3ZpZGUgd29yayB0aGF0IHdpbGwgdHJpZ2dlciBhIGNoYW5nZSBkZXRlY3Rpb24uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHRoaXMuc3RyYXRlZ3lQcm92aWRlci5zY2hlZHVsZSgoKSA9PiBteVdvcmsoKSwge3N0cmF0ZWd5OiAnaWRsZScsIHBhdGNoWm9uZTogZmFsc2V9KS5zdWJzY3JpYmUoKTtcclxuICAgKlxyXG4gICAqIEByZXR1cm4gT2JzZXJ2YWJsZTxSPlxyXG4gICAqL1xyXG4gIHNjaGVkdWxlPFI+KFxyXG4gICAgd29yazogKCkgPT4gUixcclxuICAgIG9wdGlvbnM/OiBTY2hlZHVsZU9uU3RyYXRlZ3lPcHRpb25zXHJcbiAgKTogT2JzZXJ2YWJsZTxSPiB7XHJcbiAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuc3RyYXRlZ2llc1tvcHRpb25zPy5zdHJhdGVneSB8fCB0aGlzLnByaW1hcnlTdHJhdGVneV07XHJcbiAgICBjb25zdCBzY29wZSA9IG9wdGlvbnM/LnNjb3BlIHx8IHt9O1xyXG4gICAgY29uc3QgX3dvcmsgPSBnZXRXb3JrKHdvcmssIG9wdGlvbnM/LnBhdGNoWm9uZSk7XHJcbiAgICBsZXQgcmV0dXJuVmFsOiBSO1xyXG4gICAgcmV0dXJuIG9uU3RyYXRlZ3koXHJcbiAgICAgIG51bGwsXHJcbiAgICAgIHN0cmF0ZWd5LFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuVmFsID0gX3dvcmsoKTtcclxuICAgICAgfSxcclxuICAgICAgeyBzY29wZSB9XHJcbiAgICApLnBpcGUobWFwKCgpID0+IHJldHVyblZhbCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogQWxsb3dzIHRvIHNjaGVkdWxlIGEgY2hhbmdlIGRldGVjdGlvbiBjeWNsZS4gQWNjZXB0cyB0aGUgQ2hhbmdlRGV0ZWN0b3JSZWYgYW5kIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvYmplY3QuXHJcbiAgICogT3B0aW9ucyBpbmNsdWRlOlxyXG4gICAqIC0gYWZ0ZXJDRCB3aGljaCBpcyB0aGUgd29yayB0aGF0IHNob3VsZCBiZSBleGVjdXRlZCBhZnRlciBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLlxyXG4gICAqIC0gYWJvcnRDdHJsIGlzIGFuIEFib3J0Q29udHJvbGxlciB0aGF0IHlvdSBjYW4gdXNlIHRvIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGN5Y2xlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiB0aGlzLnN0cmF0ZWd5UHJvdmlkZXIuc2NoZWR1bGVDZCh0aGlzLmNoYW5nZURldGVjdG9yUmVmLCB7YWZ0ZXJDRDogbXlXb3JrKCl9KTtcclxuICAgKlxyXG4gICAqIEByZXR1cm4gQWJvcnRDb250cm9sbGVyXHJcbiAgICovXHJcbiAgc2NoZWR1bGVDRChcclxuICAgIGNkUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcclxuICAgIG9wdGlvbnM/OiBTY2hlZHVsZU9uU3RyYXRlZ3lPcHRpb25zICYge1xyXG4gICAgICBhZnRlckNEPzogKCkgPT4gdm9pZDtcclxuICAgICAgYWJvcnRDdHJsPzogQWJvcnRDb250cm9sbGVyO1xyXG4gICAgfVxyXG4gICk6IEFib3J0Q29udHJvbGxlciB7XHJcbiAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuc3RyYXRlZ2llc1tvcHRpb25zPy5zdHJhdGVneSB8fCB0aGlzLnByaW1hcnlTdHJhdGVneV07XHJcbiAgICBjb25zdCBzY29wZSA9IG9wdGlvbnM/LnNjb3BlIHx8IGNkUmVmO1xyXG4gICAgY29uc3QgYWJDID0gb3B0aW9ucz8uYWJvcnRDdHJsIHx8IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgIGNvbnN0IHdvcmsgPSBnZXRXb3JrKCgpID0+IHtcclxuICAgICAgc3RyYXRlZ3kud29yayhjZFJlZiwgc2NvcGUpO1xyXG4gICAgICBpZiAob3B0aW9ucz8uYWZ0ZXJDRCkge1xyXG4gICAgICAgIG9wdGlvbnMuYWZ0ZXJDRCgpO1xyXG4gICAgICB9XHJcbiAgICB9LCBvcHRpb25zLnBhdGNoWm9uZSk7XHJcbiAgICBvblN0cmF0ZWd5KFxyXG4gICAgICBudWxsLFxyXG4gICAgICBzdHJhdGVneSxcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIHdvcmsoKTtcclxuICAgICAgfSxcclxuICAgICAgeyBzY29wZSB9XHJcbiAgICApXHJcbiAgICAgIC5waXBlKHRha2VVbnRpbChmcm9tRXZlbnQoYWJDLnNpZ25hbCwgJ2Fib3J0JykpKVxyXG4gICAgICAuc3Vic2NyaWJlKCk7XHJcbiAgICByZXR1cm4gYWJDO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0V29yazxUPihcclxuICB3b3JrOiAoYXJncz86IGFueSkgPT4gVCxcclxuICBwYXRjaFpvbmU/OiBmYWxzZSB8IE5nWm9uZVxyXG4pOiAoYXJncz86IGFueSkgPT4gVCB7XHJcbiAgbGV0IF93b3JrID0gd29yaztcclxuICBpZiAocGF0Y2hab25lKSB7XHJcbiAgICBfd29yayA9IChhcmdzPzogYW55KSA9PiBwYXRjaFpvbmUucnVuKCgpID0+IHdvcmsoYXJncykpO1xyXG4gIH1cclxuICByZXR1cm4gX3dvcms7XHJcbn1cclxuIl19