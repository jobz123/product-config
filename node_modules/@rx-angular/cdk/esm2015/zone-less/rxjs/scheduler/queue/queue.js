// tslint:disable file-name-casing
import * as rxjs from 'rxjs';
import { QueueAction } from './QueueAction';
import { createScheduler } from '../create-scheduler';
/**
 *
 * NOTE: This is a zone un-patched version of rxjs queueScheduler
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * ## Examples
 * Schedule recursively first, then do something
 * ```ts
 * import { queueScheduler } from '@cu/perf-utils';
 *
 * queueScheduler.schedule(() => {
 *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 * ```
 *
 * Reschedule itself recursively
 * ```ts
 * import { queueScheduler } from '@cu/perf-utils';
 *
 * queueScheduler.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 * ```
 */
export const queueScheduler = createScheduler(rxjs.queueScheduler, QueueAction);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVldWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL2Nkay96b25lLWxlc3Mvc3JjL3J4anMvc2NoZWR1bGVyL3F1ZXVlL3F1ZXVlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtDQUFrQztBQUNsQyxPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzVDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUV0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBK0RHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sY0FBYyxHQUFHLGVBQWUsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLFdBQVcsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGUgZmlsZS1uYW1lLWNhc2luZ1xyXG5pbXBvcnQgKiBhcyByeGpzIGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBRdWV1ZUFjdGlvbiB9IGZyb20gJy4vUXVldWVBY3Rpb24nO1xyXG5pbXBvcnQgeyBjcmVhdGVTY2hlZHVsZXIgfSBmcm9tICcuLi9jcmVhdGUtc2NoZWR1bGVyJztcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBOT1RFOiBUaGlzIGlzIGEgem9uZSB1bi1wYXRjaGVkIHZlcnNpb24gb2YgcnhqcyBxdWV1ZVNjaGVkdWxlclxyXG4gKlxyXG4gKiBRdWV1ZSBTY2hlZHVsZXJcclxuICpcclxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlB1dCBldmVyeSBuZXh0IHRhc2sgb24gYSBxdWV1ZSwgaW5zdGVhZCBvZiBleGVjdXRpbmcgaXQgaW1tZWRpYXRlbHk8L3NwYW4+XHJcbiAqXHJcbiAqIGBxdWV1ZWAgc2NoZWR1bGVyLCB3aGVuIHVzZWQgd2l0aCBkZWxheSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgYXN5bmNTY2hlZHVsZXJ9IHNjaGVkdWxlci5cclxuICpcclxuICogV2hlbiB1c2VkIHdpdGhvdXQgZGVsYXksIGl0IHNjaGVkdWxlcyBnaXZlbiB0YXNrIHN5bmNocm9ub3VzbHkgLSBleGVjdXRlcyBpdCByaWdodCB3aGVuXHJcbiAqIGl0IGlzIHNjaGVkdWxlZC4gSG93ZXZlciB3aGVuIGNhbGxlZCByZWN1cnNpdmVseSwgdGhhdCBpcyB3aGVuIGluc2lkZSB0aGUgc2NoZWR1bGVkIHRhc2ssXHJcbiAqIGFub3RoZXIgdGFzayBpcyBzY2hlZHVsZWQgd2l0aCBxdWV1ZSBzY2hlZHVsZXIsIGluc3RlYWQgb2YgZXhlY3V0aW5nIGltbWVkaWF0ZWx5IGFzIHdlbGwsXHJcbiAqIHRoYXQgdGFzayB3aWxsIGJlIHB1dCBvbiBhIHF1ZXVlIGFuZCB3YWl0IGZvciBjdXJyZW50IG9uZSB0byBmaW5pc2guXHJcbiAqXHJcbiAqIFRoaXMgbWVhbnMgdGhhdCB3aGVuIHlvdSBleGVjdXRlIHRhc2sgd2l0aCBgcXVldWVgIHNjaGVkdWxlciwgeW91IGFyZSBzdXJlIGl0IHdpbGwgZW5kXHJcbiAqIGJlZm9yZSBhbnkgb3RoZXIgdGFzayBzY2hlZHVsZWQgd2l0aCB0aGF0IHNjaGVkdWxlciB3aWxsIHN0YXJ0LlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlc1xyXG4gKiBTY2hlZHVsZSByZWN1cnNpdmVseSBmaXJzdCwgdGhlbiBkbyBzb21ldGhpbmdcclxuICogYGBgdHNcclxuICogaW1wb3J0IHsgcXVldWVTY2hlZHVsZXIgfSBmcm9tICdAY3UvcGVyZi11dGlscyc7XHJcbiAqXHJcbiAqIHF1ZXVlU2NoZWR1bGVyLnNjaGVkdWxlKCgpID0+IHtcclxuICogICBxdWV1ZVNjaGVkdWxlci5zY2hlZHVsZSgoKSA9PiBjb25zb2xlLmxvZygnc2Vjb25kJykpOyAvLyB3aWxsIG5vdCBoYXBwZW4gbm93LCBidXQgd2lsbCBiZSBwdXQgb24gYSBxdWV1ZVxyXG4gKlxyXG4gKiAgIGNvbnNvbGUubG9nKCdmaXJzdCcpO1xyXG4gKiB9KTtcclxuICpcclxuICogLy8gTG9nczpcclxuICogLy8gXCJmaXJzdFwiXHJcbiAqIC8vIFwic2Vjb25kXCJcclxuICogYGBgXHJcbiAqXHJcbiAqIFJlc2NoZWR1bGUgaXRzZWxmIHJlY3Vyc2l2ZWx5XHJcbiAqIGBgYHRzXHJcbiAqIGltcG9ydCB7IHF1ZXVlU2NoZWR1bGVyIH0gZnJvbSAnQGN1L3BlcmYtdXRpbHMnO1xyXG4gKlxyXG4gKiBxdWV1ZVNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbihzdGF0ZSkge1xyXG4gKiAgIGlmIChzdGF0ZSAhPT0gMCkge1xyXG4gKiAgICAgY29uc29sZS5sb2coJ2JlZm9yZScsIHN0YXRlKTtcclxuICogICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUgLSAxKTsgLy8gYHRoaXNgIHJlZmVyZW5jZXMgY3VycmVudGx5IGV4ZWN1dGluZyBBY3Rpb24sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdlIHJlc2NoZWR1bGUgd2l0aCBuZXcgc3RhdGVcclxuICogICAgIGNvbnNvbGUubG9nKCdhZnRlcicsIHN0YXRlKTtcclxuICogICB9XHJcbiAqIH0sIDAsIDMpO1xyXG4gKlxyXG4gKiAvLyBJbiBzY2hlZHVsZXIgdGhhdCBydW5zIHJlY3Vyc2l2ZWx5LCB5b3Ugd291bGQgZXhwZWN0OlxyXG4gKiAvLyBcImJlZm9yZVwiLCAzXHJcbiAqIC8vIFwiYmVmb3JlXCIsIDJcclxuICogLy8gXCJiZWZvcmVcIiwgMVxyXG4gKiAvLyBcImFmdGVyXCIsIDFcclxuICogLy8gXCJhZnRlclwiLCAyXHJcbiAqIC8vIFwiYWZ0ZXJcIiwgM1xyXG4gKlxyXG4gKiAvLyBCdXQgd2l0aCBxdWV1ZSBpdCBsb2dzOlxyXG4gKiAvLyBcImJlZm9yZVwiLCAzXHJcbiAqIC8vIFwiYWZ0ZXJcIiwgM1xyXG4gKiAvLyBcImJlZm9yZVwiLCAyXHJcbiAqIC8vIFwiYWZ0ZXJcIiwgMlxyXG4gKiAvLyBcImJlZm9yZVwiLCAxXHJcbiAqIC8vIFwiYWZ0ZXJcIiwgMVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjb25zdCBxdWV1ZVNjaGVkdWxlciA9IGNyZWF0ZVNjaGVkdWxlcihyeGpzLnF1ZXVlU2NoZWR1bGVyLCBRdWV1ZUFjdGlvbik7XHJcbiJdfQ==