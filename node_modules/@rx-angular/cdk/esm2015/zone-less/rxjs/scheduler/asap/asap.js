// tslint:disable file-name-casing
import * as rxjs from 'rxjs';
import { AsapAction } from './AsapAction';
import { createScheduler } from '../create-scheduler';
/**
 *
 * NOTE: This is a zone un-patched version of rxjs asapScheduler
 *
 * Asap Scheduler
 *
 * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
 *
 * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task
 * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
 * code to end and then it will try to execute given task as fast as possible.
 *
 * `asap` scheduler will do its best to minimize time between end of currently executing code
 * and start of scheduled task. This makes it best candidate for performing so called "deferring".
 * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
 * some (although minimal) unwanted delay.
 *
 * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
 * after currently executing code. In particular, if some task was also scheduled with `asap` before,
 * that task will execute first. That being said, if you need to schedule task asynchronously, but
 * as soon as possible, `asap` scheduler is your best bet.
 *
 * ## Example
 * Compare async and asap scheduler<
 * ```ts
 * import { asapScheduler, asyncScheduler } from '@cu/perf-utils';
 *
 * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...
 * asapScheduler.schedule(() => console.log('asap'));
 *
 * // Logs:
 * // "asap"
 * // "async"
 * // ... but 'asap' goes first!
 * ```
 */
export const asapScheduler = createScheduler(rxjs.asapScheduler, AsapAction);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNhcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvY2RrL3pvbmUtbGVzcy9zcmMvcnhqcy9zY2hlZHVsZXIvYXNhcC9hc2FwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtDQUFrQztBQUNsQyxPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQzFDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUV0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQ0c7QUFDSCxNQUFNLENBQUMsTUFBTSxhQUFhLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsVUFBVSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZSBmaWxlLW5hbWUtY2FzaW5nXHJcbmltcG9ydCAqIGFzIHJ4anMgZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IEFzYXBBY3Rpb24gfSBmcm9tICcuL0FzYXBBY3Rpb24nO1xyXG5pbXBvcnQgeyBjcmVhdGVTY2hlZHVsZXIgfSBmcm9tICcuLi9jcmVhdGUtc2NoZWR1bGVyJztcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBOT1RFOiBUaGlzIGlzIGEgem9uZSB1bi1wYXRjaGVkIHZlcnNpb24gb2YgcnhqcyBhc2FwU2NoZWR1bGVyXHJcbiAqXHJcbiAqIEFzYXAgU2NoZWR1bGVyXHJcbiAqXHJcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5QZXJmb3JtIHRhc2sgYXMgZmFzdCBhcyBpdCBjYW4gYmUgcGVyZm9ybWVkIGFzeW5jaHJvbm91c2x5PC9zcGFuPlxyXG4gKlxyXG4gKiBgYXNhcGAgc2NoZWR1bGVyIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIGFzeW5jU2NoZWR1bGVyfSBzY2hlZHVsZXIgd2hlbiB5b3UgdXNlIGl0IHRvIGRlbGF5IHRhc2tcclxuICogaW4gdGltZS4gSWYgaG93ZXZlciB5b3Ugc2V0IGRlbGF5IHRvIGAwYCwgYGFzYXBgIHdpbGwgd2FpdCBmb3IgY3VycmVudCBzeW5jaHJvbm91c2x5IGV4ZWN1dGluZ1xyXG4gKiBjb2RlIHRvIGVuZCBhbmQgdGhlbiBpdCB3aWxsIHRyeSB0byBleGVjdXRlIGdpdmVuIHRhc2sgYXMgZmFzdCBhcyBwb3NzaWJsZS5cclxuICpcclxuICogYGFzYXBgIHNjaGVkdWxlciB3aWxsIGRvIGl0cyBiZXN0IHRvIG1pbmltaXplIHRpbWUgYmV0d2VlbiBlbmQgb2YgY3VycmVudGx5IGV4ZWN1dGluZyBjb2RlXHJcbiAqIGFuZCBzdGFydCBvZiBzY2hlZHVsZWQgdGFzay4gVGhpcyBtYWtlcyBpdCBiZXN0IGNhbmRpZGF0ZSBmb3IgcGVyZm9ybWluZyBzbyBjYWxsZWQgXCJkZWZlcnJpbmdcIi5cclxuICogVHJhZGl0aW9uYWxseSB0aGlzIHdhcyBhY2hpZXZlZCBieSBjYWxsaW5nIGBzZXRUaW1lb3V0KGRlZmVycmVkVGFzaywgMClgLCBidXQgdGhhdCB0ZWNobmlxdWUgaW52b2x2ZXNcclxuICogc29tZSAoYWx0aG91Z2ggbWluaW1hbCkgdW53YW50ZWQgZGVsYXkuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB1c2luZyBgYXNhcGAgc2NoZWR1bGVyIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4gdGhhdCB5b3VyIHRhc2sgd2lsbCBiZSBmaXJzdCB0byBwcm9jZXNzXHJcbiAqIGFmdGVyIGN1cnJlbnRseSBleGVjdXRpbmcgY29kZS4gSW4gcGFydGljdWxhciwgaWYgc29tZSB0YXNrIHdhcyBhbHNvIHNjaGVkdWxlZCB3aXRoIGBhc2FwYCBiZWZvcmUsXHJcbiAqIHRoYXQgdGFzayB3aWxsIGV4ZWN1dGUgZmlyc3QuIFRoYXQgYmVpbmcgc2FpZCwgaWYgeW91IG5lZWQgdG8gc2NoZWR1bGUgdGFzayBhc3luY2hyb25vdXNseSwgYnV0XHJcbiAqIGFzIHNvb24gYXMgcG9zc2libGUsIGBhc2FwYCBzY2hlZHVsZXIgaXMgeW91ciBiZXN0IGJldC5cclxuICpcclxuICogIyMgRXhhbXBsZVxyXG4gKiBDb21wYXJlIGFzeW5jIGFuZCBhc2FwIHNjaGVkdWxlcjxcclxuICogYGBgdHNcclxuICogaW1wb3J0IHsgYXNhcFNjaGVkdWxlciwgYXN5bmNTY2hlZHVsZXIgfSBmcm9tICdAY3UvcGVyZi11dGlscyc7XHJcbiAqXHJcbiAqIGFzeW5jU2NoZWR1bGVyLnNjaGVkdWxlKCgpID0+IGNvbnNvbGUubG9nKCdhc3luYycpKTsgLy8gc2NoZWR1bGluZyAnYXN5bmMnIGZpcnN0Li4uXHJcbiAqIGFzYXBTY2hlZHVsZXIuc2NoZWR1bGUoKCkgPT4gY29uc29sZS5sb2coJ2FzYXAnKSk7XHJcbiAqXHJcbiAqIC8vIExvZ3M6XHJcbiAqIC8vIFwiYXNhcFwiXHJcbiAqIC8vIFwiYXN5bmNcIlxyXG4gKiAvLyAuLi4gYnV0ICdhc2FwJyBnb2VzIGZpcnN0IVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjb25zdCBhc2FwU2NoZWR1bGVyID0gY3JlYXRlU2NoZWR1bGVyKHJ4anMuYXNhcFNjaGVkdWxlciwgQXNhcEFjdGlvbik7XHJcbiJdfQ==