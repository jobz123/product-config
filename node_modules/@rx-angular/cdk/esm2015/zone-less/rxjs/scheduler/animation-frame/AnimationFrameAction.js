// tslint:disable
import { AsyncAction } from '../async/AsyncAction';
import { requestAnimationFrame, cancelAnimationFrame, } from '../../../browser/browser';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class AnimationFrameAction extends AsyncAction {
    constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    requestAsyncId(scheduler, id, delay = 0) {
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return super.requestAsyncId(scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        // @ts-ignore
        scheduler.actions.push(this);
        // If an animation frame has already been requested, don't request another
        // one. If an animation frame hasn't been requested yet, request one. Return
        // the current animation frame request id.
        return (scheduler.scheduled ||
            (scheduler.scheduled = requestAnimationFrame(() => scheduler.flush(undefined))));
    }
    recycleAsyncId(scheduler, id, delay = 0) {
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return super.recycleAsyncId(scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested animation frame and
        // set the scheduled flag to undefined so the next AnimationFrameAction will
        // request its own.
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQW5pbWF0aW9uRnJhbWVBY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL2Nkay96b25lLWxlc3Mvc3JjL3J4anMvc2NoZWR1bGVyL2FuaW1hdGlvbi1mcmFtZS9BbmltYXRpb25GcmFtZUFjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUI7QUFDakIsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBR25ELE9BQU8sRUFDTCxxQkFBcUIsRUFDckIsb0JBQW9CLEdBQ3JCLE1BQU0sMEJBQTBCLENBQUM7QUFFbEM7Ozs7R0FJRztBQUNILE1BQU0sT0FBTyxvQkFBd0IsU0FBUSxXQUFjO0lBQ3pELFlBQ1ksU0FBa0MsRUFDbEMsSUFBbUQ7UUFFN0QsS0FBSyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUhiLGNBQVMsR0FBVCxTQUFTLENBQXlCO1FBQ2xDLFNBQUksR0FBSixJQUFJLENBQStDO0lBRy9ELENBQUM7SUFFUyxjQUFjLENBQ3RCLFNBQWtDLEVBQ2xDLEVBQVEsRUFDUixRQUFnQixDQUFDO1FBRWpCLDBEQUEwRDtRQUMxRCxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtZQUMvQixPQUFPLEtBQUssQ0FBQyxjQUFjLENBQUMsU0FBUyxFQUFFLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUNuRDtRQUNELHFEQUFxRDtRQUNyRCxhQUFhO1FBQ2IsU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDN0IsMEVBQTBFO1FBQzFFLDRFQUE0RTtRQUM1RSwwQ0FBMEM7UUFDMUMsT0FBTyxDQUNMLFNBQVMsQ0FBQyxTQUFTO1lBQ25CLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxxQkFBcUIsQ0FBQyxHQUFHLEVBQUUsQ0FDaEQsU0FBUyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FDM0IsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDO0lBQ1MsY0FBYyxDQUN0QixTQUFrQyxFQUNsQyxFQUFRLEVBQ1IsUUFBZ0IsQ0FBQztRQUVqQixzRUFBc0U7UUFDdEUsc0VBQXNFO1FBQ3RFLDJDQUEyQztRQUMzQyxJQUFJLENBQUMsS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUU7WUFDdkUsT0FBTyxLQUFLLENBQUMsY0FBYyxDQUFDLFNBQVMsRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDbkQ7UUFDRCw0RUFBNEU7UUFDNUUsNEVBQTRFO1FBQzVFLG1CQUFtQjtRQUNuQixJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNsQyxvQkFBb0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUN6QixTQUFTLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztTQUNqQztRQUNELHNGQUFzRjtRQUN0RixPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZVxyXG5pbXBvcnQgeyBBc3luY0FjdGlvbiB9IGZyb20gJy4uL2FzeW5jL0FzeW5jQWN0aW9uJztcclxuaW1wb3J0IHsgQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgfSBmcm9tICcuL0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVyJztcclxuaW1wb3J0IHsgU2NoZWR1bGVyQWN0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5pbXBvcnQge1xyXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSxcclxuICBjYW5jZWxBbmltYXRpb25GcmFtZSxcclxufSBmcm9tICcuLi8uLi8uLi9icm93c2VyL2Jyb3dzZXInO1xyXG5cclxuLyoqXHJcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXHJcbiAqIEBpZ25vcmVcclxuICogQGV4dGVuZHMge0lnbm9yZWR9XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uRnJhbWVBY3Rpb248VD4gZXh0ZW5kcyBBc3luY0FjdGlvbjxUPiB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcm90ZWN0ZWQgc2NoZWR1bGVyOiBBbmltYXRpb25GcmFtZVNjaGVkdWxlcixcclxuICAgIHByb3RlY3RlZCB3b3JrOiAodGhpczogU2NoZWR1bGVyQWN0aW9uPFQ+LCBzdGF0ZT86IFQpID0+IHZvaWRcclxuICApIHtcclxuICAgIHN1cGVyKHNjaGVkdWxlciwgd29yayk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgcmVxdWVzdEFzeW5jSWQoXHJcbiAgICBzY2hlZHVsZXI6IEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLFxyXG4gICAgaWQ/OiBhbnksXHJcbiAgICBkZWxheTogbnVtYmVyID0gMFxyXG4gICk6IGFueSB7XHJcbiAgICAvLyBJZiBkZWxheSBpcyBncmVhdGVyIHRoYW4gMCwgcmVxdWVzdCBhcyBhbiBhc3luYyBhY3Rpb24uXHJcbiAgICBpZiAoZGVsYXkgIT09IG51bGwgJiYgZGVsYXkgPiAwKSB7XHJcbiAgICAgIHJldHVybiBzdXBlci5yZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXIsIGlkLCBkZWxheSk7XHJcbiAgICB9XHJcbiAgICAvLyBQdXNoIHRoZSBhY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgc2NoZWR1bGVyIHF1ZXVlLlxyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgc2NoZWR1bGVyLmFjdGlvbnMucHVzaCh0aGlzKTtcclxuICAgIC8vIElmIGFuIGFuaW1hdGlvbiBmcmFtZSBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZCwgZG9uJ3QgcmVxdWVzdCBhbm90aGVyXHJcbiAgICAvLyBvbmUuIElmIGFuIGFuaW1hdGlvbiBmcmFtZSBoYXNuJ3QgYmVlbiByZXF1ZXN0ZWQgeWV0LCByZXF1ZXN0IG9uZS4gUmV0dXJuXHJcbiAgICAvLyB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWUgcmVxdWVzdCBpZC5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIHNjaGVkdWxlci5zY2hlZHVsZWQgfHxcclxuICAgICAgKHNjaGVkdWxlci5zY2hlZHVsZWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT5cclxuICAgICAgICBzY2hlZHVsZXIuZmx1c2godW5kZWZpbmVkKVxyXG4gICAgICApKVxyXG4gICAgKTtcclxuICB9XHJcbiAgcHJvdGVjdGVkIHJlY3ljbGVBc3luY0lkKFxyXG4gICAgc2NoZWR1bGVyOiBBbmltYXRpb25GcmFtZVNjaGVkdWxlcixcclxuICAgIGlkPzogYW55LFxyXG4gICAgZGVsYXk6IG51bWJlciA9IDBcclxuICApOiBhbnkge1xyXG4gICAgLy8gSWYgZGVsYXkgZXhpc3RzIGFuZCBpcyBncmVhdGVyIHRoYW4gMCwgb3IgaWYgdGhlIGRlbGF5IGlzIG51bGwgKHRoZVxyXG4gICAgLy8gYWN0aW9uIHdhc24ndCByZXNjaGVkdWxlZCkgYnV0IHdhcyBvcmlnaW5hbGx5IHNjaGVkdWxlZCBhcyBhbiBhc3luY1xyXG4gICAgLy8gYWN0aW9uLCB0aGVuIHJlY3ljbGUgYXMgYW4gYXN5bmMgYWN0aW9uLlxyXG4gICAgaWYgKChkZWxheSAhPT0gbnVsbCAmJiBkZWxheSA+IDApIHx8IChkZWxheSA9PT0gbnVsbCAmJiB0aGlzLmRlbGF5ID4gMCkpIHtcclxuICAgICAgcmV0dXJuIHN1cGVyLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcclxuICAgIH1cclxuICAgIC8vIElmIHRoZSBzY2hlZHVsZXIgcXVldWUgaXMgZW1wdHksIGNhbmNlbCB0aGUgcmVxdWVzdGVkIGFuaW1hdGlvbiBmcmFtZSBhbmRcclxuICAgIC8vIHNldCB0aGUgc2NoZWR1bGVkIGZsYWcgdG8gdW5kZWZpbmVkIHNvIHRoZSBuZXh0IEFuaW1hdGlvbkZyYW1lQWN0aW9uIHdpbGxcclxuICAgIC8vIHJlcXVlc3QgaXRzIG93bi5cclxuICAgIGlmIChzY2hlZHVsZXIuYWN0aW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xyXG4gICAgICBzY2hlZHVsZXIuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBzbyB0aGUgYWN0aW9uIGtub3dzIHRvIHJlcXVlc3QgYSBuZXcgYXN5bmMgaWQgaWYgaXQncyByZXNjaGVkdWxlZC5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG59XHJcbiJdfQ==