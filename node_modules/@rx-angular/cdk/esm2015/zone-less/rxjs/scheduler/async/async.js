// tslint:disable file-name-casing
import * as rxjs from 'rxjs';
import { AsyncAction } from './AsyncAction';
import { createScheduler } from '../create-scheduler';
/**
 *
 * NOTE: This is a zone un-patched version of rxjs asyncScheduler
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asapScheduler} scheduler.
 *
 * ## Examples
 * Use async scheduler to delay task
 * ```ts
 * import { asyncScheduler } from '@cu/perf-utils';
 *
 * const task = () => console.log('it works!');
 *
 * asyncScheduler.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 * ```
 *
 * Use async scheduler to repeat task in intervals
 * ```ts
 * import { asyncScheduler } from '@cu/perf-utils';
 *
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * asyncScheduler.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 * ```
 */
export const asyncScheduler = createScheduler(rxjs.asyncScheduler, AsyncAction);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXN5bmMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL2Nkay96b25lLWxlc3Mvc3JjL3J4anMvc2NoZWR1bGVyL2FzeW5jL2FzeW5jLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtDQUFrQztBQUNsQyxPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzVDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUV0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErQ0c7QUFDSCxNQUFNLENBQUMsTUFBTSxjQUFjLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsV0FBVyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZSBmaWxlLW5hbWUtY2FzaW5nXHJcbmltcG9ydCAqIGFzIHJ4anMgZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IEFzeW5jQWN0aW9uIH0gZnJvbSAnLi9Bc3luY0FjdGlvbic7XHJcbmltcG9ydCB7IGNyZWF0ZVNjaGVkdWxlciB9IGZyb20gJy4uL2NyZWF0ZS1zY2hlZHVsZXInO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIE5PVEU6IFRoaXMgaXMgYSB6b25lIHVuLXBhdGNoZWQgdmVyc2lvbiBvZiByeGpzIGFzeW5jU2NoZWR1bGVyXHJcbiAqXHJcbiAqIEFzeW5jIFNjaGVkdWxlclxyXG4gKlxyXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+U2NoZWR1bGUgdGFzayBhcyBpZiB5b3UgdXNlZCBzZXRUaW1lb3V0KHRhc2ssIGR1cmF0aW9uKTwvc3Bhbj5cclxuICpcclxuICogYGFzeW5jYCBzY2hlZHVsZXIgc2NoZWR1bGVzIHRhc2tzIGFzeW5jaHJvbm91c2x5LCBieSBwdXR0aW5nIHRoZW0gb24gdGhlIEphdmFTY3JpcHRcclxuICogZXZlbnQgbG9vcCBxdWV1ZS4gSXQgaXMgYmVzdCB1c2VkIHRvIGRlbGF5IHRhc2tzIGluIHRpbWUgb3IgdG8gc2NoZWR1bGUgdGFza3MgcmVwZWF0aW5nXHJcbiAqIGluIGludGVydmFscy5cclxuICpcclxuICogSWYgeW91IGp1c3Qgd2FudCB0byBcImRlZmVyXCIgdGFzaywgdGhhdCBpcyB0byBwZXJmb3JtIGl0IHJpZ2h0IGFmdGVyIGN1cnJlbnRseVxyXG4gKiBleGVjdXRpbmcgc3luY2hyb25vdXMgY29kZSBlbmRzIChjb21tb25seSBhY2hpZXZlZCBieSBgc2V0VGltZW91dChkZWZlcnJlZFRhc2ssIDApYCksXHJcbiAqIGJldHRlciBjaG9pY2Ugd2lsbCBiZSB0aGUge0BsaW5rIGFzYXBTY2hlZHVsZXJ9IHNjaGVkdWxlci5cclxuICpcclxuICogIyMgRXhhbXBsZXNcclxuICogVXNlIGFzeW5jIHNjaGVkdWxlciB0byBkZWxheSB0YXNrXHJcbiAqIGBgYHRzXHJcbiAqIGltcG9ydCB7IGFzeW5jU2NoZWR1bGVyIH0gZnJvbSAnQGN1L3BlcmYtdXRpbHMnO1xyXG4gKlxyXG4gKiBjb25zdCB0YXNrID0gKCkgPT4gY29uc29sZS5sb2coJ2l0IHdvcmtzIScpO1xyXG4gKlxyXG4gKiBhc3luY1NjaGVkdWxlci5zY2hlZHVsZSh0YXNrLCAyMDAwKTtcclxuICpcclxuICogLy8gQWZ0ZXIgMiBzZWNvbmRzIGxvZ3M6XHJcbiAqIC8vIFwiaXQgd29ya3MhXCJcclxuICogYGBgXHJcbiAqXHJcbiAqIFVzZSBhc3luYyBzY2hlZHVsZXIgdG8gcmVwZWF0IHRhc2sgaW4gaW50ZXJ2YWxzXHJcbiAqIGBgYHRzXHJcbiAqIGltcG9ydCB7IGFzeW5jU2NoZWR1bGVyIH0gZnJvbSAnQGN1L3BlcmYtdXRpbHMnO1xyXG4gKlxyXG4gKiBmdW5jdGlvbiB0YXNrKHN0YXRlKSB7XHJcbiAqICAgY29uc29sZS5sb2coc3RhdGUpO1xyXG4gKiAgIHRoaXMuc2NoZWR1bGUoc3RhdGUgKyAxLCAxMDAwKTsgLy8gYHRoaXNgIHJlZmVyZW5jZXMgY3VycmVudGx5IGV4ZWN1dGluZyBBY3Rpb24sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3ZSByZXNjaGVkdWxlIHdpdGggbmV3IHN0YXRlIGFuZCBkZWxheVxyXG4gKiB9XHJcbiAqXHJcbiAqIGFzeW5jU2NoZWR1bGVyLnNjaGVkdWxlKHRhc2ssIDMwMDAsIDApO1xyXG4gKlxyXG4gKiAvLyBMb2dzOlxyXG4gKiAvLyAwIGFmdGVyIDNzXHJcbiAqIC8vIDEgYWZ0ZXIgNHNcclxuICogLy8gMiBhZnRlciA1c1xyXG4gKiAvLyAzIGFmdGVyIDZzXHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGFzeW5jU2NoZWR1bGVyID0gY3JlYXRlU2NoZWR1bGVyKHJ4anMuYXN5bmNTY2hlZHVsZXIsIEFzeW5jQWN0aW9uKTtcclxuIl19