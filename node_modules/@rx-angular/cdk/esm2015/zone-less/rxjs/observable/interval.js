import { Observable } from 'rxjs';
import { asyncScheduler } from '../scheduler/async/async';
import { isNumeric } from './utils';
/**
 * Creates an Observable that emits sequential numbers every specified
 * interval of time, on a specified {@link SchedulerLike}.
 *
 * <span class="informal">Emits incremental numbers periodically in time.
 * </span>
 *
 * ![](interval.png)
 *
 * `interval` returns an Observable that emits an infinite sequence of
 * ascending integers, with a constant interval of time of your choosing
 * between those emissions. The first emission is not sent immediately, but
 * only after the first period has passed. By default, this operator uses the
 * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any
 * {@link SchedulerLike} to it.
 *
 * ## Example
 * Emits ascending numbers, one every second (1000ms) up to the number 3
 * ```ts
 * import { interval } from 'rxjs';
 * import { take } from 'rxjs/operators';
 *
 * const numbers = interval(1000);
 *
 * const takeFourNumbers = numbers.pipe(take(4));
 *
 * takeFourNumbers.subscribe(x => console.log('Next: ', x));
 *
 * // Logs:
 * // Next: 0
 * // Next: 1
 * // Next: 2
 * // Next: 3
 * ```
 *
 * @see {@link timer}
 * @see {@link delay}
 *
 * @param {number} [period=0] The interval size in milliseconds (by default)
 * or the time unit determined by the scheduler's clock.
 * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling
 * the emission of values, and providing a notion of "time".
 * @return {Observable} An Observable that emits a sequential number each time
 * interval.
 * @static true
 * @name interval
 * @owner Observable
 */
export function interval(period = 0, scheduler = asyncScheduler) {
    if (!isNumeric(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = asyncScheduler;
    }
    return new Observable((subscriber) => {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber, counter: 0, period }));
        return subscriber;
    });
}
function dispatch(state) {
    const { subscriber, counter, period } = state;
    subscriber.next(counter);
    this.schedule({ subscriber, counter: counter + 1, period }, period);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJ2YWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL2Nkay96b25lLWxlc3Mvc3JjL3J4anMvb2JzZXJ2YWJsZS9pbnRlcnZhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUE4QyxNQUFNLE1BQU0sQ0FBQztBQUM5RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDMUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUVwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErQ0c7QUFDSCxNQUFNLFVBQVUsUUFBUSxDQUN0QixNQUFNLEdBQUcsQ0FBQyxFQUNWLFlBQTJCLGNBQWM7SUFFekMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3BDLE1BQU0sR0FBRyxDQUFDLENBQUM7S0FDWjtJQUVELElBQUksQ0FBQyxTQUFTLElBQUksT0FBTyxTQUFTLENBQUMsUUFBUSxLQUFLLFVBQVUsRUFBRTtRQUMxRCxTQUFTLEdBQUcsY0FBYyxDQUFDO0tBQzVCO0lBRUQsT0FBTyxJQUFJLFVBQVUsQ0FBUyxDQUFDLFVBQVUsRUFBRSxFQUFFO1FBQzNDLFVBQVUsQ0FBQyxHQUFHLENBQ1osU0FBUyxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FDekUsQ0FBQztRQUNGLE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQVMsUUFBUSxDQUF1QyxLQUFvQjtJQUMxRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUM7SUFDOUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxPQUFPLEdBQUcsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3RFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlLCBTY2hlZHVsZXJBY3Rpb24sIFNjaGVkdWxlckxpa2UsIFN1YnNjcmliZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgYXN5bmNTY2hlZHVsZXIgfSBmcm9tICcuLi9zY2hlZHVsZXIvYXN5bmMvYXN5bmMnO1xyXG5pbXBvcnQgeyBpc051bWVyaWMgfSBmcm9tICcuL3V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBzZXF1ZW50aWFsIG51bWJlcnMgZXZlcnkgc3BlY2lmaWVkXHJcbiAqIGludGVydmFsIG9mIHRpbWUsIG9uIGEgc3BlY2lmaWVkIHtAbGluayBTY2hlZHVsZXJMaWtlfS5cclxuICpcclxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkVtaXRzIGluY3JlbWVudGFsIG51bWJlcnMgcGVyaW9kaWNhbGx5IGluIHRpbWUuXHJcbiAqIDwvc3Bhbj5cclxuICpcclxuICogIVtdKGludGVydmFsLnBuZylcclxuICpcclxuICogYGludGVydmFsYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbiBpbmZpbml0ZSBzZXF1ZW5jZSBvZlxyXG4gKiBhc2NlbmRpbmcgaW50ZWdlcnMsIHdpdGggYSBjb25zdGFudCBpbnRlcnZhbCBvZiB0aW1lIG9mIHlvdXIgY2hvb3NpbmdcclxuICogYmV0d2VlbiB0aG9zZSBlbWlzc2lvbnMuIFRoZSBmaXJzdCBlbWlzc2lvbiBpcyBub3Qgc2VudCBpbW1lZGlhdGVseSwgYnV0XHJcbiAqIG9ubHkgYWZ0ZXIgdGhlIGZpcnN0IHBlcmlvZCBoYXMgcGFzc2VkLiBCeSBkZWZhdWx0LCB0aGlzIG9wZXJhdG9yIHVzZXMgdGhlXHJcbiAqIGBhc3luY2Age0BsaW5rIFNjaGVkdWxlckxpa2V9IHRvIHByb3ZpZGUgYSBub3Rpb24gb2YgdGltZSwgYnV0IHlvdSBtYXkgcGFzcyBhbnlcclxuICoge0BsaW5rIFNjaGVkdWxlckxpa2V9IHRvIGl0LlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlXHJcbiAqIEVtaXRzIGFzY2VuZGluZyBudW1iZXJzLCBvbmUgZXZlcnkgc2Vjb25kICgxMDAwbXMpIHVwIHRvIHRoZSBudW1iZXIgM1xyXG4gKiBgYGB0c1xyXG4gKiBpbXBvcnQgeyBpbnRlcnZhbCB9IGZyb20gJ3J4anMnO1xyXG4gKiBpbXBvcnQgeyB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG4gKlxyXG4gKiBjb25zdCBudW1iZXJzID0gaW50ZXJ2YWwoMTAwMCk7XHJcbiAqXHJcbiAqIGNvbnN0IHRha2VGb3VyTnVtYmVycyA9IG51bWJlcnMucGlwZSh0YWtlKDQpKTtcclxuICpcclxuICogdGFrZUZvdXJOdW1iZXJzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKCdOZXh0OiAnLCB4KSk7XHJcbiAqXHJcbiAqIC8vIExvZ3M6XHJcbiAqIC8vIE5leHQ6IDBcclxuICogLy8gTmV4dDogMVxyXG4gKiAvLyBOZXh0OiAyXHJcbiAqIC8vIE5leHQ6IDNcclxuICogYGBgXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIHRpbWVyfVxyXG4gKiBAc2VlIHtAbGluayBkZWxheX1cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IFtwZXJpb2Q9MF0gVGhlIGludGVydmFsIHNpemUgaW4gbWlsbGlzZWNvbmRzIChieSBkZWZhdWx0KVxyXG4gKiBvciB0aGUgdGltZSB1bml0IGRldGVybWluZWQgYnkgdGhlIHNjaGVkdWxlcidzIGNsb2NrLlxyXG4gKiBAcGFyYW0ge1NjaGVkdWxlckxpa2V9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgU2NoZWR1bGVyTGlrZX0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXHJcbiAqIHRoZSBlbWlzc2lvbiBvZiB2YWx1ZXMsIGFuZCBwcm92aWRpbmcgYSBub3Rpb24gb2YgXCJ0aW1lXCIuXHJcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIHNlcXVlbnRpYWwgbnVtYmVyIGVhY2ggdGltZVxyXG4gKiBpbnRlcnZhbC5cclxuICogQHN0YXRpYyB0cnVlXHJcbiAqIEBuYW1lIGludGVydmFsXHJcbiAqIEBvd25lciBPYnNlcnZhYmxlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJ2YWwoXHJcbiAgcGVyaW9kID0gMCxcclxuICBzY2hlZHVsZXI6IFNjaGVkdWxlckxpa2UgPSBhc3luY1NjaGVkdWxlclxyXG4pOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xyXG4gIGlmICghaXNOdW1lcmljKHBlcmlvZCkgfHwgcGVyaW9kIDwgMCkge1xyXG4gICAgcGVyaW9kID0gMDtcclxuICB9XHJcblxyXG4gIGlmICghc2NoZWR1bGVyIHx8IHR5cGVvZiBzY2hlZHVsZXIuc2NoZWR1bGUgIT09ICdmdW5jdGlvbicpIHtcclxuICAgIHNjaGVkdWxlciA9IGFzeW5jU2NoZWR1bGVyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlPG51bWJlcj4oKHN1YnNjcmliZXIpID0+IHtcclxuICAgIHN1YnNjcmliZXIuYWRkKFxyXG4gICAgICBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2gsIHBlcmlvZCwgeyBzdWJzY3JpYmVyLCBjb3VudGVyOiAwLCBwZXJpb2QgfSlcclxuICAgICk7XHJcbiAgICByZXR1cm4gc3Vic2NyaWJlcjtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGlzcGF0Y2godGhpczogU2NoZWR1bGVyQWN0aW9uPEludGVydmFsU3RhdGU+LCBzdGF0ZTogSW50ZXJ2YWxTdGF0ZSkge1xyXG4gIGNvbnN0IHsgc3Vic2NyaWJlciwgY291bnRlciwgcGVyaW9kIH0gPSBzdGF0ZTtcclxuICBzdWJzY3JpYmVyLm5leHQoY291bnRlcik7XHJcbiAgdGhpcy5zY2hlZHVsZSh7IHN1YnNjcmliZXIsIGNvdW50ZXI6IGNvdW50ZXIgKyAxLCBwZXJpb2QgfSwgcGVyaW9kKTtcclxufVxyXG5cclxuaW50ZXJmYWNlIEludGVydmFsU3RhdGUge1xyXG4gIHN1YnNjcmliZXI6IFN1YnNjcmliZXI8bnVtYmVyPjtcclxuICBjb3VudGVyOiBudW1iZXI7XHJcbiAgcGVyaW9kOiBudW1iZXI7XHJcbn1cclxuIl19