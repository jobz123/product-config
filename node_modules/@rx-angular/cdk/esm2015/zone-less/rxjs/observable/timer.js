import { Observable } from 'rxjs';
import { asyncScheduler } from '../scheduler/async/async';
import { isNumeric, isScheduler } from './utils';
/**
 * Creates an Observable that starts emitting after an `dueTime` and
 * emits ever increasing numbers after each `period` of time thereafter.
 *
 * <span class="informal">Its like {@link index/interval}, but you can specify when
 * should the emissions start.</span>
 *
 * ![](timer.png)
 *
 * `timer` returns an Observable that emits an infinite sequence of ascending
 * integers, with a constant interval of time, `period` of your choosing
 * between those emissions. The first emission happens after the specified
 * `dueTime`. The initial delay may be a `Date`. By default, this
 * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you
 * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output
 * Observable emits only one value, `0`. Otherwise, it emits an infinite
 * sequence.
 *
 * ## Examples
 * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds
 * ```ts
 * import { timer } from 'rxjs';
 *
 * const numbers = timer(3000, 1000);
 * numbers.subscribe(x => console.log(x));
 * ```
 *
 * ### Emits one number after five seconds
 * ```ts
 * import { timer } from 'rxjs';
 *
 * const numbers = timer(5000);
 * numbers.subscribe(x => console.log(x));
 * ```
 * @see {@link index/interval}
 * @see {@link delay}
 *
 * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting
 * milliseconds to wait before emitting the first value of 0`.
 * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the
 * subsequent numbers.
 * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling
 * the emission of values, and providing a notion of "time".
 * @return {Observable} An Observable that emits a `0` after the
 * `dueTime` and ever increasing numbers after each `period` of time
 * thereafter.
 * @static true
 * @name timer
 * @owner Observable
 */
export function timer(dueTime = 0, periodOrScheduler, scheduler) {
    let period = -1;
    if (isNumeric(periodOrScheduler)) {
        period = (Number(periodOrScheduler) < 1 && 1) || Number(periodOrScheduler);
    }
    else if (isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!isScheduler(scheduler)) {
        scheduler = asyncScheduler;
    }
    return new Observable((subscriber) => {
        const due = isNumeric(dueTime)
            ? dueTime
            : +dueTime - scheduler.now();
        return scheduler.schedule(dispatch, due, {
            index: 0,
            period,
            subscriber,
        });
    });
}
function dispatch(state) {
    const { index, period, subscriber } = state;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL2Nkay96b25lLWxlc3Mvc3JjL3J4anMvb2JzZXJ2YWJsZS90aW1lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUE4QyxNQUFNLE1BQU0sQ0FBQztBQUM5RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDMUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFakQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpREc7QUFDSCxNQUFNLFVBQVUsS0FBSyxDQUNuQixVQUF5QixDQUFDLEVBQzFCLGlCQUEwQyxFQUMxQyxTQUF5QjtJQUV6QixJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNoQixJQUFJLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO1FBQ2hDLE1BQU0sR0FBRyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQztLQUM1RTtTQUFNLElBQUksV0FBVyxDQUFDLGlCQUFpQixDQUFDLEVBQUU7UUFDekMsU0FBUyxHQUFHLGlCQUF3QixDQUFDO0tBQ3RDO0lBRUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUMzQixTQUFTLEdBQUcsY0FBYyxDQUFDO0tBQzVCO0lBRUQsT0FBTyxJQUFJLFVBQVUsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFO1FBQ25DLE1BQU0sR0FBRyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUM7WUFDNUIsQ0FBQyxDQUFFLE9BQWtCO1lBQ3JCLENBQUMsQ0FBQyxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFL0IsT0FBTyxTQUFTLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUU7WUFDdkMsS0FBSyxFQUFFLENBQUM7WUFDUixNQUFNO1lBQ04sVUFBVTtTQUNYLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQVFELFNBQVMsUUFBUSxDQUFvQyxLQUFpQjtJQUNwRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsR0FBRyxLQUFLLENBQUM7SUFDNUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUV2QixJQUFJLFVBQVUsQ0FBQyxNQUFNLEVBQUU7UUFDckIsT0FBTztLQUNSO1NBQU0sSUFBSSxNQUFNLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDeEIsT0FBTyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDOUI7SUFFRCxLQUFLLENBQUMsS0FBSyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDeEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDL0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUsIFNjaGVkdWxlckFjdGlvbiwgU2NoZWR1bGVyTGlrZSwgU3Vic2NyaWJlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBhc3luY1NjaGVkdWxlciB9IGZyb20gJy4uL3NjaGVkdWxlci9hc3luYy9hc3luYyc7XHJcbmltcG9ydCB7IGlzTnVtZXJpYywgaXNTY2hlZHVsZXIgfSBmcm9tICcuL3V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBzdGFydHMgZW1pdHRpbmcgYWZ0ZXIgYW4gYGR1ZVRpbWVgIGFuZFxyXG4gKiBlbWl0cyBldmVyIGluY3JlYXNpbmcgbnVtYmVycyBhZnRlciBlYWNoIGBwZXJpb2RgIG9mIHRpbWUgdGhlcmVhZnRlci5cclxuICpcclxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0cyBsaWtlIHtAbGluayBpbmRleC9pbnRlcnZhbH0sIGJ1dCB5b3UgY2FuIHNwZWNpZnkgd2hlblxyXG4gKiBzaG91bGQgdGhlIGVtaXNzaW9ucyBzdGFydC48L3NwYW4+XHJcbiAqXHJcbiAqICFbXSh0aW1lci5wbmcpXHJcbiAqXHJcbiAqIGB0aW1lcmAgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYW4gaW5maW5pdGUgc2VxdWVuY2Ugb2YgYXNjZW5kaW5nXHJcbiAqIGludGVnZXJzLCB3aXRoIGEgY29uc3RhbnQgaW50ZXJ2YWwgb2YgdGltZSwgYHBlcmlvZGAgb2YgeW91ciBjaG9vc2luZ1xyXG4gKiBiZXR3ZWVuIHRob3NlIGVtaXNzaW9ucy4gVGhlIGZpcnN0IGVtaXNzaW9uIGhhcHBlbnMgYWZ0ZXIgdGhlIHNwZWNpZmllZFxyXG4gKiBgZHVlVGltZWAuIFRoZSBpbml0aWFsIGRlbGF5IG1heSBiZSBhIGBEYXRlYC4gQnkgZGVmYXVsdCwgdGhpc1xyXG4gKiBvcGVyYXRvciB1c2VzIHRoZSB7QGxpbmsgYXN5bmNTY2hlZHVsZXJ9IHtAbGluayBTY2hlZHVsZXJMaWtlfSB0byBwcm92aWRlIGEgbm90aW9uIG9mIHRpbWUsIGJ1dCB5b3VcclxuICogbWF5IHBhc3MgYW55IHtAbGluayBTY2hlZHVsZXJMaWtlfSB0byBpdC4gSWYgYHBlcmlvZGAgaXMgbm90IHNwZWNpZmllZCwgdGhlIG91dHB1dFxyXG4gKiBPYnNlcnZhYmxlIGVtaXRzIG9ubHkgb25lIHZhbHVlLCBgMGAuIE90aGVyd2lzZSwgaXQgZW1pdHMgYW4gaW5maW5pdGVcclxuICogc2VxdWVuY2UuXHJcbiAqXHJcbiAqICMjIEV4YW1wbGVzXHJcbiAqICMjIyBFbWl0cyBhc2NlbmRpbmcgbnVtYmVycywgb25lIGV2ZXJ5IHNlY29uZCAoMTAwMG1zKSwgc3RhcnRpbmcgYWZ0ZXIgMyBzZWNvbmRzXHJcbiAqIGBgYHRzXHJcbiAqIGltcG9ydCB7IHRpbWVyIH0gZnJvbSAncnhqcyc7XHJcbiAqXHJcbiAqIGNvbnN0IG51bWJlcnMgPSB0aW1lcigzMDAwLCAxMDAwKTtcclxuICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyMgRW1pdHMgb25lIG51bWJlciBhZnRlciBmaXZlIHNlY29uZHNcclxuICogYGBgdHNcclxuICogaW1wb3J0IHsgdGltZXIgfSBmcm9tICdyeGpzJztcclxuICpcclxuICogY29uc3QgbnVtYmVycyA9IHRpbWVyKDUwMDApO1xyXG4gKiBudW1iZXJzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcclxuICogYGBgXHJcbiAqIEBzZWUge0BsaW5rIGluZGV4L2ludGVydmFsfVxyXG4gKiBAc2VlIHtAbGluayBkZWxheX1cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gW2R1ZVRpbWVdIFRoZSBpbml0aWFsIGRlbGF5IHRpbWUgc3BlY2lmaWVkIGFzIGEgRGF0ZSBvYmplY3Qgb3IgYXMgYW4gaW50ZWdlciBkZW5vdGluZ1xyXG4gKiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgZW1pdHRpbmcgdGhlIGZpcnN0IHZhbHVlIG9mIDBgLlxyXG4gKiBAcGFyYW0ge251bWJlcnxTY2hlZHVsZXJMaWtlfSBbcGVyaW9kT3JTY2hlZHVsZXJdIFRoZSBwZXJpb2Qgb2YgdGltZSBiZXR3ZWVuIGVtaXNzaW9ucyBvZiB0aGVcclxuICogc3Vic2VxdWVudCBudW1iZXJzLlxyXG4gKiBAcGFyYW0ge1NjaGVkdWxlckxpa2V9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgU2NoZWR1bGVyTGlrZX0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXHJcbiAqIHRoZSBlbWlzc2lvbiBvZiB2YWx1ZXMsIGFuZCBwcm92aWRpbmcgYSBub3Rpb24gb2YgXCJ0aW1lXCIuXHJcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIGAwYCBhZnRlciB0aGVcclxuICogYGR1ZVRpbWVgIGFuZCBldmVyIGluY3JlYXNpbmcgbnVtYmVycyBhZnRlciBlYWNoIGBwZXJpb2RgIG9mIHRpbWVcclxuICogdGhlcmVhZnRlci5cclxuICogQHN0YXRpYyB0cnVlXHJcbiAqIEBuYW1lIHRpbWVyXHJcbiAqIEBvd25lciBPYnNlcnZhYmxlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdGltZXIoXHJcbiAgZHVlVGltZTogbnVtYmVyIHwgRGF0ZSA9IDAsXHJcbiAgcGVyaW9kT3JTY2hlZHVsZXI/OiBudW1iZXIgfCBTY2hlZHVsZXJMaWtlLFxyXG4gIHNjaGVkdWxlcj86IFNjaGVkdWxlckxpa2VcclxuKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcclxuICBsZXQgcGVyaW9kID0gLTE7XHJcbiAgaWYgKGlzTnVtZXJpYyhwZXJpb2RPclNjaGVkdWxlcikpIHtcclxuICAgIHBlcmlvZCA9IChOdW1iZXIocGVyaW9kT3JTY2hlZHVsZXIpIDwgMSAmJiAxKSB8fCBOdW1iZXIocGVyaW9kT3JTY2hlZHVsZXIpO1xyXG4gIH0gZWxzZSBpZiAoaXNTY2hlZHVsZXIocGVyaW9kT3JTY2hlZHVsZXIpKSB7XHJcbiAgICBzY2hlZHVsZXIgPSBwZXJpb2RPclNjaGVkdWxlciBhcyBhbnk7XHJcbiAgfVxyXG5cclxuICBpZiAoIWlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcclxuICAgIHNjaGVkdWxlciA9IGFzeW5jU2NoZWR1bGVyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChzdWJzY3JpYmVyKSA9PiB7XHJcbiAgICBjb25zdCBkdWUgPSBpc051bWVyaWMoZHVlVGltZSlcclxuICAgICAgPyAoZHVlVGltZSBhcyBudW1iZXIpXHJcbiAgICAgIDogK2R1ZVRpbWUgLSBzY2hlZHVsZXIubm93KCk7XHJcblxyXG4gICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaCwgZHVlLCB7XHJcbiAgICAgIGluZGV4OiAwLFxyXG4gICAgICBwZXJpb2QsXHJcbiAgICAgIHN1YnNjcmliZXIsXHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFRpbWVyU3RhdGUge1xyXG4gIGluZGV4OiBudW1iZXI7XHJcbiAgcGVyaW9kOiBudW1iZXI7XHJcbiAgc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxudW1iZXI+O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkaXNwYXRjaCh0aGlzOiBTY2hlZHVsZXJBY3Rpb248VGltZXJTdGF0ZT4sIHN0YXRlOiBUaW1lclN0YXRlKSB7XHJcbiAgY29uc3QgeyBpbmRleCwgcGVyaW9kLCBzdWJzY3JpYmVyIH0gPSBzdGF0ZTtcclxuICBzdWJzY3JpYmVyLm5leHQoaW5kZXgpO1xyXG5cclxuICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcclxuICAgIHJldHVybjtcclxuICB9IGVsc2UgaWYgKHBlcmlvZCA9PT0gLTEpIHtcclxuICAgIHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG5cclxuICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcclxuICB0aGlzLnNjaGVkdWxlKHN0YXRlLCBwZXJpb2QpO1xyXG59XHJcbiJdfQ==