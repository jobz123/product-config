import { ÉµdetectChanges as detectChanges, } from '@angular/core';
import { combineLatest, concat, merge, of, } from 'rxjs';
import { delay, ignoreElements, switchMap, withLatestFrom, } from 'rxjs/operators';
import { asyncScheduler } from '@rx-angular/cdk/zone-less';
import { onStrategy } from '@rx-angular/cdk/render-strategies';
// Below are constants for LView indices to help us look up LView members
// without having to remember the specific indices.
// Uglify will inline these when minifying so there shouldn't be a cost.
const TVIEW = 1;
const T_HOST = 6;
const L_CONTAINER_NATIVE = 7;
const CONTEXT = 8;
const HEADER_OFFSET = 20;
/**
 * @internal
 *
 * Returns the TNode of the passed node form TVIEW of passed cdRef
 *
 * @param cdRef
 * @param native
 */
export function getTNode(cdRef, native) {
    const lView = cdRef._cdRefInjectingView;
    if (!lView) {
        return undefined;
    }
    const tView = lView[TVIEW];
    let i = HEADER_OFFSET;
    let lContainer;
    while (!lContainer && i <= tView['bindingStartIndex']) {
        const candidate = lView[i];
        if (candidate && candidate[L_CONTAINER_NATIVE] === native) {
            lContainer = candidate;
        }
        i++;
    }
    return lContainer[T_HOST];
}
/**
 * @internal
 *
 * Returns a set of references to parent views
 *
 *
 * @param cdRef
 * @param tNode
 */
export function extractProjectionParentViewSet(cdRef, tNode) {
    const injectingLView = cdRef._cdRefInjectingView;
    const injectingTView = injectingLView[1];
    const components = new Set(injectingTView['components']);
    const parentElements = new Set();
    let parent = tNode['parent'];
    while (parent != null && components.size > 0) {
        const idx = parent['index'];
        if (components.has(idx)) {
            // TODO: we should discuss about this. currently only the first Component will get returned, not a list of
            //  components. Maybe we should make the parent notification configurable regarding the level of `deepness`?
            // components.delete(idx);
            components.clear();
            parentElements.add(injectingLView[idx][CONTEXT]);
        }
        parent = parent['parent'];
    }
    return parentElements;
}
export function extractProjectionViews(cdRef, tNode) {
    return Array.from(extractProjectionParentViewSet(cdRef, tNode));
}
/**
 * A side effect operator similar to `tap` but with a static logic
 *
 *
 *
 * @param cdRef
 * @param tNode
 * @param strategy$
 */
export function renderProjectionParents(cdRef, tNode, strategy$) {
    return (o$) => o$.pipe(withLatestFrom(strategy$), switchMap(([_, strategy]) => {
        const parentElements = extractProjectionParentViewSet(cdRef, tNode);
        const behaviors = [];
        for (const el of parentElements.values()) {
            behaviors.push(onStrategy(el, strategy, (value, work, options) => {
                detectChanges(el);
            }, { scope: el }));
        }
        behaviors.push(onStrategy(null, strategy, (value, work, options) => work(cdRef, options.scope), { scope: cdRef.context || cdRef }));
        return merge(...behaviors);
    }));
}
/**
 * @internal
 * creates an embeddedViewRef
 *
 * @param viewContainerRef
 * @param templateRef
 * @param context
 * @param index
 * @return EmbeddedViewRef<C>
 */
export function createEmbeddedView(viewContainerRef, templateRef, context, index = 0) {
    const view = viewContainerRef.createEmbeddedView(templateRef, context, index);
    view.detectChanges();
    return view;
}
/**
 * @internal
 *
 * A factory function returning an object to handle `TemplateRef`'s.
 * You can add and get a `TemplateRef`.
 *
 */
export function templateHandling(viewContainerRef) {
    const templateCache = new Map();
    const get = (name) => {
        return templateCache.get(name);
    };
    return {
        add(name, templateRef) {
            assertTemplate(name, templateRef);
            if (!templateCache.has(name)) {
                templateCache.set(name, templateRef);
            }
            else {
                throw new Error('Updating an already existing Template is not supported at the moment.');
            }
        },
        get,
        createEmbeddedView: (name, context) => createEmbeddedView(viewContainerRef, get(name), context),
    };
    //
    function assertTemplate(property, templateRef) {
        const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
        if (!isTemplateRefOrNull) {
            throw new Error(`${property} must be a TemplateRef, but received something else.`);
        }
        return isTemplateRefOrNull;
    }
}
/**
 * @internal
 *
 * A side effect operator similar to `tap` but with a static internal logic.
 * It calls detect changes on the 'VirtualParent' and the injectingViewCdRef.
 *
 * @param tNode
 * @param injectingViewCdRef
 * @param strategy
 * @param notifyNeeded
 */
export function notifyAllParentsIfNeeded(tNode, injectingViewCdRef, strategy, notifyNeeded) {
    return (o$) => o$.pipe(delay(0, asyncScheduler), switchMap((v) => {
        const notifyParent = notifyNeeded();
        if (!notifyParent) {
            return of(v);
        }
        const behaviors = tNode
            ? getVirtualParentNotifications$(tNode, injectingViewCdRef, strategy)
            : [];
        // @TODO remove this CD on injectingViewCdRef if possible
        behaviors.push(onStrategy(injectingViewCdRef, strategy, (_v, work, options) => work(injectingViewCdRef, options.scope), {
            scope: injectingViewCdRef.context || injectingViewCdRef,
        }));
        if (behaviors.length === 1) {
            return of(v);
        }
        return concat(of(v), combineLatest(behaviors).pipe(ignoreElements()));
    }));
}
/**
 * @internal
 *
 * returns an Observable executing a side effects for change detection of parents
 *
 * @param injectingViewCdRef
 * @param strategy
 * @param notify
 */
export function notifyInjectingParentIfNeeded(injectingViewCdRef, strategy, notify) {
    return concat(of(null), notify
        ? onStrategy(injectingViewCdRef, strategy, (value, work, options) => {
            // console.log('notify injectingView', injectingViewCdRef);
            work(injectingViewCdRef, options.scope);
        }, {}).pipe(ignoreElements())
        : []);
}
/**
 * @internal
 *
 * Returns an array of observables triggering `detectChanges` on the __virtual parent__  (parent of the projected view)
 *
 * @param tNode - is a component that was projected into another component (virtual parent)
 * @param injectingViewCdRef - is needed to get the
 * @param strategy - the strategy to run the change detection
 */
export function getVirtualParentNotifications$(tNode, injectingViewCdRef, strategy) {
    const parentElements = extractProjectionParentViewSet(injectingViewCdRef, tNode);
    const behaviors = [];
    for (const parentComponent of parentElements.values()) {
        behaviors.push(onStrategy(parentComponent, strategy, 
        // Here we CD the parent to update their projected views scenarios
        (value, work, options) => {
            // console.log('parentComponent', parentComponent);
            detectChanges(parentComponent);
        }, { scope: parentComponent }));
    }
    return behaviors;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL2Nkay90ZW1wbGF0ZS9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFPTCxjQUFjLElBQUksYUFBYSxHQUNoQyxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQ0wsYUFBYSxFQUNiLE1BQU0sRUFDTixLQUFLLEVBRUwsRUFBRSxHQUVILE1BQU0sTUFBTSxDQUFDO0FBRWQsT0FBTyxFQUNMLEtBQUssRUFDTCxjQUFjLEVBQ2QsU0FBUyxFQUNULGNBQWMsR0FDZixNQUFNLGdCQUFnQixDQUFDO0FBQ3hCLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUMzRCxPQUFPLEVBQXlCLFVBQVUsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBRXRGLHlFQUF5RTtBQUN6RSxtREFBbUQ7QUFDbkQsd0VBQXdFO0FBQ3hFLE1BQU0sS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNoQixNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDakIsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLENBQUM7QUFDN0IsTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBQ2xCLE1BQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQztBQUl6Qjs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLFFBQVEsQ0FBQyxLQUF3QixFQUFFLE1BQVk7SUFDN0QsTUFBTSxLQUFLLEdBQUksS0FBYSxDQUFDLG1CQUFtQixDQUFDO0lBQ2pELElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDVixPQUFPLFNBQVMsQ0FBQztLQUNsQjtJQUNELE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQixJQUFJLENBQUMsR0FBRyxhQUFhLENBQUM7SUFDdEIsSUFBSSxVQUFVLENBQUM7SUFDZixPQUFPLENBQUMsVUFBVSxJQUFJLENBQUMsSUFBSSxL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RSxPQUFPLEVBQUUsRUFBRTtZQUN2QixtREFBbUQ7WUFDbkQsYUFBYSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ2pDLENBQUMsRUFDRCxFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsQ0FDM0IsQ0FDRixDQUFDO0tBQ0g7SUFDRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICBDb21wb25lbnQsXHJcbiAgRW1iZWRkZWRWaWV3UmVmLFxyXG4gIFRlbXBsYXRlUmVmLFxyXG4gIFR5cGUsXHJcbiAgVmlld0NvbnRhaW5lclJlZixcclxuICDJtWRldGVjdENoYW5nZXMgYXMgZGV0ZWN0Q2hhbmdlcyxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtcclxuICBjb21iaW5lTGF0ZXN0LFxyXG4gIGNvbmNhdCxcclxuICBtZXJnZSxcclxuICBPYnNlcnZhYmxlLFxyXG4gIG9mLFxyXG4gIE9wZXJhdG9yRnVuY3Rpb24sXHJcbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge1xyXG4gIGRlbGF5LFxyXG4gIGlnbm9yZUVsZW1lbnRzLFxyXG4gIHN3aXRjaE1hcCxcclxuICB3aXRoTGF0ZXN0RnJvbSxcclxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IGFzeW5jU2NoZWR1bGVyIH0gZnJvbSAnQHJ4LWFuZ3VsYXIvY2RrL3pvbmUtbGVzcyc7XHJcbmltcG9ydCB7IFJ4U3RyYXRlZ3lDcmVkZW50aWFscywgb25TdHJhdGVneSB9IGZyb20gJ0ByeC1hbmd1bGFyL2Nkay9yZW5kZXItc3RyYXRlZ2llcyc7XHJcblxyXG4vLyBCZWxvdyBhcmUgY29uc3RhbnRzIGZvciBMVmlldyBpbmRpY2VzIHRvIGhlbHAgdXMgbG9vayB1cCBMVmlldyBtZW1iZXJzXHJcbi8vIHdpdGhvdXQgaGF2aW5nIHRvIHJlbWVtYmVyIHRoZSBzcGVjaWZpYyBpbmRpY2VzLlxyXG4vLyBVZ2xpZnkgd2lsbCBpbmxpbmUgdGhlc2Ugd2hlbiBtaW5pZnlpbmcgc28gdGhlcmUgc2hvdWxkbid0IGJlIGEgY29zdC5cclxuY29uc3QgVFZJRVcgPSAxO1xyXG5jb25zdCBUX0hPU1QgPSA2O1xyXG5jb25zdCBMX0NPTlRBSU5FUl9OQVRJVkUgPSA3O1xyXG5jb25zdCBDT05URVhUID0gODtcclxuY29uc3QgSEVBREVSX09GRlNFVCA9IDIwO1xyXG5cclxuZXhwb3J0IHR5cGUgVE5vZGUgPSBhbnk7XHJcblxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqXHJcbiAqIFJldHVybnMgdGhlIFROb2RlIG9mIHRoZSBwYXNzZWQgbm9kZSBmb3JtIFRWSUVXIG9mIHBhc3NlZCBjZFJlZlxyXG4gKlxyXG4gKiBAcGFyYW0gY2RSZWZcclxuICogQHBhcmFtIG5hdGl2ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFROb2RlKGNkUmVmOiBDaGFuZ2VEZXRlY3RvclJlZiwgbmF0aXZlOiBOb2RlKTogVE5vZGUge1xyXG4gIGNvbnN0IGxWaWV3ID0gKGNkUmVmIGFzIGFueSkuX2NkUmVmSW5qZWN0aW5nVmlldztcclxuICBpZiAoIWxWaWV3KSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBjb25zdCB0VmlldyA9IGxWaWV3W1RWSUVXXTtcclxuICBsZXQgaSA9IEhFQURFUl9PRkZTRVQ7XHJcbiAgbGV0IGxDb250YWluZXI7XHJcbiAgd2hpbGUgKCFsQ29udGFpbmVyICYmIGkgPD0gdFZpZXdbJ2JpbmRpbmdTdGFydEluZGV4J10pIHtcclxuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGxWaWV3W2ldO1xyXG4gICAgaWYgKGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGVbTF9DT05UQUlORVJfTkFUSVZFXSA9PT0gbmF0aXZlKSB7XHJcbiAgICAgIGxDb250YWluZXIgPSBjYW5kaWRhdGU7XHJcbiAgICB9XHJcbiAgICBpKys7XHJcbiAgfVxyXG4gIHJldHVybiBsQ29udGFpbmVyW1RfSE9TVF07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICpcclxuICogUmV0dXJucyBhIHNldCBvZiByZWZlcmVuY2VzIHRvIHBhcmVudCB2aWV3c1xyXG4gKlxyXG4gKlxyXG4gKiBAcGFyYW0gY2RSZWZcclxuICogQHBhcmFtIHROb2RlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFByb2plY3Rpb25QYXJlbnRWaWV3U2V0KFxyXG4gIGNkUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcclxuICB0Tm9kZTogVE5vZGVcclxuKTogU2V0PFR5cGU8Q29tcG9uZW50Pj4ge1xyXG4gIGNvbnN0IGluamVjdGluZ0xWaWV3ID0gKGNkUmVmIGFzIGFueSkuX2NkUmVmSW5qZWN0aW5nVmlldztcclxuICBjb25zdCBpbmplY3RpbmdUVmlldyA9IGluamVjdGluZ0xWaWV3WzFdO1xyXG4gIGNvbnN0IGNvbXBvbmVudHMgPSBuZXcgU2V0PG51bWJlcj4oaW5qZWN0aW5nVFZpZXdbJ2NvbXBvbmVudHMnXSk7XHJcbiAgY29uc3QgcGFyZW50RWxlbWVudHMgPSBuZXcgU2V0PFR5cGU8Q29tcG9uZW50Pj4oKTtcclxuICBsZXQgcGFyZW50ID0gdE5vZGVbJ3BhcmVudCddO1xyXG4gIHdoaWxlIChwYXJlbnQgIT0gbnVsbCAmJiBjb21wb25lbnRzLnNpemUgPiAwKSB7XHJcbiAgICBjb25zdCBpZHggPSBwYXJlbnRbJ2luZGV4J107XHJcbiAgICBpZiAoY29tcG9uZW50cy5oYXMoaWR4KSkge1xyXG4gICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgZGlzY3VzcyBhYm91dCB0aGlzLiBjdXJyZW50bHkgb25seSB0aGUgZmlyc3QgQ29tcG9uZW50IHdpbGwgZ2V0IHJldHVybmVkLCBub3QgYSBsaXN0IG9mXHJcbiAgICAgIC8vICBjb21wb25lbnRzLiBNYXliZSB3ZSBzaG91bGQgbWFrZSB0aGUgcGFyZW50IG5vdGlmaWNhdGlvbiBjb25maWd1cmFibGUgcmVnYXJkaW5nIHRoZSBsZXZlbCBvZiBgZGVlcG5lc3NgP1xyXG4gICAgICAvLyBjb21wb25lbnRzLmRlbGV0ZShpZHgpO1xyXG4gICAgICBjb21wb25lbnRzLmNsZWFyKCk7XHJcbiAgICAgIHBhcmVudEVsZW1lbnRzLmFkZChpbmplY3RpbmdMVmlld1tpZHhdW0NPTlRFWFRdKTtcclxuICAgIH1cclxuICAgIHBhcmVudCA9IHBhcmVudFsncGFyZW50J107XHJcbiAgfVxyXG4gIHJldHVybiBwYXJlbnRFbGVtZW50cztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQcm9qZWN0aW9uVmlld3MoXHJcbiAgY2RSZWY6IENoYW5nZURldGVjdG9yUmVmLFxyXG4gIHROb2RlOiBUTm9kZVxyXG4pOiBUeXBlPGFueT5bXSB7XHJcbiAgcmV0dXJuIEFycmF5LmZyb20oZXh0cmFjdFByb2plY3Rpb25QYXJlbnRWaWV3U2V0KGNkUmVmLCB0Tm9kZSkpO1xyXG59XHJcblxyXG4vKipcclxuICogQSBzaWRlIGVmZmVjdCBvcGVyYXRvciBzaW1pbGFyIHRvIGB0YXBgIGJ1dCB3aXRoIGEgc3RhdGljIGxvZ2ljXHJcbiAqXHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSBjZFJlZlxyXG4gKiBAcGFyYW0gdE5vZGVcclxuICogQHBhcmFtIHN0cmF0ZWd5JFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclByb2plY3Rpb25QYXJlbnRzKFxyXG4gIGNkUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcclxuICB0Tm9kZTogVE5vZGUsXHJcbiAgc3RyYXRlZ3kkOiBPYnNlcnZhYmxlPFJ4U3RyYXRlZ3lDcmVkZW50aWFscz5cclxuKTogT3BlcmF0b3JGdW5jdGlvbjxhbnksIGFueT4ge1xyXG4gIHJldHVybiAobyQpID0+XHJcbiAgICBvJC5waXBlKFxyXG4gICAgICB3aXRoTGF0ZXN0RnJvbShzdHJhdGVneSQpLFxyXG4gICAgICBzd2l0Y2hNYXAoKFtfLCBzdHJhdGVneV0pID0+IHtcclxuICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50cyA9IGV4dHJhY3RQcm9qZWN0aW9uUGFyZW50Vmlld1NldChjZFJlZiwgdE5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGJlaGF2aW9ycyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgcGFyZW50RWxlbWVudHMudmFsdWVzKCkpIHtcclxuICAgICAgICAgIGJlaGF2aW9ycy5wdXNoKFxyXG4gICAgICAgICAgICBvblN0cmF0ZWd5KFxyXG4gICAgICAgICAgICAgIGVsLFxyXG4gICAgICAgICAgICAgIHN0cmF0ZWd5LFxyXG4gICAgICAgICAgICAgICh2YWx1ZSwgd29yaywgb3B0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGV0ZWN0Q2hhbmdlcyhlbCk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7IHNjb3BlOiBlbCB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJlaGF2aW9ycy5wdXNoKFxyXG4gICAgICAgICAgb25TdHJhdGVneShcclxuICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgc3RyYXRlZ3ksXHJcbiAgICAgICAgICAgICh2YWx1ZSwgd29yaywgb3B0aW9ucykgPT4gd29yayhjZFJlZiwgb3B0aW9ucy5zY29wZSksXHJcbiAgICAgICAgICAgIHsgc2NvcGU6IChjZFJlZiBhcyBhbnkpLmNvbnRleHQgfHwgY2RSZWYgfVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlKC4uLmJlaGF2aW9ycyk7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG59XHJcblxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqIGNyZWF0ZXMgYW4gZW1iZWRkZWRWaWV3UmVmXHJcbiAqXHJcbiAqIEBwYXJhbSB2aWV3Q29udGFpbmVyUmVmXHJcbiAqIEBwYXJhbSB0ZW1wbGF0ZVJlZlxyXG4gKiBAcGFyYW0gY29udGV4dFxyXG4gKiBAcGFyYW0gaW5kZXhcclxuICogQHJldHVybiBFbWJlZGRlZFZpZXdSZWY8Qz5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbWJlZGRlZFZpZXc8Qz4oXHJcbiAgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcclxuICB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8Qz4sXHJcbiAgY29udGV4dDogQyxcclxuICBpbmRleCA9IDBcclxuKTogRW1iZWRkZWRWaWV3UmVmPEM+IHtcclxuICBjb25zdCB2aWV3ID0gdmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcodGVtcGxhdGVSZWYsIGNvbnRleHQsIGluZGV4KTtcclxuICB2aWV3LmRldGVjdENoYW5nZXMoKTtcclxuICByZXR1cm4gdmlldztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKlxyXG4gKiBBIGZhY3RvcnkgZnVuY3Rpb24gcmV0dXJuaW5nIGFuIG9iamVjdCB0byBoYW5kbGUgYFRlbXBsYXRlUmVmYCdzLlxyXG4gKiBZb3UgY2FuIGFkZCBhbmQgZ2V0IGEgYFRlbXBsYXRlUmVmYC5cclxuICpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUhhbmRsaW5nPE4sIEM+KFxyXG4gIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWZcclxuKToge1xyXG4gIGFkZChuYW1lOiBOLCB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8Qz4pOiB2b2lkO1xyXG4gIGdldChuYW1lOiBOKTogVGVtcGxhdGVSZWY8Qz47XHJcbiAgY3JlYXRlRW1iZWRkZWRWaWV3KG5hbWU6IE4sIGNvbnRleHQ/OiBDLCBpbmRleD86IG51bWJlcik6IEVtYmVkZGVkVmlld1JlZjxDPjtcclxufSB7XHJcbiAgY29uc3QgdGVtcGxhdGVDYWNoZSA9IG5ldyBNYXA8TiwgVGVtcGxhdGVSZWY8Qz4+KCk7XHJcblxyXG4gIGNvbnN0IGdldCA9IChuYW1lOiBOKTogVGVtcGxhdGVSZWY8Qz4gPT4ge1xyXG4gICAgcmV0dXJuIHRlbXBsYXRlQ2FjaGUuZ2V0KG5hbWUpO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIGFkZChuYW1lOiBOLCB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8Qz4pOiB2b2lkIHtcclxuICAgICAgYXNzZXJ0VGVtcGxhdGUobmFtZSwgdGVtcGxhdGVSZWYpO1xyXG4gICAgICBpZiAoIXRlbXBsYXRlQ2FjaGUuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgdGVtcGxhdGVDYWNoZS5zZXQobmFtZSwgdGVtcGxhdGVSZWYpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICdVcGRhdGluZyBhbiBhbHJlYWR5IGV4aXN0aW5nIFRlbXBsYXRlIGlzIG5vdCBzdXBwb3J0ZWQgYXQgdGhlIG1vbWVudC4nXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldCxcclxuICAgIGNyZWF0ZUVtYmVkZGVkVmlldzogKG5hbWU6IE4sIGNvbnRleHQ/OiBDKSA9PlxyXG4gICAgICBjcmVhdGVFbWJlZGRlZFZpZXcodmlld0NvbnRhaW5lclJlZiwgZ2V0KG5hbWUpLCBjb250ZXh0KSxcclxuICB9O1xyXG5cclxuICAvL1xyXG4gIGZ1bmN0aW9uIGFzc2VydFRlbXBsYXRlPFQ+KFxyXG4gICAgcHJvcGVydHk6IGFueSxcclxuICAgIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxUPiB8IG51bGxcclxuICApOiB0ZW1wbGF0ZVJlZiBpcyBUZW1wbGF0ZVJlZjxUPiB7XHJcbiAgICBjb25zdCBpc1RlbXBsYXRlUmVmT3JOdWxsID0gISEoXHJcbiAgICAgICF0ZW1wbGF0ZVJlZiB8fCB0ZW1wbGF0ZVJlZi5jcmVhdGVFbWJlZGRlZFZpZXdcclxuICAgICk7XHJcbiAgICBpZiAoIWlzVGVtcGxhdGVSZWZPck51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGAke3Byb3BlcnR5fSBtdXN0IGJlIGEgVGVtcGxhdGVSZWYsIGJ1dCByZWNlaXZlZCBzb21ldGhpbmcgZWxzZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNUZW1wbGF0ZVJlZk9yTnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICpcclxuICogQSBzaWRlIGVmZmVjdCBvcGVyYXRvciBzaW1pbGFyIHRvIGB0YXBgIGJ1dCB3aXRoIGEgc3RhdGljIGludGVybmFsIGxvZ2ljLlxyXG4gKiBJdCBjYWxscyBkZXRlY3QgY2hhbmdlcyBvbiB0aGUgJ1ZpcnR1YWxQYXJlbnQnIGFuZCB0aGUgaW5qZWN0aW5nVmlld0NkUmVmLlxyXG4gKlxyXG4gKiBAcGFyYW0gdE5vZGVcclxuICogQHBhcmFtIGluamVjdGluZ1ZpZXdDZFJlZlxyXG4gKiBAcGFyYW0gc3RyYXRlZ3lcclxuICogQHBhcmFtIG5vdGlmeU5lZWRlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5vdGlmeUFsbFBhcmVudHNJZk5lZWRlZDxUPihcclxuICB0Tm9kZTogVE5vZGUsXHJcbiAgaW5qZWN0aW5nVmlld0NkUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcclxuICBzdHJhdGVneTogUnhTdHJhdGVneUNyZWRlbnRpYWxzLFxyXG4gIG5vdGlmeU5lZWRlZDogKCkgPT4gYm9vbGVhblxyXG4pOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD4ge1xyXG4gIHJldHVybiAobyQpID0+XHJcbiAgICBvJC5waXBlKFxyXG4gICAgICBkZWxheSgwLCBhc3luY1NjaGVkdWxlciksXHJcbiAgICAgIHN3aXRjaE1hcCgodikgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5vdGlmeVBhcmVudCA9IG5vdGlmeU5lZWRlZCgpO1xyXG4gICAgICAgIGlmICghbm90aWZ5UGFyZW50KSB7XHJcbiAgICAgICAgICByZXR1cm4gb2Yodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJlaGF2aW9ycyA9IHROb2RlXHJcbiAgICAgICAgICA/IGdldFZpcnR1YWxQYXJlbnROb3RpZmljYXRpb25zJCh0Tm9kZSwgaW5qZWN0aW5nVmlld0NkUmVmLCBzdHJhdGVneSlcclxuICAgICAgICAgIDogW107XHJcbiAgICAgICAgLy8gQFRPRE8gcmVtb3ZlIHRoaXMgQ0Qgb24gaW5qZWN0aW5nVmlld0NkUmVmIGlmIHBvc3NpYmxlXHJcbiAgICAgICAgYmVoYXZpb3JzLnB1c2goXHJcbiAgICAgICAgICBvblN0cmF0ZWd5KFxyXG4gICAgICAgICAgICBpbmplY3RpbmdWaWV3Q2RSZWYsXHJcbiAgICAgICAgICAgIHN0cmF0ZWd5LFxyXG4gICAgICAgICAgICAoX3YsIHdvcmssIG9wdGlvbnMpID0+IHdvcmsoaW5qZWN0aW5nVmlld0NkUmVmLCBvcHRpb25zLnNjb3BlKSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHNjb3BlOiAoaW5qZWN0aW5nVmlld0NkUmVmIGFzIGFueSkuY29udGV4dCB8fCBpbmplY3RpbmdWaWV3Q2RSZWYsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChiZWhhdmlvcnMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICByZXR1cm4gb2Yodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb25jYXQob2YodiksIGNvbWJpbmVMYXRlc3QoYmVoYXZpb3JzKS5waXBlKGlnbm9yZUVsZW1lbnRzKCkpKTtcclxuICAgICAgfSlcclxuICAgICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICpcclxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlIGV4ZWN1dGluZyBhIHNpZGUgZWZmZWN0cyBmb3IgY2hhbmdlIGRldGVjdGlvbiBvZiBwYXJlbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSBpbmplY3RpbmdWaWV3Q2RSZWZcclxuICogQHBhcmFtIHN0cmF0ZWd5XHJcbiAqIEBwYXJhbSBub3RpZnlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBub3RpZnlJbmplY3RpbmdQYXJlbnRJZk5lZWRlZChcclxuICBpbmplY3RpbmdWaWV3Q2RSZWY6IENoYW5nZURldGVjdG9yUmVmLFxyXG4gIHN0cmF0ZWd5OiBSeFN0cmF0ZWd5Q3JlZGVudGlhbHMsXHJcbiAgbm90aWZ5OiBib29sZWFuXHJcbik6IE9ic2VydmFibGU8bnVsbD4ge1xyXG4gIHJldHVybiBjb25jYXQoXHJcbiAgICBvZihudWxsKSxcclxuICAgIG5vdGlmeVxyXG4gICAgICA/IG9uU3RyYXRlZ3koXHJcbiAgICAgICAgaW5qZWN0aW5nVmlld0NkUmVmLFxyXG4gICAgICAgICAgc3RyYXRlZ3ksXHJcbiAgICAgICAgICAodmFsdWUsIHdvcmssIG9wdGlvbnMpID0+IHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ25vdGlmeSBpbmplY3RpbmdWaWV3JywgaW5qZWN0aW5nVmlld0NkUmVmKTtcclxuICAgICAgICAgICAgd29yayhpbmplY3RpbmdWaWV3Q2RSZWYsIG9wdGlvbnMuc2NvcGUpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHt9XHJcbiAgICAgICAgKS5waXBlKGlnbm9yZUVsZW1lbnRzKCkpXHJcbiAgICAgIDogKFtdIGFzIHVua25vd24gYXMgT2JzZXJ2YWJsZTxuZXZlcj4pXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKlxyXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIG9ic2VydmFibGVzIHRyaWdnZXJpbmcgYGRldGVjdENoYW5nZXNgIG9uIHRoZSBfX3ZpcnR1YWwgcGFyZW50X18gIChwYXJlbnQgb2YgdGhlIHByb2plY3RlZCB2aWV3KVxyXG4gKlxyXG4gKiBAcGFyYW0gdE5vZGUgLSBpcyBhIGNvbXBvbmVudCB0aGF0IHdhcyBwcm9qZWN0ZWQgaW50byBhbm90aGVyIGNvbXBvbmVudCAodmlydHVhbCBwYXJlbnQpXHJcbiAqIEBwYXJhbSBpbmplY3RpbmdWaWV3Q2RSZWYgLSBpcyBuZWVkZWQgdG8gZ2V0IHRoZVxyXG4gKiBAcGFyYW0gc3RyYXRlZ3kgLSB0aGUgc3RyYXRlZ3kgdG8gcnVuIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmlydHVhbFBhcmVudE5vdGlmaWNhdGlvbnMkKFxyXG4gIHROb2RlOiBUTm9kZSxcclxuICBpbmplY3RpbmdWaWV3Q2RSZWY6IENoYW5nZURldGVjdG9yUmVmLFxyXG4gIHN0cmF0ZWd5OiBSeFN0cmF0ZWd5Q3JlZGVudGlhbHNcclxuKTogT2JzZXJ2YWJsZTx1bmtub3duPltdIHtcclxuICBjb25zdCBwYXJlbnRFbGVtZW50cyA9IGV4dHJhY3RQcm9qZWN0aW9uUGFyZW50Vmlld1NldChcclxuICAgIGluamVjdGluZ1ZpZXdDZFJlZixcclxuICAgIHROb2RlXHJcbiAgKTtcclxuICBjb25zdCBiZWhhdmlvcnMgPSBbXTtcclxuICBmb3IgKGNvbnN0IHBhcmVudENvbXBvbmVudCBvZiBwYXJlbnRFbGVtZW50cy52YWx1ZXMoKSkge1xyXG4gICAgYmVoYXZpb3JzLnB1c2goXHJcbiAgICAgIG9uU3RyYXRlZ3koXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIHN0cmF0ZWd5LFxyXG4gICAgICAgIC8vIEhlcmUgd2UgQ0QgdGhlIHBhcmVudCB0byB1cGRhdGUgdGhlaXIgcHJvamVjdGVkIHZpZXdzIHNjZW5hcmlvc1xyXG4gICAgICAgICh2YWx1ZSwgd29yaywgb3B0aW9ucykgPT4ge1xyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3BhcmVudENvbXBvbmVudCcsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgICBkZXRlY3RDaGFuZ2VzKHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IHNjb3BlOiBwYXJlbnRDb21wb25lbnQgfVxyXG4gICAgICApXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gYmVoYXZpb3JzO1xyXG59XHJcbiJdfQ==