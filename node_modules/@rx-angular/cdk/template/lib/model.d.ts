import { ChangeDetectorRef, ElementRef, EmbeddedViewRef, ErrorHandler, NgZone, TemplateRef, ViewContainerRef } from '@angular/core';
import { Observable } from 'rxjs';
import { RxNotification } from '@rx-angular/cdk/notifications';
import { RxStrategies } from '@rx-angular/cdk/render-strategies';
export declare type rxBaseTemplateNames = 'errorTpl' | 'completeTpl' | 'suspenseTpl';
export declare enum RxBaseTemplateNames {
    error = "errorTpl",
    complete = "completeTpl",
    suspense = "suspenseTpl"
}
export declare const enum RxListTemplateChangeType {
    insert = 0,
    remove = 1,
    move = 2,
    update = 3,
    context = 4
}
export declare type RxListTemplateChangePayload<T> = [T, number, number?];
export declare type RxListTemplateChange<T = any> = [
    RxListTemplateChangeType,
    RxListTemplateChangePayload<T>
];
export declare type RxListTemplateChanges<T = any> = [
    RxListTemplateChange<T>[],
    boolean
];
export interface RxViewContext<T> {
    $implicit: T;
    $error: false | Error;
    $complete: boolean;
    $suspense: any;
}
export interface RxRenderAware<T> {
    nextStrategy: (nextConfig: string | Observable<string>) => void;
    render: (values$: Observable<RxNotification<T>>) => Observable<void>;
}
export interface RxRenderSettings<T, C> {
    cdRef: ChangeDetectorRef;
    eRef: ElementRef;
    parent: boolean;
    patchZone: NgZone | false;
    strategies: RxStrategies<string>;
    defaultStrategyName: string;
    errorHandler?: ErrorHandler;
}
export declare type CreateEmbeddedView<C> = (viewContainerRef: ViewContainerRef, patchZone: NgZone | false) => (templateRef: TemplateRef<C>, context?: C, index?: number) => EmbeddedViewRef<C>;
export declare type CreateViewContext<T, C, U = unknown> = (value: T, computedContext: U) => C;
export declare type UpdateViewContext<T, C, U = unknown> = (value: T, view: EmbeddedViewRef<C>, computedContext?: U) => void;
export interface RxTemplateSettings<T, C, U = unknown> {
    patchZone: NgZone | false;
    viewContainerRef: ViewContainerRef;
    createViewContext: CreateViewContext<T, C, U>;
    updateViewContext: UpdateViewContext<T, C, U>;
    initialTemplateRef?: TemplateRef<C>;
    customContext?: (value: T) => any;
}
