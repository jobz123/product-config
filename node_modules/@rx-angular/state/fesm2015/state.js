import { Subject, BehaviorSubject, merge, queueScheduler, EMPTY, noop, Subscription, isObservable } from 'rxjs';
import { distinctUntilChanged, mergeAll, observeOn, withLatestFrom, scan, tap, catchError, publish, publishReplay, filter, shareReplay, pluck, map } from 'rxjs/operators';
import { Injectable } from '@angular/core';

const defaultAccumulator = (st, sl) => {
    return Object.assign(Object.assign({}, st), sl);
};
const Éµ0 = defaultAccumulator;
function createAccumulationObservable(stateObservables = new Subject(), stateSlices = new Subject(), accumulatorObservable = new BehaviorSubject(defaultAccumulator)) {
    const signal$ = merge(stateObservables.pipe(distinctUntilChanged(), mergeAll(), observeOn(queueScheduler)), stateSlices.pipe(observeOn(queueScheduler))).pipe(withLatestFrom(accumulatorObservable.pipe(observeOn(queueScheduler))), scan((state, [slice, stateAccumulator]) => stateAccumulator(state, slice), {}), tap((newState) => (compositionObservable.state = newState), (error) => console.error(error)), 
    // @Notice We catch the error here as it get lost in between `publish` and `publishReplay`. We return empty to
    catchError((e) => EMPTY), publish());
    const state$ = signal$.pipe(publishReplay(1));
    const compositionObservable = {
        state: {},
        signal$,
        state$,
        nextSlice,
        nextSliceObservable,
        nextAccumulator,
        subscribe
    };
    // ======
    return compositionObservable;
    // ======
    function nextAccumulator(accumulatorFn) {
        accumulatorObservable.next(accumulatorFn);
    }
    function nextSlice(stateSlice) {
        stateSlices.next(stateSlice);
    }
    function nextSliceObservable(stateObservable) {
        stateObservables.next(stateObservable);
    }
    function subscribe() {
        const sub = compositionObservable.signal$.connect();
        sub.add(compositionObservable.state$.connect());
        sub.add(() => {
            accumulatorObservable.complete();
            stateObservables.complete();
            stateSlices.complete();
        });
        return sub;
    }
}

function createSideEffectObservable(stateObservables = new Subject()) {
    const effects$ = merge(stateObservables.pipe(mergeAll(), observeOn(queueScheduler)));
    function nextEffectObservable(effect$) {
        stateObservables.next(effect$);
    }
    function subscribe() {
        return effects$.subscribe();
    }
    return {
        effects$,
        nextEffectObservable,
        subscribe
    };
}

function pipeFromArray(fns) {
    if (!fns) {
        return noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce((prev, fn) => fn(prev), input);
    };
}

function isPromiseGuard(value) {
    return (!!value &&
        typeof value.subscribe !== 'function' &&
        typeof value.then === 'function');
}
function isOperateFnArrayGuard(op) {
    if (!Array.isArray(op)) {
        return false;
    }
    return op.length > 0 && op.every((i) => typeof i === 'function');
}
function isStringArrayGuard(op) {
    if (!Array.isArray(op)) {
        return false;
    }
    return op.length > 0 && op.every((i) => typeof i === 'string');
}
function isIterableGuard(obj) {
    if (obj === null || obj === undefined) {
        return false;
    }
    return typeof obj[Symbol.iterator] === 'function';
}
function isKeyOf(k) {
    return (!!k &&
        (typeof k === 'string' || typeof k === 'symbol' || typeof k === 'number'));
}
function isObjectGuard(obj) {
    return !!obj && typeof obj === 'object' && !Array.isArray(obj);
}
function isDefined(val) {
    return val !== null && val !== undefined;
}

function safePluck(stateObject, keys) {
    // needed to match null and undefined conventions of RxAngular core components
    // safePluck(null) -> return null
    // safePluck(undefined) -> return undefined
    // safePluck(obj, ['wrongKey']) -> return undefined
    // safePluck(obj, ['correctKey']) -> return value of key
    // safePluck(obj, '') -> return undefined
    // safePluck(obj, null) -> return undefined
    if (!isDefined(stateObject)) {
        return stateObject;
    }
    if (!isDefined(keys)) {
        return undefined;
    }
    // sanitize keys -> keep only valid keys (string, number, symbol)
    const keysArr = (Array.isArray(keys) ? keys : [keys]).filter(k => isKeyOf(k));
    if (keysArr.length === 0 ||
        !isObjectGuard(stateObject) ||
        Object.keys(stateObject).length === 0) {
        return undefined;
    }
    let prop = stateObject[keysArr.shift()];
    keysArr.forEach(key => {
        if (isObjectGuard(prop) && isKeyOf(key)) {
            prop = prop[key];
        }
    });
    return prop;
}

/**
 * @description
 *
 * As it acts like the Observables `pipe` method, it accepts one or many RxJS operators as params.
 *
 * @example
 * import { Observable } from 'rxjs';
 * import { map } from 'rxjs/operators';
 * import { stateful } from 'rx-angular/state';
 *
 * const state$: Observable<{ name: string; items: string[] }>;
 * const derivation$ = state$.pipe(
 *   stateful(
 *     map(state => state.list.length),
 *     filter(length => length > 3)
 *   )
 * );
 *
 * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated
 *
 * @docsPage stateful
 * @docsCategory operators
 */
function stateful(...optionalDerive) {
    return (s) => {
        return s.pipe(
        // distinct same base-state objects (e.g. a default emission of default switch cases, incorrect mutable handling
        // of data) @TODO evaluate benefits vs. overhead
        distinctUntilChanged(), 
        // CUSTOM LOGIC HERE
        (o) => {
            if (isOperateFnArrayGuard(optionalDerive)) {
                return o.pipe(pipeFromArray(optionalDerive));
            }
            return o;
        }, 
        // initial emissions, undefined is no base-state, pollution with skip(1)
        filter((v) => v !== undefined), 
        // distinct same derivation value
        distinctUntilChanged(), 
        // reuse custom operations result for multiple subscribers and reemit the last calculated value.
        shareReplay({ bufferSize: 1, refCount: true }));
    };
}

/**
 * @internal
 */
function select(...opOrMapFn) {
    return (state$) => {
        if (!opOrMapFn || opOrMapFn.length === 0) {
            return state$.pipe(stateful());
        }
        else if (isStringArrayGuard(opOrMapFn)) {
            return state$.pipe(stateful(pluck(...opOrMapFn)));
        }
        else if (isOperateFnArrayGuard(opOrMapFn)) {
            return state$.pipe(stateful(pipeFromArray(opOrMapFn)));
        }
        else {
            throw new Error('wrong params passed to select');
        }
    };
}

/**
 * @internal
 */
function defaultCompare(oldVal, newVal) {
    return oldVal === newVal;
}
/**
 * @description
 *
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from
 * the previous item. Comparison will be done for each set key in the `keys` array.
 *
 * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute
 * explicitly different
 *
 * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the
 * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to
 * compute if values are distinct or not.
 *
 * @example
 *
 * import { of } from 'rxjs';
 * import { distinctUntilSomeChanged } from 'rx-angular/state';
 *
 * interface Person {
 *    age: number;
 *    name: string;
 * }
 *
 * of(
 *   { age: 4, name: 'Hans'},
 *   { age: 7, name: 'Sophie'},
 *   { age: 5, name: 'Han Solo'},
 *   { age: 5, name: 'HanSophie'},
 * ).pipe(
 *   distinctUntilSomeChanged(['age', 'name']),
 * )
 * .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Hans'}
 * // { age: 7, name: 'Sophie'}
 * // { age: 5, name: 'Han Solo'}
 * // { age: 5, name: 'HanSophie'}
 *
 * @example
 * // An example with `KeyCompareMap`
 * import { of } from 'rxjs';
 * import { distinctUntilSomeChanged } from 'rxjs/operators';
 *
 * interface Person {
 *     age: number;
 *     name: string;
 *  }
 * const customComparison: KeyCompareMap<Person> = {
 *   name: (oldName, newName) => oldName.substring(0, 2) === newName.substring(0, 2)
 * };
 *
 * of(
 *     { age: 4, name: 'Hans'},
 *     { age: 7, name: 'Sophie'},
 *     { age: 5, name: 'Han Solo'},
 *     { age: 5, name: 'HanSophie'},
 *   ).pipe(
 *     distinctUntilSomeChanged(['age', 'name'], customComparison),
 *   )
 *   .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Hans' }
 * // { age: 7, name: 'Sophie' }
 * // { age: 5, name: 'Han Solo' }
 *
 * @param {K[]} keys String key for object property lookup on each item.
 * @param {KeyCompareMap<T>} [compare] Optional KeyCompareMap to explicitly define comparisons for some of the keys
 * @docsPage distinctUntilSomeChanged
 * @docsCategory operators
 */
function distinctUntilSomeChanged(keys, keyCompareMap) {
    // default compare function applying === to every key
    let distinctCompare = (oldState, newState) => keys.some((key) => !defaultCompare(safePluck(oldState, [key]), safePluck(newState, [key])));
    // generate compare function respecting every case of provided keyCompareMap
    if (keyCompareMap !== undefined) {
        const compare = (key) => {
            return keyCompareMap.hasOwnProperty(key) &&
                keyCompareMap[key] !== undefined
                ? keyCompareMap[key]
                : defaultCompare;
        };
        distinctCompare = (oldState, newState) => {
            return keys.some((key) => !compare(key)(safePluck(oldState, [key]), safePluck(newState, [key])));
        };
    }
    return distinctUntilChanged((oldV, newV) => !distinctCompare(oldV, newV));
}

/**
 * @description
 *
 * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get
 * filtered to only emit _defined_ values as well as checked for distinct emissions.
 * Comparison will be done for each set key in the `keys` array.
 *
 * `selectSlice` will only emit _valid_ selections. A selection is _valid_ if every
 * selected key exists and is defined in the source Observable. This ensures that the `selectSlice`
 * operator will always return a complete slice with all values defined.
 *
 * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute
 * explicitly different
 *
 * @example
 *
 * // An example with a custom comparison applied to each key
 * import { of } from 'rxjs';
 * import { selectSlice } from 'rx-angular/state';
 *
 *
 * const state$: Observable<MyState> = of(
 *  { title: 'myTitle', panelOpen: true},
 *  { title: 'myTitle2', panelOpen: true},
 *  { title: 'newTitle', panelOpen: true},
 *  { title: 'newTitle', panelOpen: false}
 * )
 * .pipe(
 *     selectSlice(['title', 'panelOpen']),
 *   )
 *   .subscribe(x => console.log(x));
 *
 * // displays:
 * //  { title: 'myTitle', panelOpen: true },
 * //  { title: 'myTitle2', panelOpen: true },
 * //  { title: 'newTitle', panelOpen: true },
 * //  { title: 'newTitle', panelOpen: false }
 *
 * @example
 *
 * import { of, Observable } from 'rxjs';
 * import { tap } from 'rxjs/operators';
 * import { selectSlice } from 'rx-angular/state';
 *
 * interface MyState {
 *    title: string;
 *    items: string[];
 *    panelOpen: boolean;
 * }
 * // Select items and title.
 * // apply custom compare logic for the items array
 * const customComparison: KeyCompareMap<MyState> = {
 *   items: (oldItems, newItems) => compareItems(oldItems, newItems)
 * };
 * const state$: Observable<MyState> = of(
 * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: true },
 * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: false },
 * { title: 'nextTitle', items: ['foo', 'baR'], panelOpen: true },
 * { title: 'nextTitle', items: ['fooRz', 'boo'], panelOpen: false },
 * );
 * const slice$ = state$.pipe(selectSlice(['title', 'items'], customComparison), tap(console.log)).subscribe();
 *
 * // displays:
 * // { title: 'myTitle', items: ['foo', 'bar'] }
 * // { title: 'nextTitle', items: ['foo', 'baR'] }
 * // { title: 'nextTitle', items: ['fooRz', 'boo'] }
 *
 * @param {(K)[]} keys - the array of keys which should be selected
 * @param {KeyCompareMap<{ [P in K]: T[P] }>} [keyCompareMap] Optional KeyCompareMap to provide custom compare logic
 * for some the keys
 * @docsPage selectSlice
 * @docsCategory operators
 */
function selectSlice(keys, keyCompareMap) {
    return (o$) => o$.pipe(filter((state) => state !== undefined), map((state) => {
        // forward null
        if (state === null) {
            return null;
        }
        // an array of all keys which exist and are _defined_ in the state object
        const definedKeys = keys
            // filter out undefined properties e. g. {}, { str: undefined }
            .filter((k) => state.hasOwnProperty(k) && state[k] !== undefined);
        // we want to ensure to only emit _valid_ selections
        // a selection is _valid_ if every selected key exists and has a value:
        // {} => selectSlice(['foo']) => no emission
        // {str: 'test'} => selectSlice([]) => no emission
        // {str: 'test'} => selectSlice(['notPresent']) => no emission
        // {str: 'test'} => state.select(selectSlice([])) => no emission
        // {str: 'test'} => state.select(selectSlice(['notPresent'])) => no emission
        // {str: undefined} => state.select(selectSlice(['str'])) => no emission
        // {str: 'test', foo: undefined } => state.select(selectSlice(['foo'])) => no emission
        if (definedKeys.length < keys.length) {
            return undefined;
        }
        // create the selected slice
        return definedKeys
            .reduce((vm, key) => {
            vm[key] = state[key];
            return vm;
        }, {});
    }), filter((v) => v !== undefined), distinctUntilSomeChanged(keys, keyCompareMap));
}

/**
 * @description
 * RxState is a light-weight reactive state management service for managing local state in angular.
 *
 * @example
 * Component({
 *   selector: 'app-stateful',
 *   template: `<div>{{ state$ | async | json }}</div>`,
 *   providers: [RxState]
 * })
 * export class StatefulComponent {
 *   readonly state$ = this.state.select();
 *
 *   constructor(private state: RxState<{ foo: string }>) {}
 * }
 *
 * @docsCategory RxState
 * @docsPage RxState
 */
class RxState {
    /**
     * @internal
     */
    constructor() {
        this.subscription = new Subscription();
        this.accumulator = createAccumulationObservable();
        this.effectObservable = createSideEffectObservable();
        /**
         * @description
         * The unmodified state exposed as `Observable<T>`. It is not shared, distinct or gets replayed.
         * Use the `$` property if you want to read the state without having applied {@link stateful} to it.
         */
        this.$ = this.accumulator.signal$;
        this.subscription.add(this.subscribe());
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * @description
     *
     * Allows to customize state accumulation function.
     * This can be helpful to implement deep updates and tackle other immutability problems in a custom way.
     * @example
     *
     * ```typescript
     * const myAccumulator = (state: MyState, slice: Partial<MyState>) => deepCopy(state, slice);
     *
     * this.state.setAccumulator(myAccumulator);
     * ```
     */
    setAccumulator(accumulatorFn) {
        this.accumulator.nextAccumulator(accumulatorFn);
    }
    /** @internal **/
    get(...keys) {
        const hasStateAnyKeys = Object.keys(this.accumulator.state).length > 0;
        if (!!keys && keys.length) {
            return safePluck(this.accumulator.state, keys);
        }
        else {
            return hasStateAnyKeys ?
                this.accumulator.state :
                undefined;
        }
    }
    /**
     * @internal
     */
    set(keyOrStateOrProjectState, stateOrSliceProjectFn) {
        if (typeof keyOrStateOrProjectState === 'object' &&
            stateOrSliceProjectFn === undefined) {
            this.accumulator.nextSlice(keyOrStateOrProjectState);
            return;
        }
        if (typeof keyOrStateOrProjectState === 'function' &&
            stateOrSliceProjectFn === undefined) {
            this.accumulator.nextSlice(keyOrStateOrProjectState(this.accumulator.state));
            return;
        }
        if (isKeyOf(keyOrStateOrProjectState) &&
            typeof stateOrSliceProjectFn === 'function') {
            const state = {};
            state[keyOrStateOrProjectState] = stateOrSliceProjectFn(this.accumulator.state);
            this.accumulator.nextSlice(state);
            return;
        }
        throw new Error('wrong params passed to set');
    }
    /**
     * @internal
     */
    connect(keyOrInputOrSlice$, projectOrSlices$, projectValueFn) {
        if (isObservable(keyOrInputOrSlice$) &&
            projectOrSlices$ === undefined &&
            projectValueFn === undefined) {
            this.accumulator.nextSliceObservable(keyOrInputOrSlice$);
            return;
        }
        if (isObservable(keyOrInputOrSlice$) &&
            typeof projectOrSlices$ === 'function' &&
            !isObservable(projectOrSlices$) &&
            projectValueFn === undefined) {
            const project = projectOrSlices$;
            const slice$ = keyOrInputOrSlice$.pipe(map((v) => project(this.get(), v)));
            this.accumulator.nextSliceObservable(slice$);
            return;
        }
        if (isKeyOf(keyOrInputOrSlice$) &&
            isObservable(projectOrSlices$) &&
            projectValueFn === undefined) {
            const key = keyOrInputOrSlice$;
            const slice$ = projectOrSlices$.pipe(map((value) => (Object.assign({}, { [key]: value }))));
            this.accumulator.nextSliceObservable(slice$);
            return;
        }
        if (isKeyOf(keyOrInputOrSlice$) &&
            isObservable(projectOrSlices$) &&
            typeof projectValueFn === 'function') {
            const key = keyOrInputOrSlice$;
            const slice$ = projectOrSlices$.pipe(map((value) => (Object.assign({}, { [key]: projectValueFn(this.get(), value) }))));
            this.accumulator.nextSliceObservable(slice$);
            return;
        }
        throw new Error('wrong params passed to connect');
    }
    /**
     * @internal
     */
    select(...opOrMapFn) {
        if (!opOrMapFn || opOrMapFn.length === 0) {
            return this.accumulator.state$.pipe(stateful());
        }
        else if (isStringArrayGuard(opOrMapFn)) {
            return this.accumulator.state$.pipe(stateful(pluck(...opOrMapFn)));
        }
        else if (isOperateFnArrayGuard(opOrMapFn)) {
            return this.accumulator.state$.pipe(stateful(pipeFromArray(opOrMapFn)));
        }
        throw new Error('wrong params passed to select');
    }
    /**
     * @description
     * Manages side-effects of your state. Provide an `Observable<any>` **side-effect** and an optional
     * `sideEffectFunction`.
     * Subscription handling is done automatically.
     *
     * @example
     * // Directly pass an observable side-effect
     * const localStorageEffect$ = changes$.pipe(
     *  tap(changes => storeChanges(changes))
     * );
     * state.hold(localStorageEffect$);
     *
     * // Pass an additional `sideEffectFunction`
     *
     * const localStorageEffectFn = changes => storeChanges(changes);
     * state.hold(changes$, localStorageEffectFn);
     *
     * @param {Observable<S>} obsOrObsWithSideEffect
     * @param {function} [sideEffectFn]
     */
    hold(obsOrObsWithSideEffect, sideEffectFn) {
        const sideEffect = obsOrObsWithSideEffect.pipe(catchError(e => EMPTY));
        if (typeof sideEffectFn === 'function') {
            this.effectObservable.nextEffectObservable(sideEffect.pipe(tap(sideEffectFn)));
            return;
        }
        this.effectObservable.nextEffectObservable(sideEffect);
    }
    /**
     * @internal
     */
    subscribe() {
        const subscription = new Subscription();
        subscription.add(this.accumulator.subscribe());
        subscription.add(this.effectObservable.subscribe());
        return subscription;
    }
}
RxState.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RxState.ctorParameters = () => [];

/**
 * @description
 * Inserts one or multiple items to an array T[].
 * Returns a shallow copy of the updated array T[], and does not mutate the original one.
 *
 * @example
 * // Inserting single value
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
 *
 * const updatedCreatures = insert(creatures, {id: 3, type: 'parrot'});
 *
 * // updatedCreatures will be:
 * //  [{id: 1, type: 'cat'}, {id: 2, type: 'dog}, {id: 3, type: 'parrot}];
 *
 * @example
 * // Inserting multiple values
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
 *
 * const updatedCreatures = insert(creatures, [{id: 3, type: 'parrot'}, {id: 4, type: 'hamster'}]);
 *
 * // updatedCreatures will be:
 * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'parrot'}, {id: 4, type: 'hamster'}];
 *
 * @example
 * // Usage with RxState
 *
 * export class ListComponent {
 *
 *    readonly insertCreature$ = new Subject<void>();
 *
 *    constructor(private state: RxState<ComponentState>) {
 *      // Reactive implementation
 *      state.connect(
 *        'creatures',
 *        this.insertCreature$,
 *        ({ creatures }) => {
 *            const creatureToAdd = {id: generateId(), name: 'newCreature', type: 'dinosaur' };
 *            return insert(creatures, creatureToAdd);
 *        }
 *      );
 *    }
 *
 *    // Imperative implementation
 *    insertCeature(): void {
 *        const creatureToAdd = {id: generateId(), name: 'newCreature', type: 'dinosaur' };
 *        this.state.set({ creatures: insert(this.state.get().creatures, creatureToAdd)});
 *    }
 * }
 *
 *
 * @returns T[]
 *
 * @docsPage insert
 * @docsCategory transformation-helpers
 */
function insert(source, updates) {
    const updatesDefined = isDefined(updates);
    const sourceIsArray = Array.isArray(source);
    const invalidInput = !sourceIsArray && !updatesDefined;
    if (!sourceIsArray && isDefined(source)) {
        console.warn(`Insert: Original value (${source}) is not an array.`);
    }
    if (invalidInput) {
        return source;
    }
    return [
        ...(sourceIsArray ? source : []),
        ...(updatesDefined ? (Array.isArray(updates) ? updates : [updates]) : [])
    ];
}

function valuesComparer(original, incoming, compare) {
    const defaultCompare = (a, b) => a === b;
    if (isKeyOf(compare)) {
        return original[compare] === incoming[compare];
    }
    if (Array.isArray(compare)) {
        const sanitizedKeys = compare.filter((k) => isKeyOf(k));
        return !!sanitizedKeys.length
            ? sanitizedKeys.every((k) => original[k] === incoming[k])
            : defaultCompare(original, incoming);
    }
    return (compare || defaultCompare)(original, incoming);
}

/**
 * @description
 * Removes one or multiple items from an array T[].
 * For comparison you can provide a key, an array of keys or a custom comparison function that should return true if items match.
 * If no comparison data is provided, an equality check is used by default.
 * Returns a shallow copy of the updated array T[], and does not mutate the original one.
 *
 * @example
 * // Removing value without comparison data
 *
 * const items = [1,2,3,4,5];
 *
 * const updatedItems = remove(items, [1,2,3]);
 *
 * // updatedItems will be: [4,5];
 *
 * @example
 * // Removing values with comparison function
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
 *
 * const nonExistingCreatures = [{id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
 *
 * const realCreatures = remove(creatures, nonExistingCreatures, (a, b) => a.id === b.id);
 *
 * // realCreatures will be: [{id: 1, type: 'cat'}];
 *
 * @example
 * // Removing values with key
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
 *
 * const nonExistingCreatures = [{id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
 *
 * const realCreatures = remove(creatures, nonExistingCreatures, 'id');
 *
 * // realCreatures will be: [{id: 1, type: 'cat'}];
 *
 * @example
 * // Removing values with array of keys
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
 *
 * const nonExistingCreatures = [{id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
 *
 * const realCreatures = remove(creatures, nonExistingCreatures, ['id', 'type']);
 *
 * // realCreatures will be: [{id: 1, type: 'cat'}];
 *
 * @example
 * // Usage with RxState
 *
 * export class ListComponent {
 *
 *    readonly removeCreature$ = new Subject<Creature>();
 *
 *    constructor(private state: RxState<ComponentState>) {
 *      // Reactive implementation
 *      state.connect(
 *        'creatures',
 *        this.removeCreature$,
 *        ({ creatures }, creatureToRemove) => {
 *            return remove(creatures, creatureToRemove, (a, b) => a.id === b.id);
 *        }
 *      );
 *    }
 *
 *    // Imperative implementation
 *    removeCreature(creatureToRemove: Creature): void {
 *        this.state.set({ creatures: remove(this.state.get().creatures, creatureToRemove, (a, b) => a.id === b.id)});
 *    }
 * }
 *
 * @returns T[]
 *
 * @docsPage remove
 * @docsCategory transformation-helpers
 */
function remove(source, scrap, compare) {
    const scrapAsArray = isDefined(scrap)
        ? Array.isArray(scrap)
            ? scrap
            : [scrap]
        : [];
    const invalidInput = !Array.isArray(source);
    if (invalidInput) {
        console.warn(`Remove: original value (${source}) is not an array`);
        return source;
    }
    return source.filter((existingItem) => {
        return !scrapAsArray.some((item) => valuesComparer(item, existingItem, compare));
    });
}

/**
 * @description
 * Converts an array of objects to a dictionary {[key: string]: T}.
 * Accepts array T[] and key of type string, number or symbol as inputs.
 *
 *
 * @example
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'parrot'}];
 *
 * const creaturesDictionary = toDictionary(creatures, 'id');
 *
 * // creaturesDictionary will be:
 * // {
 * //  1: {id: 1, type: 'cat'},
 * //  2: {id: 2, type: 'dog'},
 * //  3: {id: 3, type: 'parrot'}
 * // };
 * @example
 * // Usage with RxState
 *
 * export class ListComponent {
 *
 *    readonly convertToDictionary$ = new Subject();
 *
 *    constructor(private state: RxState<ComponentState>) {
 *      // Reactive implementation
 *      state.connect(
 *        'creaturesDictionary',
 *        this.convertToDictionary$,
 *        ({ creatures }) => {
 *            return toDictionary(creatures, 'id');
 *        }
 *      );
 *    }
 *
 *    // Imperative implementation
 *    convertToDictionary(): void {
 *        this.state.set({ creaturesDictionary: toDictionary(this.state.get().creatures, 'id'});
 *    }
 * }
 *
 * @see {@link OnlyKeysOfSpecificType}
 * @param {OnlyKeysOfSpecificType<T, S>} key
 * @returns { [key: string]: T[] }
 * @docsPage toDictionary
 * @docsCategory transformation-helpers
 */
function toDictionary(source, key) {
    if (!isDefined(source)) {
        return source;
    }
    const sourceEmpty = !source.length;
    if (!Array.isArray(source) || sourceEmpty || !isKeyOf(source[0][key])) {
        if (!sourceEmpty) {
            console.warn('ToDictionary: unexpected input params.');
        }
        return {};
    }
    const dictionary = {};
    const length = source.length;
    let i = 0;
    for (i; i < length; i++) {
        dictionary[`${source[i][key]}`] = Object.assign({}, source[i]);
    }
    return dictionary;
}

/**
 * @description
 * Updates one or multiple items in an array T[].
 * For comparison you can provide key, array of keys or a custom comparison function that should return true if items match.
 * If no comparison is provided, an equality check is used by default.
 * Returns a shallow copy of the array T[] and updated items, does not mutate the original array.
 *
 * @example
 * // Update with comparison function
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
 *
 * const newCat = {id: 1, type: 'lion'};
 *
 * const updatedCreatures = update(creatures, newCat, (a, b) => a.id === b.id);
 *
 * // updatedCreatures will be:
 * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];
 *
 * @example
 * // Update with key
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
 *
 * const newCat = {id: 1, type: 'lion'};
 *
 * const updatedCreatures = update(creatures, newCat, 'id');
 *
 * // updatedCreatures will be:
 * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];
 *
 * @example
 * // Update with array of keys
 *
 * const creatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
 *
 * const newCat = {id: 1, type: 'lion', name: 'Bella'};
 *
 * const updatedCreatures = update(creatures, newCat, ['id', 'name']);
 *
 * // updatedCreatures will be:
 * // [{id: 1, type: 'lion', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
 *
 * @example
 * // Usage with RxState
 *
 * export class ListComponent {
 *
 *    readonly updateCreature$ = new Subject<Creature>();
 *
 *    constructor(private state: RxState<ComponentState>) {
 *      // Reactive implementation
 *      state.connect(
 *        'creatures',
 *        this.updateCreature$,
 *        ({ creatures }, creatureToUpdate) => {
 *            return update(creatures, creatureToUpdate, (a, b) => a.id === b.id);
 *        }
 *      );
 *    }
 *
 *    // Imperative implementation
 *    updateCreature(creatureToUpdate: Creature): void {
 *        this.state.set({ creatures: update(this.state.get().creatures, creatureToUpdate, (a, b) => a.id === b.id)});
 *    }
 * }
 *
 * @returns T[]
 *
 * @docsPage update
 * @docsCategory transformation-helpers
 */
function update(source, updates, compare) {
    const updatesDefined = updates != null;
    const updatesAsArray = updatesDefined
        ? Array.isArray(updates)
            ? updates
            : [updates]
        : [];
    const sourceDefined = source != null;
    const sourceIsArray = Array.isArray(source);
    const invalidInput = !sourceIsArray || source.length === 0 || updatesAsArray.length === 0;
    if (sourceDefined && !sourceIsArray) {
        console.warn(`Update: Original value (${source}) is not an array.`);
    }
    if (invalidInput) {
        return source;
    }
    return source.map((existingItem) => {
        const match = updatesAsArray.find((item) => valuesComparer(item, existingItem, compare));
        if (match) {
            return Object.assign(Object.assign({}, existingItem), match);
        }
        return existingItem;
    });
}

/**
 * @description
 * Accepts an array of objects of type T and single key or array of keys (K extends keyof T).
 * The `exctract` method is pure and immutable, thus not touching the input values and returning a shallow
 * copy of the extracted source.
 *
 * @example
 *
 * const cats = [{id: 1, type: 'cat', name: 'Fluffy'}, {id: 2, type: 'cat', name: 'Emma'}];
 *
 * const catsWithoutTypes = extract(cats, ['name', 'id']);
 *
 * // catsWithoutTypes will be:
 * // [{id: 1, name: 'Fluffy'}, {id: 2, name: 'Emma'}];
 *
 * @example
 * // Usage with RxState
 *
 * export class AnimalsListComponent {
 *
 *    constructor(private state: RxState<ComponentState>, private api: ApiService) {
 *      state.connect(
 *        'animals'
 *        this.api.getAnimals(),
 *        (state, animals) => extract(animals, ['id', 'name'])
 *      );
 *    }
 * }
 *
 * @returns T
 *
 * @docsPage slice
 * @docsCategory transformation-helpers
 */
function extract(array, keys) {
    const arrayIsArray = isDefined(array) && Array.isArray(array);
    if (!arrayIsArray) {
        console.warn(`extract: original value (${array}) is not an array.`);
        return undefined;
    }
    const sanitizedKeys = (Array.isArray(keys) ? keys : [keys]).filter(k => isKeyOf(k) && array.some(i => k in i));
    const length = sanitizedKeys.length;
    if (!sanitizedKeys.length) {
        console.warn(`extract: provided keys not found`);
        return undefined;
    }
    return array.map(item => {
        let i = 0;
        const result = {};
        for (i; i < length; i++) {
            result[sanitizedKeys[i]] = item[sanitizedKeys[i]];
        }
        return result;
    });
}

/**
 * @description
 * Updates or inserts (if does not exist) one or multiple items in an array T[].
 * For comparison you can provide a key, an array of keys or a custom comparison function that should return true if
 * items match.
 * If no comparison is provided, an equality check is used by default.
 * upsert is `pure` and `immutable`, your inputs won't be changed
 *
 *
 * @example
 * // Upsert (update) with key
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
 *
 * const newCat = {id: 1, type: 'lion'};
 *
 * const updatedCreatures = upsert(creatures, newCat, 'id');
 *
 * // updatedCreatures will be:
 * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];
 *
 * @example
 * // Upsert (insert) with key
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
 *
 * const newCat = {id: 3, type: 'lion'};
 *
 * const updatedCreatures = upsert(creatures, newCat, 'id');
 *
 * // updatedCreatures will be:
 * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];
 *
 * @example
 * // Upsert (update) with array of keys
 *
 * const creatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
 *
 * const newCat = {id: 1, type: 'lion', name: 'Bella'};
 *
 * const updatedCreatures = upsert(creatures, newCat, ['id', 'name']);
 *
 * // updatedCreatures will be:
 * // [{id: 1, type: 'lion', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
 *
 * @example
 * // Update (insert) with comparison function
 *
 * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
 *
 * const newCat = {id: 3, type: 'lion'};
 *
 * const updatedCreatures = upsert(creatures, newCat, (a, b) => a.id === b.id);
 *
 * // updatedCreatures will be:
 * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];
 *
 * @example
 * // Usage with RxState
 *
 * export class ListComponent {
 *
 *    // trigger which gets called on add/update (for reactive implementation)
 *    readonly addOrUpdateCreature = new Subject<Creature>();
 *
 *    constructor(private state: RxState<ComponentState>) {
 *      const initialCreatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
 *      state.set({ creatures: initialCreatures });
 *      // Reactive implementation
 *      state.connect(
 *        'creatures',
 *        this.addOrUpdateCreature,
 *        ({ creatures }, creatureToUpsert) => {
 *            return upsert(creatures, creatureToUpsert, 'id');
 *        }
 *      );
 *    }
 *
 *    // Imperative implementation
 *    updateCreature(creatureToUpdate: Creature): void {
 *        this.state.set({ creatures: upsert(this.state.get('creatures'), creatureToUpdate, 'id')});
 *    }
 * }
 *
 * @returns T[]
 *
 * @docsPage upsert
 * @docsCategory transformation-helpers
 */
function upsert(source, update, compare) {
    // check inputs for validity
    const updatesAsArray = update != null ? (Array.isArray(update) ? update : [update]) : [];
    // check inputs for validity
    const sourceIsArray = Array.isArray(source);
    const invalidInput = !sourceIsArray && updatesAsArray.length === 0;
    // if the source value is not an Array or the input is not defined return the original source
    // this is the case for any edge case:
    // '', null, undefined, CustomObjectOfDoomAndDarkness, ...
    if (invalidInput) {
        return source;
    }
    // if source is empty array or not an array, but the updates are valid:
    // return a shallow copy of the updates as result
    if (updatesAsArray.length > 0 && (!sourceIsArray || source.length === 0)) {
        return [...updatesAsArray];
    }
    const inserts = [];
    const updates = {};
    // process updates/inserts
    updatesAsArray.forEach((item) => {
        const match = source.findIndex((sourceItem) => valuesComparer(item, sourceItem, compare));
        // if item already exists, save it as update
        if (match !== -1) {
            updates[match] = item;
        }
        else {
            // otherwise consider this as insert
            if (isObjectGuard(item)) {
                // create a shallow copy if item is an object
                inserts.push(Object.assign({}, item));
            }
            else {
                // otherwise just push it
                inserts.push(item);
            }
        }
    });
    let updated = source;
    if (Object.keys(updates).length > 0) {
        // if we have updates to process
        updated = updated.map((item, i) => {
            const updatedItem = updates[i];
            // process the updated
            if (updatedItem != null) {
                if (isObjectGuard(item)) {
                    return Object.assign(Object.assign({}, item), updatedItem);
                }
                else {
                    return updatedItem;
                }
            }
            return item;
        });
    }
    // return the combination of the updated source & the inserts as new array
    return [...updated, ...inserts];
}

/**
 * @description
 * Accepts an object of type T and key of type K extends keyof T.
 * Removes property from an object and returns a shallow copy of the updated object without specified property.
 * If property not found returns copy of the original object.
 * Not mutating original object.
 *
 * @example
 *
 * const cat = {id: 1, type: 'cat', name: 'Fluffy'};
 *
 * const anonymusCat = deleteProp(cat, 'name');
 *
 * // anonymusCat will be:
 * // {id: 1, type: 'cat'};
 *
 * @example
 * // Usage with RxState
 *
 * export class ProfileComponent {
 *
 *    readonly removeName$ = new Subject();
 *
 *    constructor(private state: RxState<ComponentState>) {
 *      // Reactive implementation
 *      state.connect(
 *        this.removeName$,
 *        (state) => {
 *            return deleteProp(state, 'name');
 *        }
 *      );
 *    }
 *
 *    // Imperative implementation
 *    removeName(): void {
 *        this.state.set(remove(this.get(), 'name'));
 *    }
 * }
 *
 * @returns Omit<T, K>
 *
 * @docsPage deleteProp
 * @docsCategory transformation-helpers
 */
function deleteProp(object, key) {
    if (!isDefined(object) || !isObjectGuard(object)) {
        console.warn(`DeleteProp: original value ${object} is not an object.`);
        return object;
    }
    if (!isKeyOf(key)) {
        console.warn(`DeleteProp: provided key is not a string, number or symbol.`);
        return Object.assign({}, object);
    }
    const copy = Object.assign({}, object);
    delete copy[key];
    return copy;
}

/**
 * @description
 * Converts a dictionary of type {[key: string]: T} to array T[].
 *
 * @example
 *
 * const creaturesDictionary = {
 *   '1': {id: 1, type: 'cat'},
 *   '2': {id: 2, type: 'dog'},
 *   '3': {id: 3, type: 'parrot'}
 * };
 *
 * const creaturesArray = dictionaryToArray(creaturesDictionary);
 *
 * // creaturesArray will be:
 * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'parrot'}];
 *
 * @example
 * // Usage with RxState
 *
 * export class ListComponent {
 *    readonly removeName$ = new Subject();
 *
 *    constructor(
 *      private state: RxState<ComponentState>,
 *      private api: ApiService
 *    ) {
 *      // Reactive implementation
 *      state.connect(
 *        'creatures',
 *        this.api.creaturesDictionary$,
 *        (_, creatures) => {
 *            return dictionaryToArray(creatures);
 *        }
 *      );
 *    }
 *
 *    // Imperative implementation
 *    removeName(): void {
 *      this.api.creaturesDictionary$.pipe(
 *        // subscription handling logic
 *      ).subscribe(
 *        dictionary => this.set({creatures: dictionaryToArray(dictionary)})
 *      );
 *    }
 * }
 *
 * @returns T[];
 *
 * @docsPage dictionaryToArray
 * @docsCategory transformation-helpers
 */
function dictionaryToArray(dictionary) {
    if (!isDefined(dictionary)) {
        return dictionary;
    }
    if (!isObjectGuard(dictionary)) {
        console.warn(`DictionaryToArray: unexpected input.`);
        return [];
    }
    return Object.values(dictionary);
}

/**
 * @description
 * Merges an object of type T with updates of type Partial<T>.
 * Returns a new object where updates override original values while not mutating the original one.

 * @example
 * interface Creature {
 *  id: number,
 *  type: string,
 *  name: string
 * }
 *
 * const cat = {id: 1, type: 'cat'};
 *
 * const catWithname = patch(cat, {name: 'Fluffy'});
 *
 * // catWithname will be:
 * // {id: 1, type: 'cat', name: 'Fluffy'};
 *
 * @example
 * // Usage with RxState
 *
 * export class ProfileComponent {
 *
 *    readonly changeName$ = new Subject<string>();
 *
 *    constructor(private state: RxState<ComponentState>) {
 *      // Reactive implementation
 *      state.connect(
 *        this.changeName$,
 *        (state, name) => {
 *            return patch(state, { name });
 *        }
 *      );
 *    }
 *
 *    // Imperative implementation
 *    changeName(name: string): void {
 *        this.state.set(patch(this.get(), { name }));
 *    }
 * }
 *
 * @returns T
 *
 * @docsPage patch
 * @docsCategory transformation-helpers
 */
function patch(object, upd) {
    const update = isObjectGuard(upd) ? upd : {};
    if (!isObjectGuard(object) && isObjectGuard(upd)) {
        console.warn(`Patch: original value ${object} is not an object.`);
        return Object.assign({}, update);
    }
    if (!isObjectGuard(object) && !isObjectGuard(upd)) {
        console.warn(`Patch: original value ${object} and updates ${upd} are not objects.`);
        return object;
    }
    return Object.assign(Object.assign({}, object), update);
}

/**
 * @description
 * Accepts an object of type T, key of type K extends keyof T, and value of type T[K].
 * Sets the property and returns a newly updated shallow copy of an object while not mutating the original one.
 *
 * @example
 *
 * const cat = {id: 1, type: 'cat', name: 'Fluffy'};
 *
 * const renamedCat = setProp(cat, 'name', 'Bella');
 *
 * // renamedCat will be:
 * // {id: 1, type: 'cat', name: 'Bella'};
 *
 * @example
 * // Usage with RxState
 *
 * export class ProfileComponent {
 *
 *    readonly changeName$ = new Subject<string>();
 *
 *    constructor(private state: RxState<ComponentState>) {
 *      // Reactive implementation
 *      state.connect(
 *        this.changeName$,
 *        (state, name) => {
 *            return setProp(state, 'name', name);
 *        }
 *      );
 *    }
 *
 *    // Imperative implementation
 *    changeName(name: string): void {
 *        this.state.set(setProp(this.get(), 'name', name));
 *    }
 * }
 *
 * @returns T
 *
 * @docsPage setProp
 * @docsCategory transformation-helpers
 */
function setProp(object, key, value) {
    const objectIsObject = isObjectGuard(object);
    const keyIsValid = isKeyOf(key);
    const initialObject = objectIsObject ? object : {};
    if (!objectIsObject) {
        console.warn(`SetProp: original value (${object}) is not an object.`);
    }
    if (!keyIsValid) {
        console.warn(`SetProp: key argument (${key}) is invalid.`);
    }
    if (!isDefined(object) && !keyIsValid) {
        return object;
    }
    if (keyIsValid) {
        return Object.assign(Object.assign({}, initialObject), { [key]: value });
    }
    return Object.assign({}, initialObject);
}

/**
 * @description
 * Toggles a boolean property in the object.
 * Accepts object of type T and key value of which is boolean.
 * Toggles the property and returns a shallow copy of an object, while not mutating the original one.
 *
 * @example
 *
 * const state = {items: [1,2,3], loading: true};
 *
 * const updatedState = toggle(state, 'loading');
 *
 * // updatedState will be:
 * // {items: [1,2,3], loading: false};
 *
 * @example
 * // Usage with RxState
 *
 * export class ListComponent {
 *    readonly loadingChange$ = new Subject();
 *
 *    constructor(
 *      private state: RxState<ComponentState>
 *    ) {
 *      // Reactive implementation
 *      state.connect(
 *        this.api.loadingChange$,
 *        (state, _) => {
 *            return toggle(state, 'isLoading');
 *        }
 *      );
 *    }
 *
 *    // Imperative implementation
 *    toggleLoading(): void {
 *      this.set(toggle(state, 'isLoading'));
 *    }
 * }
 *
 * @returns T
 *
 * @docsPage toggle
 * @docsCategory transformation-helpers
 */
function toggle(object, key) {
    const objectIsObject = isObjectGuard(object);
    const keyIsValid = isKeyOf(key);
    const initialObject = objectIsObject ? object : {};
    if (!objectIsObject) {
        console.warn(`Toggle: original value (${object}) is not an object.`);
    }
    if (!keyIsValid) {
        console.warn(`Toggle: key argument (${key}) is invalid.`);
    }
    if (keyIsValid && typeof initialObject[key] !== 'boolean') {
        console.warn(`Toggle: value of the key (${key}) is not a boolean.`);
    }
    if (!isDefined(object) && !keyIsValid) {
        return object;
    }
    if (keyIsValid &&
        (typeof initialObject[key] === 'boolean' ||
            !initialObject.hasOwnProperty(key))) {
        return Object.assign(Object.assign({}, initialObject), { [key]: !initialObject[key] });
    }
    return Object.assign({}, initialObject);
}

/**
 * @description
 * Accepts an object of type T and single key or array of keys (K extends keyof T).
 * Constructs new object based on provided keys.
 *
 * @example
 *
 * const cat = {id: 1, type: 'cat', name: 'Fluffy'};
 *
 * const catWithoutType = slice(cat, ['name', 'id']);
 *
 * // catWithoutType will be:
 * // {id: 1, name: 'Fluffy'};
 *
 * @example
 * // Usage with RxState
 *
 * export class AnimalsListComponent {
 *
 *    constructor(private state: RxState<ComponentState>, private api: ApiService) {
 *      state.connect(
 *        'animals'
 *        this.api.getAnimals(),
 *        (state, animals) => {
 *            return animals.map(animal => slice(animal, ['id', 'name']));
 *        }
 *      );
 *    }
 * }
 *
 * @returns T
 *
 * @docsPage slice
 * @docsCategory transformation-helpers
 */
function slice(object, keys) {
    const objectIsObject = isDefined(object) && isObjectGuard(object);
    if (!objectIsObject) {
        console.warn(`slice: original value (${object}) is not an object.`);
        return undefined;
    }
    const sanitizedKeys = (Array.isArray(keys) ? keys : [keys]).filter((k) => isKeyOf(k) && k in object);
    if (!sanitizedKeys.length) {
        console.warn(`slice: provided keys not found`);
        return undefined;
    }
    return sanitizedKeys.reduce((acc, k) => (Object.assign(Object.assign({}, acc), { [k]: object[k] })), {});
}

/**
 * Generated bundle index. Do not edit.
 */

export { RxState, createAccumulationObservable, createSideEffectObservable, deleteProp, dictionaryToArray, distinctUntilSomeChanged, extract, insert, patch, remove, select, selectSlice, setProp, slice, stateful, toDictionary, toggle, update, upsert };
//# sourceMappingURL=state.js.map
