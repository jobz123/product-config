{"version":3,"file":"state.js","sources":["../../../../libs/state/src/lib/cdk/accumulation-observable.ts","../../../../libs/state/src/lib/cdk/side-effect-observable.ts","../../../../libs/state/src/lib/core/utils/pipe-from-array.ts","../../../../libs/state/src/lib/core/utils/guards.ts","../../../../libs/state/src/lib/core/utils/safe-pluck.ts","../../../../libs/state/src/lib/rxjs/operators/stateful.ts","../../../../libs/state/src/lib/rxjs/operators/select.ts","../../../../libs/state/src/lib/rxjs/operators/distinctUntilSomeChanged.ts","../../../../libs/state/src/lib/rxjs/operators/selectSlice.ts","../../../../libs/state/src/lib/rx-state.service.ts","../../../../libs/state/src/lib/transformation-helpers/array/insert.ts","../../../../libs/state/src/lib/transformation-helpers/_internals/valuesComparer.util.ts","../../../../libs/state/src/lib/transformation-helpers/array/remove.ts","../../../../libs/state/src/lib/transformation-helpers/array/toDictionary.ts","../../../../libs/state/src/lib/transformation-helpers/array/update.ts","../../../../libs/state/src/lib/transformation-helpers/array/extract.ts","../../../../libs/state/src/lib/transformation-helpers/array/upsert.ts","../../../../libs/state/src/lib/transformation-helpers/object/deleteProp.ts","../../../../libs/state/src/lib/transformation-helpers/object/dictionaryToArray.ts","../../../../libs/state/src/lib/transformation-helpers/object/patch.ts","../../../../libs/state/src/lib/transformation-helpers/object/setProp.ts","../../../../libs/state/src/lib/transformation-helpers/object/toggle.ts","../../../../libs/state/src/lib/transformation-helpers/object/slice.ts","../../../../libs/state/src/state.ts"],"sourcesContent":["import {\r\n  BehaviorSubject,\r\n  ConnectableObservable,\r\n  EMPTY,\r\n  merge,\r\n  Observable,\r\n  queueScheduler,\r\n  Subject,\r\n  Subscribable,\r\n  Subscription,\r\n} from 'rxjs';\r\nimport {\r\n  catchError,\r\n  distinctUntilChanged,\r\n  mergeAll,\r\n  observeOn,\r\n  publish,\r\n  publishReplay,\r\n  scan,\r\n  tap,\r\n  withLatestFrom\r\n} from 'rxjs/operators';\r\n\r\nexport type AccumulationFn = <T>(st: T, sl: Partial<T>) => T;\r\n\r\nconst defaultAccumulator: AccumulationFn = <T>(st: T, sl: Partial<T>): T => {\r\n  return { ...st, ...sl };\r\n};\r\n\r\ninterface Accumulator<T> extends Subscribable<T> {\r\n  state: T;\r\n  state$: Observable<T>;\r\n  signal$: Observable<T>;\r\n  subscribe: () => Subscription;\r\n  nextSlice: (stateSlice: Partial<T>) => void;\r\n  nextSliceObservable: (state$: Observable<Partial<T>>) => void;\r\n  nextAccumulator: (fn: AccumulationFn) => void;\r\n}\r\n\r\nexport function createAccumulationObservable<T extends object>(\r\n  stateObservables = new Subject<Observable<Partial<T>>>(),\r\n  stateSlices = new Subject<Partial<T>>(),\r\n  accumulatorObservable = new BehaviorSubject(defaultAccumulator)\r\n): Accumulator<T> {\r\n  const signal$ = merge(\r\n    stateObservables.pipe(\r\n      distinctUntilChanged(),\r\n      mergeAll(),\r\n      observeOn(queueScheduler)\r\n    ),\r\n    stateSlices.pipe(observeOn(queueScheduler))\r\n  ).pipe(\r\n    withLatestFrom(accumulatorObservable.pipe(observeOn(queueScheduler))),\r\n    scan(\r\n      (state, [slice, stateAccumulator]) => stateAccumulator(state, slice),\r\n      {} as T\r\n    ),\r\n    tap(\r\n      (newState) => (compositionObservable.state = newState),\r\n      (error) => console.error(error)\r\n    ),\r\n    // @Notice We catch the error here as it get lost in between `publish` and `publishReplay`. We return empty to\r\n    catchError((e) => EMPTY),\r\n    publish()\r\n  );\r\n  const state$: Observable<T> = signal$.pipe(publishReplay(1));\r\n  const compositionObservable: Accumulator<T> = {\r\n    state: {} as T,\r\n    signal$,\r\n    state$,\r\n    nextSlice,\r\n    nextSliceObservable,\r\n    nextAccumulator,\r\n    subscribe\r\n  };\r\n\r\n  // ======\r\n\r\n  return compositionObservable;\r\n\r\n  // ======\r\n\r\n  function nextAccumulator(accumulatorFn: AccumulationFn): void {\r\n    accumulatorObservable.next(accumulatorFn);\r\n  }\r\n\r\n  function nextSlice(stateSlice: Partial<T>): void {\r\n    stateSlices.next(stateSlice);\r\n  }\r\n\r\n  function nextSliceObservable(stateObservable: Observable<Partial<T>>): void {\r\n    stateObservables.next(stateObservable);\r\n  }\r\n\r\n  function subscribe(): Subscription {\r\n    const sub = (compositionObservable.signal$ as ConnectableObservable<T>).connect();\r\n    sub.add(\r\n      (compositionObservable.state$ as ConnectableObservable<T>).connect()\r\n    );\r\n    sub.add(() => {\r\n      accumulatorObservable.complete();\r\n      stateObservables.complete();\r\n      stateSlices.complete();\r\n    });\r\n    return sub;\r\n  }\r\n}\r\n","import { merge, Observable, queueScheduler, Subject, Subscribable, Subscription, Observer } from 'rxjs';\r\nimport { mergeAll, observeOn } from 'rxjs/operators';\r\n\r\nexport function createSideEffectObservable<T>(\r\n  stateObservables = new Subject<Observable<T>>()\r\n): {\r\n  effects$: Observable<T>;\r\n  nextEffectObservable: (effect$: Observable<T>) => void;\r\n  subscribe: () => Subscription;\r\n} & Subscribable<T> {\r\n  const effects$: Observable<T> = merge(\r\n    stateObservables.pipe(mergeAll(), observeOn(queueScheduler))\r\n  );\r\n\r\n  function nextEffectObservable(effect$: Observable<T>): void {\r\n    stateObservables.next(effect$);\r\n  }\r\n\r\n  function subscribe(): Subscription {\r\n    return effects$.subscribe();\r\n  }\r\n\r\n  return {\r\n    effects$,\r\n    nextEffectObservable,\r\n    subscribe\r\n  };\r\n}\r\n","import { noop, UnaryFunction } from 'rxjs';\r\n\r\nexport function pipeFromArray<T, R>(\r\n  fns: Array<UnaryFunction<T, R>>\r\n): UnaryFunction<T, R> {\r\n  if (!fns) {\r\n    return noop as UnaryFunction<any, any>;\r\n  }\r\n\r\n  if (fns.length === 1) {\r\n    return fns[0];\r\n  }\r\n\r\n  return function piped(input: T): R {\r\n    return fns.reduce(\r\n      (prev: any, fn: UnaryFunction<T, R>) => fn(prev),\r\n      input as any\r\n    );\r\n  };\r\n}\r\n","import { OperatorFunction } from 'rxjs';\r\n\r\nexport function isPromiseGuard<T>(value: unknown): value is Promise<T> {\r\n  return (\r\n    !!value &&\r\n    typeof (<any>value).subscribe !== 'function' &&\r\n    typeof (value as any).then === 'function'\r\n  );\r\n}\r\n\r\nexport function isOperateFnArrayGuard<T, R = T>(\r\n  op: any[]\r\n): op is OperatorFunction<T, R>[] {\r\n  if (!Array.isArray(op)) {\r\n    return false;\r\n  }\r\n  return op.length > 0 && op.every((i: any) => typeof i === 'function');\r\n}\r\n\r\nexport function isStringArrayGuard(op: any[]): op is string[] {\r\n  if (!Array.isArray(op)) {\r\n    return false;\r\n  }\r\n  return op.length > 0 && op.every((i: any) => typeof i === 'string');\r\n}\r\n\r\nexport function isIterableGuard<T>(obj: unknown): obj is Array<T> {\r\n  if (obj === null || obj === undefined) {\r\n    return false;\r\n  }\r\n  return typeof (obj as any)[Symbol.iterator] === 'function';\r\n}\r\n\r\nexport function isKeyOf<O>(k: unknown): k is keyof O {\r\n  return (\r\n    !!k &&\r\n    (typeof k === 'string' || typeof k === 'symbol' || typeof k === 'number')\r\n  );\r\n}\r\n\r\nexport function isObjectGuard(obj: unknown): obj is object {\r\n  return !!obj && typeof obj === 'object' && !Array.isArray(obj);\r\n}\r\n\r\nexport function isDefined(val: unknown): val is NonNullable<any> {\r\n  return val !== null && val !== undefined;\r\n}\r\n","import { isDefined, isKeyOf, isObjectGuard } from './guards';\r\n\r\nexport function safePluck<T extends object, K1 extends keyof T>(\r\n  stateObject: T,\r\n  keys: K1 | [K1]\r\n): T[K1];\r\n\r\nexport function safePluck<T extends object,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1]>(stateObject: T, keys: [K1, K2]): T[K1][K2];\r\n\r\nexport function safePluck<T extends object,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2]>(stateObject: T, keys: [K1, K2, K3]): T[K1][K2][K3];\r\n\r\nexport function safePluck<T extends object,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3]>(stateObject: T, keys: [K1, K2, K3, K4]): T[K1][K2][K3][K4];\r\n\r\nexport function safePluck<T extends object,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4]>(stateObject: T, keys: [K1, K2, K3, K4, K5]): T[K1][K2][K3][K4][K5];\r\n\r\nexport function safePluck<T extends object,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4],\r\n  K6 extends keyof T[K1][K2][K3][K4][K5]>(\r\n  stateObject: T,\r\n  keys:\r\n    | [K1]\r\n    | [K1, K2]\r\n    | [K1, K2, K3]\r\n    | [K1, K2, K3, K4]\r\n    | [K1, K2, K3, K4, K5]\r\n    | [K1, K2, K3, K4, K5, K6]\r\n): T[K1][K2][K3][K4][K5][K6];\r\n\r\nexport function safePluck<T extends object,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4],\r\n  K6 extends keyof T[K1][K2][K3][K4][K5]>(\r\n  stateObject: T,\r\n  keys:\r\n    | [K1]\r\n    | [K1, K2]\r\n    | [K1, K2, K3]\r\n    | [K1, K2, K3, K4]\r\n    | [K1, K2, K3, K4, K5]\r\n    | [K1, K2, K3, K4, K5, K6]\r\n):\r\n  | T[K1]\r\n  | T[K1][K2]\r\n  | T[K1][K2][K3]\r\n  | T[K1][K2][K3][K4]\r\n  | T[K1][K2][K3][K4][K5]\r\n  | T[K1][K2][K3][K4][K5][K6]\r\n  | null\r\n  | undefined {\r\n  // needed to match null and undefined conventions of RxAngular core components\r\n  // safePluck(null) -> return null\r\n  // safePluck(undefined) -> return undefined\r\n  // safePluck(obj, ['wrongKey']) -> return undefined\r\n  // safePluck(obj, ['correctKey']) -> return value of key\r\n  // safePluck(obj, '') -> return undefined\r\n  // safePluck(obj, null) -> return undefined\r\n  if (!isDefined(stateObject)) {\r\n    return stateObject;\r\n  }\r\n  if (!isDefined(keys)) {\r\n    return undefined;\r\n  }\r\n  // sanitize keys -> keep only valid keys (string, number, symbol)\r\n  const keysArr = (Array.isArray(keys) ? keys : [keys]).filter(k =>\r\n    isKeyOf<T>(k)\r\n  );\r\n  if (\r\n    keysArr.length === 0 ||\r\n    !isObjectGuard(stateObject) ||\r\n    Object.keys(stateObject).length === 0\r\n  ) {\r\n    return undefined;\r\n  }\r\n  let prop = stateObject[keysArr.shift() as K1];\r\n\r\n  keysArr.forEach(key => {\r\n    if (isObjectGuard(prop) && isKeyOf(key)) {\r\n      prop = prop[key];\r\n    }\r\n  });\r\n  return prop;\r\n}\r\n","import { MonoTypeOperatorFunction, Observable, OperatorFunction } from 'rxjs';\r\nimport { distinctUntilChanged, filter, shareReplay } from 'rxjs/operators';\r\nimport { isOperateFnArrayGuard, pipeFromArray } from '../../core/utils';\r\n\r\n/**\r\n * @description\r\n *\r\n * As the name `stateful` implies this operator is useful when you process an Observable which maintains state.\r\n *\r\n * Maintaining state as an `Observable` source comes with a handful of repetitive as well as use case specific tasks.\r\n *\r\n * It acts like the Observables `pipe` method.\r\n * It accepts RxJS operators and composes them like `Observable#pipe` and the standalone `pipe` method.\r\n *\r\n * Furthermore, it takes care of the above mentioned repetitive tasks as listed below.\r\n *\r\n * You will always (aka repetitive) want to ensure that:\r\n * - only distinct state changes are emitted\r\n * - only defined values are emitted (filter out undefined, which ensures lazy state)\r\n * - share and replay custom operations for multiple subscribers (saves performance)\r\n *\r\n * You will sometimes (aka situational) need:\r\n * - a subset of the state (derivations)\r\n * - compose the state with other Observables or change the Observables behaviour\r\n *\r\n *\r\n * @example\r\n * import { Observable } from 'rxjs';\r\n * import { map } from 'rxjs/operators';\r\n * import { stateful } from 'rx-angular/state';\r\n *\r\n * const state$: Observable<{ name: string; items: string[] }>;\r\n * const derivation$ = state$.pipe(\r\n *   stateful(\r\n *     map(state => state.list.length),\r\n *     filter(length => length > 3)\r\n *   )\r\n * );\r\n *\r\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\r\n * @return OperatorFunction<T, A>\r\n *\r\n * @docsPage stateful\r\n * @docsCategory operators\r\n */\r\nexport function stateful<T>(): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A>(\r\n  op: OperatorFunction<T, A>\r\n): OperatorFunction<T, A>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>\r\n): OperatorFunction<T, B>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>\r\n): OperatorFunction<T, C>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C, D>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>\r\n): OperatorFunction<T, D>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C, D, E>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>,\r\n  op5: OperatorFunction<D, E>\r\n): OperatorFunction<T, E>;\r\n/**\r\n * @description\r\n *\r\n * As it acts like the Observables `pipe` method, it accepts one or many RxJS operators as params.\r\n *\r\n * @example\r\n * import { Observable } from 'rxjs';\r\n * import { map } from 'rxjs/operators';\r\n * import { stateful } from 'rx-angular/state';\r\n *\r\n * const state$: Observable<{ name: string; items: string[] }>;\r\n * const derivation$ = state$.pipe(\r\n *   stateful(\r\n *     map(state => state.list.length),\r\n *     filter(length => length > 3)\r\n *   )\r\n * );\r\n *\r\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\r\n *\r\n * @docsPage stateful\r\n * @docsCategory operators\r\n */\r\nexport function stateful<T, R>(\r\n  ...optionalDerive: OperatorFunction<T, R>[]\r\n): OperatorFunction<T, T | R> {\r\n  return (s: Observable<T>): Observable<T | R> => {\r\n    return s.pipe(\r\n      // distinct same base-state objects (e.g. a default emission of default switch cases, incorrect mutable handling\r\n      // of data) @TODO evaluate benefits vs. overhead\r\n      distinctUntilChanged(),\r\n      // CUSTOM LOGIC HERE\r\n      (o: Observable<T>): Observable<T | R> => {\r\n        if (isOperateFnArrayGuard(optionalDerive)) {\r\n          return o.pipe(pipeFromArray(optionalDerive));\r\n        }\r\n        return o;\r\n      },\r\n      // initial emissions, undefined is no base-state, pollution with skip(1)\r\n      filter((v) => v !== undefined),\r\n      // distinct same derivation value\r\n      distinctUntilChanged(),\r\n      // reuse custom operations result for multiple subscribers and reemit the last calculated value.\r\n      shareReplay({ bufferSize: 1, refCount: true })\r\n    );\r\n  };\r\n}\r\n","import { MonoTypeOperatorFunction, Observable, OperatorFunction } from 'rxjs';\r\nimport { pluck } from 'rxjs/operators';\r\nimport { isOperateFnArrayGuard, isStringArrayGuard, pipeFromArray } from '../../core/utils';\r\nimport { stateful } from './stateful';\r\n\r\n/**\r\n * @description\r\n * returns the state as shared, replayed and distinct `Observable<T>`. This way you don't have to think about late\r\n * subscribers, multiple subscribers or multiple emissions of the same value.\r\n *\r\n * @example\r\n * const state$ = state.pipe(select());\r\n * state$.subscribe(state => doStuff(state));\r\n *\r\n * @returns Observable<T>\r\n */\r\n\r\nexport function select<T>(): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * @description\r\n * returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\r\n * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\r\n *\r\n * @example\r\n * const profilePicture$ = state.pipe(\r\n *   select(\r\n *    pluck('profilePicture'),\r\n *    switchMap(profilePicture => mapImageAsync(profilePicture))\r\n *   )\r\n * );\r\n * @param  { OperatorFunction<T, A> } op\r\n * @returns Observable<A>\r\n *\r\n * @docsPage select\r\n * @docsCategory operators\r\n */\r\nexport function select<T, A>(\r\n  op: OperatorFunction<T, A>\r\n): OperatorFunction<T, A>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>\r\n): OperatorFunction<T, B>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>\r\n): OperatorFunction<T, C>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C, D>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>\r\n): OperatorFunction<T, D>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C, D, E>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>,\r\n  op5: OperatorFunction<D, E>\r\n): OperatorFunction<T, E>;\r\n\r\n/**\r\n * @description\r\n * Access a single property of the state by providing keys.\r\n * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\r\n *\r\n * @example\r\n *  // Access a single property\r\n * const bar$ = state$.pipe(select('bar'));\r\n *\r\n * // Access a nested property\r\n * const foo$ = state$.pipe(select('bar', 'foo'));\r\n *\r\n * @return Observable<T[K1]>\r\n */\r\nexport function select<T, K1 extends keyof T>(\r\n  k1: K1\r\n): OperatorFunction<T, T[K1]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, K1 extends keyof T, K2 extends keyof T[K1]>(\r\n  k1: K1,\r\n  k2: K2\r\n): OperatorFunction<T, T[K1][K2]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2]>(k1: K1, k2: K2, k3: K3): OperatorFunction<T, T[K1][K2][K3]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3]>(k1: K1, k2: K2, k3: K3, k4: K4): OperatorFunction<T, T[K1][K2][K3][K4]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4]>(\r\n  k1: K1,\r\n  k2: K2,\r\n  k3: K3,\r\n  k4: K4,\r\n  k5: K5\r\n): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4],\r\n  K6 extends keyof T[K1][K2][K3][K4][K5]>(\r\n  k1: K1,\r\n  k2: K2,\r\n  k3: K3,\r\n  k4: K4,\r\n  k5: K5,\r\n  k6: K6\r\n): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function select<T>(\r\n  ...opOrMapFn: OperatorFunction<T, any>[] | string[]\r\n): OperatorFunction<T, any> {\r\n  return (state$: Observable<T>) => {\r\n    if (!opOrMapFn || opOrMapFn.length === 0) {\r\n      return state$.pipe(stateful());\r\n    } else if (isStringArrayGuard(opOrMapFn)) {\r\n      return state$.pipe(stateful(pluck(...opOrMapFn)));\r\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\r\n      return state$.pipe(stateful(pipeFromArray(opOrMapFn)));\r\n    } else {\r\n      throw new Error('wrong params passed to select');\r\n    }\r\n  };\r\n}\r\n","import { MonoTypeOperatorFunction } from 'rxjs';\r\nimport { distinctUntilChanged } from 'rxjs/operators';\r\nimport { CompareFn, KeyCompareMap } from '../interfaces';\r\nimport { safePluck } from '../../core/utils/safe-pluck';\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction defaultCompare<T>(oldVal: T, newVal: T): boolean {\r\n  return oldVal === newVal;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\r\n * the previous item. Comparison will be done for each set key in the `keys` array.\r\n *\r\n * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute\r\n * explicitly different\r\n *\r\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\r\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\r\n * compute if values are distinct or not.\r\n *\r\n * @example\r\n *\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\r\n *\r\n * interface Person {\r\n *    age: number;\r\n *    name: string;\r\n * }\r\n *\r\n * of(\r\n *   { age: 4, name: 'Hans'},\r\n *   { age: 7, name: 'Sophie'},\r\n *   { age: 5, name: 'Han Solo'},\r\n *   { age: 5, name: 'HanSophie'},\r\n * ).pipe(\r\n *   distinctUntilSomeChanged(['age', 'name']),\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Hans'}\r\n * // { age: 7, name: 'Sophie'}\r\n * // { age: 5, name: 'Han Solo'}\r\n * // { age: 5, name: 'HanSophie'}\r\n *\r\n * @example\r\n * // An example with `KeyCompareMap`\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rxjs/operators';\r\n *\r\n * interface Person {\r\n *     age: number;\r\n *     name: string;\r\n *  }\r\n * const customComparison: KeyCompareMap<Person> = {\r\n *   name: (oldName, newName) => oldName.substring(0, 2) === newName.substring(0, 2)\r\n * };\r\n *\r\n * of(\r\n *     { age: 4, name: 'Hans'},\r\n *     { age: 7, name: 'Sophie'},\r\n *     { age: 5, name: 'Han Solo'},\r\n *     { age: 5, name: 'HanSophie'},\r\n *   ).pipe(\r\n *     distinctUntilSomeChanged(['age', 'name'], customComparison),\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Hans' }\r\n * // { age: 7, name: 'Sophie' }\r\n * // { age: 5, name: 'Han Solo' }\r\n *\r\n * @param {K[]} keys String key for object property lookup on each item.\r\n * @param {KeyCompareMap<T>} [compare] Optional KeyCompareMap to explicitly define comparisons for some of the keys\r\n * @docsPage distinctUntilSomeChanged\r\n * @docsCategory operators\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keys: K[],\r\n  keyCompareMap?: KeyCompareMap<T>\r\n): MonoTypeOperatorFunction<T> {\r\n  // default compare function applying === to every key\r\n  let distinctCompare: CompareFn<T> = (oldState, newState) =>\r\n    keys.some(\r\n      (key) =>\r\n        !defaultCompare(safePluck(oldState, [key]), safePluck(newState, [key]))\r\n    );\r\n\r\n  // generate compare function respecting every case of provided keyCompareMap\r\n  if (keyCompareMap !== undefined) {\r\n    const compare = (key: K) => {\r\n      return keyCompareMap.hasOwnProperty(key) &&\r\n      keyCompareMap[key] !== undefined\r\n        ? (keyCompareMap[key] as CompareFn<T[K]>)\r\n        : defaultCompare;\r\n    };\r\n    distinctCompare = (oldState, newState) => {\r\n      return keys.some(\r\n        (key) =>\r\n          !compare(key)(safePluck(oldState, [key]), safePluck(newState, [key]))\r\n      );\r\n    };\r\n  }\r\n  return distinctUntilChanged((oldV, newV) => !distinctCompare(oldV, newV));\r\n}\r\n","import { Observable, OperatorFunction } from 'rxjs';\r\nimport { filter, map } from 'rxjs/operators';\r\nimport { KeyCompareMap, PickSlice } from '../interfaces';\r\nimport { distinctUntilSomeChanged } from './distinctUntilSomeChanged';\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get\r\n * filtered to only emit _defined_ values as well as checked for distinct emissions.\r\n * Comparison will be done for each set key in the `keys` array.\r\n *\r\n * `selectSlice` will only emit _valid_ selections. A selection is _valid_ if every\r\n * selected key exists and is defined in the source Observable. This ensures that the `selectSlice`\r\n * operator will always return a complete slice with all values defined.\r\n *\r\n * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute\r\n * explicitly different\r\n *\r\n * @example\r\n *\r\n * // An example with a custom comparison applied to each key\r\n * import { of } from 'rxjs';\r\n * import { selectSlice } from 'rx-angular/state';\r\n *\r\n *\r\n * const state$: Observable<MyState> = of(\r\n *  { title: 'myTitle', panelOpen: true},\r\n *  { title: 'myTitle2', panelOpen: true},\r\n *  { title: 'newTitle', panelOpen: true},\r\n *  { title: 'newTitle', panelOpen: false}\r\n * )\r\n * .pipe(\r\n *     selectSlice(['title', 'panelOpen']),\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * //  { title: 'myTitle', panelOpen: true },\r\n * //  { title: 'myTitle2', panelOpen: true },\r\n * //  { title: 'newTitle', panelOpen: true },\r\n * //  { title: 'newTitle', panelOpen: false }\r\n *\r\n * @example\r\n *\r\n * import { of, Observable } from 'rxjs';\r\n * import { tap } from 'rxjs/operators';\r\n * import { selectSlice } from 'rx-angular/state';\r\n *\r\n * interface MyState {\r\n *    title: string;\r\n *    items: string[];\r\n *    panelOpen: boolean;\r\n * }\r\n * // Select items and title.\r\n * // apply custom compare logic for the items array\r\n * const customComparison: KeyCompareMap<MyState> = {\r\n *   items: (oldItems, newItems) => compareItems(oldItems, newItems)\r\n * };\r\n * const state$: Observable<MyState> = of(\r\n * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: true },\r\n * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: false },\r\n * { title: 'nextTitle', items: ['foo', 'baR'], panelOpen: true },\r\n * { title: 'nextTitle', items: ['fooRz', 'boo'], panelOpen: false },\r\n * );\r\n * const slice$ = state$.pipe(selectSlice(['title', 'items'], customComparison), tap(console.log)).subscribe();\r\n *\r\n * // displays:\r\n * // { title: 'myTitle', items: ['foo', 'bar'] }\r\n * // { title: 'nextTitle', items: ['foo', 'baR'] }\r\n * // { title: 'nextTitle', items: ['fooRz', 'boo'] }\r\n *\r\n * @param {(K)[]} keys - the array of keys which should be selected\r\n * @param {KeyCompareMap<{ [P in K]: T[P] }>} [keyCompareMap] Optional KeyCompareMap to provide custom compare logic\r\n * for some the keys\r\n * @docsPage selectSlice\r\n * @docsCategory operators\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T>(\r\n  keys: K[],\r\n  keyCompareMap?: KeyCompareMap<{ [P in K]: T[P] }>\r\n): OperatorFunction<T, PickSlice<T, K>> {\r\n  return (o$: Observable<T>): Observable<PickSlice<T, K>> =>\r\n    o$.pipe(\r\n      filter((state) => state !== undefined),\r\n      map((state) => {\r\n        // forward null\r\n        if (state === null) {\r\n          return null;\r\n        }\r\n        // an array of all keys which exist and are _defined_ in the state object\r\n        const definedKeys = keys\r\n          // filter out undefined properties e. g. {}, { str: undefined }\r\n          .filter((k) => state.hasOwnProperty(k) && state[k] !== undefined);\r\n\r\n        // we want to ensure to only emit _valid_ selections\r\n        // a selection is _valid_ if every selected key exists and has a value:\r\n\r\n        // {} => selectSlice(['foo']) => no emission\r\n        // {str: 'test'} => selectSlice([]) => no emission\r\n        // {str: 'test'} => selectSlice(['notPresent']) => no emission\r\n        // {str: 'test'} => state.select(selectSlice([])) => no emission\r\n        // {str: 'test'} => state.select(selectSlice(['notPresent'])) => no emission\r\n        // {str: undefined} => state.select(selectSlice(['str'])) => no emission\r\n        // {str: 'test', foo: undefined } => state.select(selectSlice(['foo'])) => no emission\r\n        if (definedKeys.length < keys.length) {\r\n          return undefined;\r\n        }\r\n\r\n        // create the selected slice\r\n        return definedKeys\r\n          .reduce((vm, key) => {\r\n            vm[key] = state[key];\r\n            return vm;\r\n          }, {} as PickSlice<T, K>);\r\n      }),\r\n      filter((v) => v !== undefined),\r\n      distinctUntilSomeChanged(keys, keyCompareMap)\r\n    );\r\n}\r\n\r\n","import { Injectable, OnDestroy } from '@angular/core';\r\nimport { EMPTY, isObservable, Observable, OperatorFunction, Subscribable, Subscription, Unsubscribable } from 'rxjs';\r\nimport { catchError, map, pluck, tap } from 'rxjs/operators';\r\nimport { isKeyOf, isOperateFnArrayGuard, isStringArrayGuard, pipeFromArray, safePluck } from './core';\r\nimport { AccumulationFn, createAccumulationObservable, createSideEffectObservable } from './cdk';\r\nimport { stateful } from './rxjs/operators';\r\n\r\ntype ProjectStateFn<T> = (oldState: T) => Partial<T>;\r\ntype ProjectValueFn<T, K extends keyof T> = (oldState: T) => T[K];\r\n\r\ntype ProjectStateReducer<T, V> = (oldState: T, value: V) => Partial<T>;\r\n\r\ntype ProjectValueReducer<T, K extends keyof T, V> = (\r\n  oldState: T,\r\n  value: V\r\n) => T[K];\r\n\r\n/**\r\n * @description\r\n * RxState is a light-weight reactive state management service for managing local state in angular.\r\n *\r\n * @example\r\n * Component({\r\n *   selector: 'app-stateful',\r\n *   template: `<div>{{ state$ | async | json }}</div>`,\r\n *   providers: [RxState]\r\n * })\r\n * export class StatefulComponent {\r\n *   readonly state$ = this.state.select();\r\n *\r\n *   constructor(private state: RxState<{ foo: string }>) {}\r\n * }\r\n *\r\n * @docsCategory RxState\r\n * @docsPage RxState\r\n */\r\n@Injectable()\r\nexport class RxState<T extends object> implements OnDestroy, Subscribable<T> {\r\n  private subscription = new Subscription();\r\n\r\n  private accumulator = createAccumulationObservable<T>();\r\n  private effectObservable = createSideEffectObservable();\r\n\r\n  /**\r\n   * @description\r\n   * The unmodified state exposed as `Observable<T>`. It is not shared, distinct or gets replayed.\r\n   * Use the `$` property if you want to read the state without having applied {@link stateful} to it.\r\n   */\r\n  readonly $: Observable<T> = this.accumulator.signal$;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  constructor() {\r\n    this.subscription.add(this.subscribe());\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  ngOnDestroy(): void {\r\n    this.subscription.unsubscribe();\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   *\r\n   * Allows to customize state accumulation function.\r\n   * This can be helpful to implement deep updates and tackle other immutability problems in a custom way.\r\n   * @example\r\n   *\r\n   * ```typescript\r\n   * const myAccumulator = (state: MyState, slice: Partial<MyState>) => deepCopy(state, slice);\r\n   *\r\n   * this.state.setAccumulator(myAccumulator);\r\n   * ```\r\n   */\r\n  setAccumulator(accumulatorFn: AccumulationFn): void {\r\n    this.accumulator.nextAccumulator(accumulatorFn);\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Read from the state in imperative manner. Returns the state object in its current state.\r\n   *\r\n   * @example\r\n   * const { disabled } = state.get();\r\n   * if (!disabled) {\r\n   *   doStuff();\r\n   * }\r\n   *\r\n   * @return T\r\n   */\r\n  get(): T;\r\n\r\n  /**\r\n   * @description\r\n   * Read from the state in imperative manner by providing keys as parameters.\r\n   * Returns the part of state object.\r\n   *\r\n   * @example\r\n   * // Access a single property\r\n   *\r\n   * const bar = state.get('bar');\r\n   *\r\n   * // Access a nested property\r\n   *\r\n   * const foo = state.get('bar', 'foo');\r\n   *\r\n   * @return T | T[K1] | T[K1][K2]\r\n   */\r\n\r\n  get<K1 extends keyof T>(k1: K1): T[K1];\r\n  /** @internal **/\r\n  get<K1 extends keyof T, K2 extends keyof T[K1]>(k1: K1, k2: K2): T[K1][K2];\r\n  /** @internal **/\r\n  get<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\r\n    k1: K1,\r\n    k2: K2,\r\n    k3: K3\r\n  ): T[K1][K2][K3];\r\n  /** @internal **/\r\n  get<K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3]>(k1: K1, k2: K2, k3: K3, k4: K4): T[K1][K2][K3][K4];\r\n  /** @internal **/\r\n  get<K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): T[K1][K2][K3][K4][K5];\r\n  /** @internal **/\r\n  get<K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4],\r\n    K6 extends keyof T[K1][K2][K3][K4][K5]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6): T[K1][K2][K3][K4][K5][K6];\r\n  /** @internal **/\r\n  get<K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4],\r\n    K6 extends keyof T[K1][K2][K3][K4][K5]>(\r\n    ...keys:\r\n      | [K1]\r\n      | [K1, K2]\r\n      | [K1, K2, K3]\r\n      | [K1, K2, K3, K4]\r\n      | [K1, K2, K3, K4, K5]\r\n      | [K1, K2, K3, K4, K5, K6]\r\n  ):\r\n    | T\r\n    | T[K1]\r\n    | T[K1][K2]\r\n    | T[K1][K2][K3]\r\n    | T[K1][K2][K3][K4]\r\n    | T[K1][K2][K3][K4][K5]\r\n    | T[K1][K2][K3][K4][K5][K6] {\r\n    const hasStateAnyKeys = Object.keys(this.accumulator.state).length > 0;\r\n    if (!!keys && keys.length) {\r\n      return safePluck(this.accumulator.state, keys);\r\n    } else {\r\n      return hasStateAnyKeys ?\r\n             this.accumulator.state :\r\n              undefined as unknown as T;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Manipulate one or many properties of the state by providing a `Partial<T>` state or a `ProjectionFunction<T>`.\r\n   *\r\n   * @example\r\n   * // Update one or many properties of the state by providing a `Partial<T>`\r\n   *\r\n   * const partialState = {\r\n   *   foo: 'bar',\r\n   *   bar: 5\r\n   * };\r\n   * state.set(partialState);\r\n   *\r\n   * // Update one or many properties of the state by providing a `ProjectionFunction<T>`\r\n   *\r\n   * const reduceFn = oldState => ({\r\n   *   bar: oldState.bar + 5\r\n   * });\r\n   * state.set(reduceFn);\r\n   *\r\n   * @param {Partial<T>|ProjectStateFn<T>} stateOrProjectState\r\n   * @return void\r\n   */\r\n  set(stateOrProjectState: Partial<T> | ProjectStateFn<T>): void;\r\n\r\n  /**\r\n   * @description\r\n   * Manipulate a single property of the state by the property name and a `ProjectionFunction<T>`.\r\n   *\r\n   * @example\r\n   * const reduceFn = oldState => oldState.bar + 5;\r\n   * state.set('bar', reduceFn);\r\n   *\r\n   * @param {K} key\r\n   * @param {ProjectValueFn<T, K>} projectSlice\r\n   * @return void\r\n   */\r\n  set<K extends keyof T, O>(key: K, projectSlice: ProjectValueFn<T, K>): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  set<K extends keyof T>(\r\n    keyOrStateOrProjectState: Partial<T> | ProjectStateFn<T> | K,\r\n    stateOrSliceProjectFn?: ProjectValueFn<T, K>\r\n  ): void {\r\n    if (\r\n      typeof keyOrStateOrProjectState === 'object' &&\r\n      stateOrSliceProjectFn === undefined\r\n    ) {\r\n      this.accumulator.nextSlice(keyOrStateOrProjectState);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      typeof keyOrStateOrProjectState === 'function' &&\r\n      stateOrSliceProjectFn === undefined\r\n    ) {\r\n      this.accumulator.nextSlice(\r\n        keyOrStateOrProjectState(this.accumulator.state)\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrStateOrProjectState) &&\r\n      typeof stateOrSliceProjectFn === 'function'\r\n    ) {\r\n      const state: Partial<T> = {};\r\n      state[keyOrStateOrProjectState] = stateOrSliceProjectFn(\r\n        this.accumulator.state\r\n      );\r\n      this.accumulator.nextSlice(state);\r\n      return;\r\n    }\r\n\r\n    throw new Error('wrong params passed to set');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Connect an `Observable<Partial<T>>` to the state `T`.\r\n   * Any change emitted by the source will get merged into the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const sliceToAdd$ = interval(250).pipe(mapTo({\r\n   *   bar: 5,\r\n   *   foo: 'foo'\r\n   * });\r\n   * state.connect(sliceToAdd$);\r\n   * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$\r\n   *\r\n   * // Additionally you can provide a `projectionFunction` to access the current state object and do custom mappings.\r\n   *\r\n   * const sliceToAdd$ = interval(250).pipe(mapTo({\r\n   *   bar: 5,\r\n   *   foo: 'foo'\r\n   * });\r\n   * state.connect(sliceToAdd$, (state, slice) => state.bar += slice.bar);\r\n   * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$. Bar will increase by\r\n   * // 5 due to the projectionFunction\r\n   */\r\n  connect(inputOrSlice$: Observable<Partial<T>>): void;\r\n\r\n  /**\r\n   * @description\r\n   * Connect an `Observable<V>` to the state `T`.\r\n   * Any change emitted by the source will get forwarded to to project function and merged into the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * You have to provide a `projectionFunction` to access the current state object and do custom mappings.\r\n   *\r\n   * @example\r\n   * const sliceToAdd$ = interval(250);\r\n   * state.connect(sliceToAdd$, (s, v) => ({bar: v}));\r\n   * // every 250ms the property bar get updated due to the emission of sliceToAdd$\r\n   *\r\n   */\r\n  connect<V>(\r\n    inputOrSlice$: Observable<V>,\r\n    projectFn: ProjectStateReducer<T, V>\r\n  ): void;\r\n  /**\r\n   *\r\n   * @description\r\n   * Connect an `Observable<T[K]>` source to a specific property `K` in the state `T`. Any emitted change will update\r\n   * this\r\n   * specific property in the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const myTimer$ = interval(250);\r\n   * state.connect('timer', myTimer$);\r\n   * // every 250ms the property timer will get updated\r\n   */\r\n  connect<K extends keyof T>(key: K, slice$: Observable<T[K]>): void;\r\n  /**\r\n   *\r\n   * @description\r\n   * Connect an `Observable<V>` source to a specific property in the state. Additionally you can provide a\r\n   * `projectionFunction` to access the current state object on every emission of your connected `Observable`.\r\n   * Any change emitted by the source will get merged into the state.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * const myTimer$ = interval(250);\r\n   * state.connect('timer', myTimer$, (state, timerChange) => state.timer += timerChange);\r\n   * // every 250ms the property timer will get updated\r\n   */\r\n  connect<K extends keyof T, V>(\r\n    key: K,\r\n    input$: Observable<V>,\r\n    projectSliceFn: ProjectValueReducer<T, K, V>\r\n  ): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  connect<K extends keyof T, V>(\r\n    keyOrInputOrSlice$: K | Observable<Partial<T> | V>,\r\n    projectOrSlices$?: ProjectStateReducer<T, V> | Observable<T[K] | V>,\r\n    projectValueFn?: ProjectValueReducer<T, K, V>\r\n  ): void {\r\n    if (\r\n      isObservable(keyOrInputOrSlice$) &&\r\n      projectOrSlices$ === undefined &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      this.accumulator.nextSliceObservable(keyOrInputOrSlice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isObservable(keyOrInputOrSlice$) &&\r\n      typeof projectOrSlices$ === 'function' &&\r\n      !isObservable(projectOrSlices$) &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const project = projectOrSlices$;\r\n      const slice$ = keyOrInputOrSlice$.pipe(\r\n        map((v) => project(this.get(), v as V))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrInputOrSlice$) &&\r\n      isObservable(projectOrSlices$) &&\r\n      projectValueFn === undefined\r\n    ) {\r\n      const key = keyOrInputOrSlice$;\r\n      const slice$ = projectOrSlices$.pipe(\r\n        map((value) => ({ ...{}, [key]: value }))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      isKeyOf<T>(keyOrInputOrSlice$) &&\r\n      isObservable(projectOrSlices$) &&\r\n      typeof projectValueFn === 'function'\r\n    ) {\r\n      const key = keyOrInputOrSlice$;\r\n      const slice$ = projectOrSlices$.pipe(\r\n        map((value) => ({ ...{}, [key]: projectValueFn(this.get(), value as V) }))\r\n      );\r\n      this.accumulator.nextSliceObservable(slice$);\r\n      return;\r\n    }\r\n\r\n    throw new Error('wrong params passed to connect');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * returns the state as cached and distinct `Observable<T>`. This way you don't have to think about **late\r\n   * subscribers**,\r\n   * **multiple subscribers** or **multiple emissions** of the same value\r\n   *\r\n   * @example\r\n   * const state$ = state.select();\r\n   * state$.subscribe(state => doStuff(state));\r\n   *\r\n   * @returns Observable<T>\r\n   */\r\n  select(): Observable<T>;\r\n\r\n  /**\r\n   * @description\r\n   * returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\r\n   * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\r\n   *\r\n   * @example\r\n   * const profilePicture$ = state.select(\r\n   *  pluck('profilePicture'),\r\n   *  switchMap(profilePicture => mapImageAsync(profilePicture))\r\n   * );\r\n   * @param op { OperatorFunction<T, A> }\r\n   * @returns Observable<A>\r\n   */\r\n  select<A = T>(op: OperatorFunction<T, A>): Observable<A>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>\r\n  ): Observable<B>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>\r\n  ): Observable<C>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B, D = C>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>\r\n  ): Observable<D>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<A = T, B = A, C = B, D = C, E = D>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>,\r\n    op5: OperatorFunction<D, E>\r\n  ): Observable<E>;\r\n  /**\r\n   * @description\r\n   * Access a single property of the state by providing keys.\r\n   * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\r\n   *\r\n   * @example\r\n   * // Access a single property\r\n   *\r\n   * const bar$ = state.select('bar');\r\n   *\r\n   * // Access a nested property\r\n   *\r\n   * const foo$ = state.select('bar', 'foo');\r\n   *\r\n   * @return Observable<T[K1]>\r\n   */\r\n  select<K1 extends keyof T>(k1: K1): Observable<T[K1]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<K1 extends keyof T, K2 extends keyof T[K1]>(\r\n    k1: K1,\r\n    k2: K2\r\n  ): Observable<T[K1][K2]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2]>(k1: K1, k2: K2, k3: K3): Observable<T[K1][K2][K3]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3]>(k1: K1, k2: K2, k3: K3, k4: K4): Observable<T[K1][K2][K3][K4]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): Observable<T[K1][K2][K3][K4][K5]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<K1 extends keyof T,\r\n    K2 extends keyof T[K1],\r\n    K3 extends keyof T[K1][K2],\r\n    K4 extends keyof T[K1][K2][K3],\r\n    K5 extends keyof T[K1][K2][K3][K4],\r\n    K6 extends keyof T[K1][K2][K3][K4][K5]>(\r\n    k1: K1,\r\n    k2: K2,\r\n    k3: K3,\r\n    k4: K4,\r\n    k5: K5,\r\n    k6: K6\r\n  ): Observable<T[K1][K2][K3][K4][K5][K6]>;\r\n  /**\r\n   * @internal\r\n   */\r\n  select<R>(\r\n    ...opOrMapFn: OperatorFunction<T, R>[] | string[]\r\n  ): Observable<T | R> {\r\n    if (!opOrMapFn || opOrMapFn.length === 0) {\r\n      return this.accumulator.state$.pipe(stateful());\r\n    } else if (isStringArrayGuard(opOrMapFn)) {\r\n      return this.accumulator.state$.pipe(stateful(pluck(...opOrMapFn))) as Observable<T | R>;\r\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\r\n      return this.accumulator.state$.pipe(stateful(pipeFromArray(opOrMapFn)));\r\n    }\r\n    throw new Error('wrong params passed to select');\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * Manages side-effects of your state. Provide an `Observable<any>` **side-effect** and an optional\r\n   * `sideEffectFunction`.\r\n   * Subscription handling is done automatically.\r\n   *\r\n   * @example\r\n   * // Directly pass an observable side-effect\r\n   * const localStorageEffect$ = changes$.pipe(\r\n   *  tap(changes => storeChanges(changes))\r\n   * );\r\n   * state.hold(localStorageEffect$);\r\n   *\r\n   * // Pass an additional `sideEffectFunction`\r\n   *\r\n   * const localStorageEffectFn = changes => storeChanges(changes);\r\n   * state.hold(changes$, localStorageEffectFn);\r\n   *\r\n   * @param {Observable<S>} obsOrObsWithSideEffect\r\n   * @param {function} [sideEffectFn]\r\n   */\r\n  hold<S>(\r\n    obsOrObsWithSideEffect: Observable<S>,\r\n    sideEffectFn?: (arg: S) => void\r\n  ): void {\r\n    const sideEffect = obsOrObsWithSideEffect.pipe(catchError(e => EMPTY))\r\n    if (typeof sideEffectFn === 'function') {\r\n      this.effectObservable.nextEffectObservable(\r\n        sideEffect.pipe(tap(sideEffectFn))\r\n      );\r\n      return;\r\n    }\r\n    this.effectObservable.nextEffectObservable(sideEffect);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  subscribe(): Unsubscribable {\r\n    const subscription = new Subscription();\r\n    subscription.add(this.accumulator.subscribe());\r\n    subscription.add(this.effectObservable.subscribe());\r\n    return subscription;\r\n  }\r\n}\r\n","import { isDefined } from '../../core';\r\n\r\n/**\r\n * @description\r\n * Inserts one or multiple items to an array T[].\r\n * Returns a shallow copy of the updated array T[], and does not mutate the original one.\r\n *\r\n * @example\r\n * // Inserting single value\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\r\n *\r\n * const updatedCreatures = insert(creatures, {id: 3, type: 'parrot'});\r\n *\r\n * // updatedCreatures will be:\r\n * //  [{id: 1, type: 'cat'}, {id: 2, type: 'dog}, {id: 3, type: 'parrot}];\r\n *\r\n * @example\r\n * // Inserting multiple values\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\r\n *\r\n * const updatedCreatures = insert(creatures, [{id: 3, type: 'parrot'}, {id: 4, type: 'hamster'}]);\r\n *\r\n * // updatedCreatures will be:\r\n * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'parrot'}, {id: 4, type: 'hamster'}];\r\n *\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class ListComponent {\r\n *\r\n *    readonly insertCreature$ = new Subject<void>();\r\n *\r\n *    constructor(private state: RxState<ComponentState>) {\r\n *      // Reactive implementation\r\n *      state.connect(\r\n *        'creatures',\r\n *        this.insertCreature$,\r\n *        ({ creatures }) => {\r\n *            const creatureToAdd = {id: generateId(), name: 'newCreature', type: 'dinosaur' };\r\n *            return insert(creatures, creatureToAdd);\r\n *        }\r\n *      );\r\n *    }\r\n *\r\n *    // Imperative implementation\r\n *    insertCeature(): void {\r\n *        const creatureToAdd = {id: generateId(), name: 'newCreature', type: 'dinosaur' };\r\n *        this.state.set({ creatures: insert(this.state.get().creatures, creatureToAdd)});\r\n *    }\r\n * }\r\n *\r\n *\r\n * @returns T[]\r\n *\r\n * @docsPage insert\r\n * @docsCategory transformation-helpers\r\n */\r\nexport function insert<T>(source: T[], updates: T | T[]): T[] {\r\n  const updatesDefined = isDefined(updates);\r\n  const sourceIsArray = Array.isArray(source);\r\n  const invalidInput = !sourceIsArray && !updatesDefined;\r\n\r\n  if (!sourceIsArray && isDefined(source)) {\r\n    console.warn(`Insert: Original value (${source}) is not an array.`);\r\n  }\r\n\r\n  if (invalidInput) {\r\n    return source;\r\n  }\r\n\r\n  return [\r\n    ...(sourceIsArray ? source : []),\r\n    ...(updatesDefined ? (Array.isArray(updates) ? updates : [updates]) : [])\r\n  ];\r\n}\r\n","import { CompareFn } from '../../rxjs/interfaces';\r\nimport { ComparableData } from '../interfaces/comparable-data-type';\r\nimport { isKeyOf } from '../../core';\r\n\r\nexport function valuesComparer<T>(\r\n  original: T,\r\n  incoming: T,\r\n  compare?: ComparableData<T>\r\n): boolean {\r\n  const defaultCompare = (a: T, b: T) => a === b;\r\n\r\n  if (isKeyOf<T>(compare)) {\r\n    return original[compare] === incoming[compare];\r\n  }\r\n\r\n  if (Array.isArray(compare)) {\r\n    const sanitizedKeys = compare.filter((k) => isKeyOf<T>(k));\r\n    return !!sanitizedKeys.length\r\n      ? sanitizedKeys.every((k) => original[k] === incoming[k])\r\n      : defaultCompare(original, incoming);\r\n  }\r\n\r\n  return ((compare as CompareFn<T>) || defaultCompare)(original, incoming);\r\n}\r\n","import { ComparableData } from '../interfaces/comparable-data-type';\r\nimport { isDefined } from '../../core';\r\nimport { valuesComparer } from '../_internals/valuesComparer.util';\r\n\r\n/**\r\n * @description\r\n * Removes one or multiple items from an array T[].\r\n * For comparison you can provide a key, an array of keys or a custom comparison function that should return true if items match.\r\n * If no comparison data is provided, an equality check is used by default.\r\n * Returns a shallow copy of the updated array T[], and does not mutate the original one.\r\n *\r\n * @example\r\n * // Removing value without comparison data\r\n *\r\n * const items = [1,2,3,4,5];\r\n *\r\n * const updatedItems = remove(items, [1,2,3]);\r\n *\r\n * // updatedItems will be: [4,5];\r\n *\r\n * @example\r\n * // Removing values with comparison function\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];\r\n *\r\n * const nonExistingCreatures = [{id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];\r\n *\r\n * const realCreatures = remove(creatures, nonExistingCreatures, (a, b) => a.id === b.id);\r\n *\r\n * // realCreatures will be: [{id: 1, type: 'cat'}];\r\n *\r\n * @example\r\n * // Removing values with key\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];\r\n *\r\n * const nonExistingCreatures = [{id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];\r\n *\r\n * const realCreatures = remove(creatures, nonExistingCreatures, 'id');\r\n *\r\n * // realCreatures will be: [{id: 1, type: 'cat'}];\r\n *\r\n * @example\r\n * // Removing values with array of keys\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];\r\n *\r\n * const nonExistingCreatures = [{id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];\r\n *\r\n * const realCreatures = remove(creatures, nonExistingCreatures, ['id', 'type']);\r\n *\r\n * // realCreatures will be: [{id: 1, type: 'cat'}];\r\n *\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class ListComponent {\r\n *\r\n *    readonly removeCreature$ = new Subject<Creature>();\r\n *\r\n *    constructor(private state: RxState<ComponentState>) {\r\n *      // Reactive implementation\r\n *      state.connect(\r\n *        'creatures',\r\n *        this.removeCreature$,\r\n *        ({ creatures }, creatureToRemove) => {\r\n *            return remove(creatures, creatureToRemove, (a, b) => a.id === b.id);\r\n *        }\r\n *      );\r\n *    }\r\n *\r\n *    // Imperative implementation\r\n *    removeCreature(creatureToRemove: Creature): void {\r\n *        this.state.set({ creatures: remove(this.state.get().creatures, creatureToRemove, (a, b) => a.id === b.id)});\r\n *    }\r\n * }\r\n *\r\n * @returns T[]\r\n *\r\n * @docsPage remove\r\n * @docsCategory transformation-helpers\r\n */\r\nexport function remove<T>(\r\n  source: T[],\r\n  scrap: Partial<T>[] | Partial<T>,\r\n  compare?: ComparableData<T>\r\n): T[] {\r\n  const scrapAsArray = isDefined(scrap)\r\n    ? Array.isArray(scrap)\r\n      ? scrap\r\n      : [scrap]\r\n    : [];\r\n  const invalidInput = !Array.isArray(source);\r\n\r\n  if (invalidInput) {\r\n    console.warn(`Remove: original value (${source}) is not an array`);\r\n    return source;\r\n  }\r\n\r\n  return source.filter((existingItem) => {\r\n    return !scrapAsArray.some((item) =>\r\n      valuesComparer(item as T, existingItem, compare)\r\n    );\r\n  });\r\n}\r\n","import { OnlyKeysOfSpecificType } from '../interfaces/only-keys-of-specific-type';\r\nimport { isDefined, isKeyOf } from '../../core';\r\n\r\n/**\r\n * @description\r\n * Converts an array of objects to a dictionary {[key: string]: T}.\r\n * Accepts array T[] and key of type string, number or symbol as inputs.\r\n *\r\n *\r\n * @example\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'parrot'}];\r\n *\r\n * const creaturesDictionary = toDictionary(creatures, 'id');\r\n *\r\n * // creaturesDictionary will be:\r\n * // {\r\n * //  1: {id: 1, type: 'cat'},\r\n * //  2: {id: 2, type: 'dog'},\r\n * //  3: {id: 3, type: 'parrot'}\r\n * // };\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class ListComponent {\r\n *\r\n *    readonly convertToDictionary$ = new Subject();\r\n *\r\n *    constructor(private state: RxState<ComponentState>) {\r\n *      // Reactive implementation\r\n *      state.connect(\r\n *        'creaturesDictionary',\r\n *        this.convertToDictionary$,\r\n *        ({ creatures }) => {\r\n *            return toDictionary(creatures, 'id');\r\n *        }\r\n *      );\r\n *    }\r\n *\r\n *    // Imperative implementation\r\n *    convertToDictionary(): void {\r\n *        this.state.set({ creaturesDictionary: toDictionary(this.state.get().creatures, 'id'});\r\n *    }\r\n * }\r\n *\r\n * @see {@link OnlyKeysOfSpecificType}\r\n * @param {OnlyKeysOfSpecificType<T, S>} key\r\n * @returns { [key: string]: T[] }\r\n * @docsPage toDictionary\r\n * @docsCategory transformation-helpers\r\n */\r\nexport function toDictionary<T extends object>(\r\n  source: T[],\r\n  key:\r\n    | OnlyKeysOfSpecificType<T, number>\r\n    | OnlyKeysOfSpecificType<T, string>\r\n    | OnlyKeysOfSpecificType<T, symbol>\r\n): { [key: string]: T } {\r\n  if (!isDefined(source)) {\r\n    return source;\r\n  }\r\n\r\n  const sourceEmpty = !source.length;\r\n\r\n  if (!Array.isArray(source) || sourceEmpty || !isKeyOf<T>(source[0][key])) {\r\n    if (!sourceEmpty) {\r\n      console.warn('ToDictionary: unexpected input params.');\r\n    }\r\n    return {};\r\n  }\r\n\r\n  const dictionary: { [key: string]: T } = {};\r\n  const length = source.length;\r\n  let i = 0;\r\n\r\n  for (i; i < length; i++) {\r\n    dictionary[`${source[i][key]}`] = Object.assign({}, source[i]);\r\n  }\r\n\r\n  return dictionary;\r\n}\r\n","import { ComparableData } from '../interfaces/comparable-data-type';\r\nimport { valuesComparer } from '../_internals/valuesComparer.util';\r\n\r\n/**\r\n * @description\r\n * Updates one or multiple items in an array T[].\r\n * For comparison you can provide key, array of keys or a custom comparison function that should return true if items match.\r\n * If no comparison is provided, an equality check is used by default.\r\n * Returns a shallow copy of the array T[] and updated items, does not mutate the original array.\r\n *\r\n * @example\r\n * // Update with comparison function\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\r\n *\r\n * const newCat = {id: 1, type: 'lion'};\r\n *\r\n * const updatedCreatures = update(creatures, newCat, (a, b) => a.id === b.id);\r\n *\r\n * // updatedCreatures will be:\r\n * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];\r\n *\r\n * @example\r\n * // Update with key\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\r\n *\r\n * const newCat = {id: 1, type: 'lion'};\r\n *\r\n * const updatedCreatures = update(creatures, newCat, 'id');\r\n *\r\n * // updatedCreatures will be:\r\n * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];\r\n *\r\n * @example\r\n * // Update with array of keys\r\n *\r\n * const creatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\r\n *\r\n * const newCat = {id: 1, type: 'lion', name: 'Bella'};\r\n *\r\n * const updatedCreatures = update(creatures, newCat, ['id', 'name']);\r\n *\r\n * // updatedCreatures will be:\r\n * // [{id: 1, type: 'lion', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\r\n *\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class ListComponent {\r\n *\r\n *    readonly updateCreature$ = new Subject<Creature>();\r\n *\r\n *    constructor(private state: RxState<ComponentState>) {\r\n *      // Reactive implementation\r\n *      state.connect(\r\n *        'creatures',\r\n *        this.updateCreature$,\r\n *        ({ creatures }, creatureToUpdate) => {\r\n *            return update(creatures, creatureToUpdate, (a, b) => a.id === b.id);\r\n *        }\r\n *      );\r\n *    }\r\n *\r\n *    // Imperative implementation\r\n *    updateCreature(creatureToUpdate: Creature): void {\r\n *        this.state.set({ creatures: update(this.state.get().creatures, creatureToUpdate, (a, b) => a.id === b.id)});\r\n *    }\r\n * }\r\n *\r\n * @returns T[]\r\n *\r\n * @docsPage update\r\n * @docsCategory transformation-helpers\r\n */\r\nexport function update<T extends object>(\r\n  source: T[],\r\n  updates: Partial<T>[] | Partial<T>,\r\n  compare?: ComparableData<T>\r\n): T[] {\r\n  const updatesDefined = updates != null;\r\n  const updatesAsArray = updatesDefined\r\n    ? Array.isArray(updates)\r\n      ? updates\r\n      : [updates]\r\n    : [];\r\n\r\n  const sourceDefined = source != null;\r\n  const sourceIsArray = Array.isArray(source);\r\n  const invalidInput =\r\n    !sourceIsArray || source.length === 0 || updatesAsArray.length === 0;\r\n\r\n  if (sourceDefined && !sourceIsArray) {\r\n    console.warn(`Update: Original value (${source}) is not an array.`);\r\n  }\r\n\r\n  if (invalidInput) {\r\n    return source;\r\n  }\r\n\r\n  return source.map((existingItem) => {\r\n    const match = updatesAsArray.find((item) =>\r\n      valuesComparer(item as T, existingItem, compare)\r\n    );\r\n\r\n    if (match) {\r\n      return { ...existingItem, ...match };\r\n    }\r\n\r\n    return existingItem;\r\n  });\r\n}\r\n","import { isDefined, isKeyOf } from '../../core';\r\n\r\n/**\r\n * @description\r\n * Accepts an array of objects of type T and single key or array of keys (K extends keyof T).\r\n * The `exctract` method is pure and immutable, thus not touching the input values and returning a shallow\r\n * copy of the extracted source.\r\n *\r\n * @example\r\n *\r\n * const cats = [{id: 1, type: 'cat', name: 'Fluffy'}, {id: 2, type: 'cat', name: 'Emma'}];\r\n *\r\n * const catsWithoutTypes = extract(cats, ['name', 'id']);\r\n *\r\n * // catsWithoutTypes will be:\r\n * // [{id: 1, name: 'Fluffy'}, {id: 2, name: 'Emma'}];\r\n *\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class AnimalsListComponent {\r\n *\r\n *    constructor(private state: RxState<ComponentState>, private api: ApiService) {\r\n *      state.connect(\r\n *        'animals'\r\n *        this.api.getAnimals(),\r\n *        (state, animals) => extract(animals, ['id', 'name'])\r\n *      );\r\n *    }\r\n * }\r\n *\r\n * @returns T\r\n *\r\n * @docsPage slice\r\n * @docsCategory transformation-helpers\r\n */\r\n export function extract<T extends object, K extends keyof T>(\r\n  array: T[],\r\n  keys: K | K[]\r\n): Pick<T, K>[] {\r\n  const arrayIsArray = isDefined(array) && Array.isArray(array);\r\n\r\n  if (!arrayIsArray) {\r\n    console.warn(`extract: original value (${array}) is not an array.`);\r\n    return undefined as any;\r\n  }\r\n\r\n  const sanitizedKeys = (Array.isArray(keys) ? keys : [keys]).filter(\r\n    k => isKeyOf<T>(k) && array.some(i => k in i)\r\n  );\r\n  const length = sanitizedKeys.length;\r\n\r\n  if (!sanitizedKeys.length) {\r\n    console.warn(`extract: provided keys not found`);\r\n    return undefined as any;\r\n  }\r\n\r\n  return array.map(item => {\r\n    let i = 0;\r\n    const result = {} as Pick<T, K>;\r\n\r\n    for(i; i < length; i++) {\r\n      result[sanitizedKeys[i]] = item[sanitizedKeys[i]];\r\n    }\r\n\r\n    return result;\r\n  }\r\n  );\r\n}\r\n","import { isObjectGuard } from '../../core/utils/guards';\r\nimport { valuesComparer } from '../_internals/valuesComparer.util';\r\nimport { ComparableData } from '../interfaces/comparable-data-type';\r\n\r\n/**\r\n * @description\r\n * Updates or inserts (if does not exist) one or multiple items in an array T[].\r\n * For comparison you can provide a key, an array of keys or a custom comparison function that should return true if\r\n * items match.\r\n * If no comparison is provided, an equality check is used by default.\r\n * upsert is `pure` and `immutable`, your inputs won't be changed\r\n *\r\n *\r\n * @example\r\n * // Upsert (update) with key\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\r\n *\r\n * const newCat = {id: 1, type: 'lion'};\r\n *\r\n * const updatedCreatures = upsert(creatures, newCat, 'id');\r\n *\r\n * // updatedCreatures will be:\r\n * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];\r\n *\r\n * @example\r\n * // Upsert (insert) with key\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\r\n *\r\n * const newCat = {id: 3, type: 'lion'};\r\n *\r\n * const updatedCreatures = upsert(creatures, newCat, 'id');\r\n *\r\n * // updatedCreatures will be:\r\n * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];\r\n *\r\n * @example\r\n * // Upsert (update) with array of keys\r\n *\r\n * const creatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\r\n *\r\n * const newCat = {id: 1, type: 'lion', name: 'Bella'};\r\n *\r\n * const updatedCreatures = upsert(creatures, newCat, ['id', 'name']);\r\n *\r\n * // updatedCreatures will be:\r\n * // [{id: 1, type: 'lion', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\r\n *\r\n * @example\r\n * // Update (insert) with comparison function\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\r\n *\r\n * const newCat = {id: 3, type: 'lion'};\r\n *\r\n * const updatedCreatures = upsert(creatures, newCat, (a, b) => a.id === b.id);\r\n *\r\n * // updatedCreatures will be:\r\n * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];\r\n *\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class ListComponent {\r\n *\r\n *    // trigger which gets called on add/update (for reactive implementation)\r\n *    readonly addOrUpdateCreature = new Subject<Creature>();\r\n *\r\n *    constructor(private state: RxState<ComponentState>) {\r\n *      const initialCreatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\r\n *      state.set({ creatures: initialCreatures });\r\n *      // Reactive implementation\r\n *      state.connect(\r\n *        'creatures',\r\n *        this.addOrUpdateCreature,\r\n *        ({ creatures }, creatureToUpsert) => {\r\n *            return upsert(creatures, creatureToUpsert, 'id');\r\n *        }\r\n *      );\r\n *    }\r\n *\r\n *    // Imperative implementation\r\n *    updateCreature(creatureToUpdate: Creature): void {\r\n *        this.state.set({ creatures: upsert(this.state.get('creatures'), creatureToUpdate, 'id')});\r\n *    }\r\n * }\r\n *\r\n * @returns T[]\r\n *\r\n * @docsPage upsert\r\n * @docsCategory transformation-helpers\r\n */\r\nexport function upsert<T>(\r\n  source: T[],\r\n  update: Partial<T>[] | Partial<T>,\r\n  compare?: ComparableData<T>\r\n): T[] {\r\n  // check inputs for validity\r\n  const updatesAsArray =\r\n    update != null ? (Array.isArray(update) ? update : [update]) : [];\r\n  // check inputs for validity\r\n  const sourceIsArray = Array.isArray(source);\r\n  const invalidInput = !sourceIsArray && updatesAsArray.length === 0;\r\n  // if the source value is not an Array or the input is not defined return the original source\r\n  // this is the case for any edge case:\r\n  // '', null, undefined, CustomObjectOfDoomAndDarkness, ...\r\n  if (invalidInput) {\r\n    return source;\r\n  }\r\n\r\n  // if source is empty array or not an array, but the updates are valid:\r\n  // return a shallow copy of the updates as result\r\n  if (updatesAsArray.length > 0 && (!sourceIsArray || source.length === 0)) {\r\n    return [...updatesAsArray] as T[];\r\n  }\r\n\r\n  const inserts: T[] = [];\r\n  const updates: Record<number, Partial<T>> = {};\r\n  // process updates/inserts\r\n  updatesAsArray.forEach((item) => {\r\n    const match = source.findIndex((sourceItem) =>\r\n      valuesComparer(item as T, sourceItem, compare)\r\n    );\r\n    // if item already exists, save it as update\r\n    if (match !== -1) {\r\n      updates[match] = item;\r\n    } else {\r\n      // otherwise consider this as insert\r\n      if (isObjectGuard(item)) {\r\n        // create a shallow copy if item is an object\r\n        inserts.push({ ...(item as T) });\r\n      } else {\r\n        // otherwise just push it\r\n        inserts.push(item);\r\n      }\r\n    }\r\n  });\r\n  let updated = source;\r\n  if (Object.keys(updates).length > 0) {\r\n    // if we have updates to process\r\n    updated = updated.map((item, i) => {\r\n      const updatedItem = updates[i];\r\n      // process the updated\r\n      if (updatedItem != null) {\r\n        if (isObjectGuard(item)) {\r\n          return { ...item, ...updatedItem };\r\n        } else {\r\n          return updatedItem as T;\r\n        }\r\n      }\r\n      return item;\r\n    });\r\n  }\r\n  // return the combination of the updated source & the inserts as new array\r\n  return [...updated, ...inserts];\r\n}\r\n","import { isDefined, isKeyOf, isObjectGuard } from '../../core';\r\n\r\n/**\r\n * @description\r\n * Accepts an object of type T and key of type K extends keyof T.\r\n * Removes property from an object and returns a shallow copy of the updated object without specified property.\r\n * If property not found returns copy of the original object.\r\n * Not mutating original object.\r\n *\r\n * @example\r\n *\r\n * const cat = {id: 1, type: 'cat', name: 'Fluffy'};\r\n *\r\n * const anonymusCat = deleteProp(cat, 'name');\r\n *\r\n * // anonymusCat will be:\r\n * // {id: 1, type: 'cat'};\r\n *\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class ProfileComponent {\r\n *\r\n *    readonly removeName$ = new Subject();\r\n *\r\n *    constructor(private state: RxState<ComponentState>) {\r\n *      // Reactive implementation\r\n *      state.connect(\r\n *        this.removeName$,\r\n *        (state) => {\r\n *            return deleteProp(state, 'name');\r\n *        }\r\n *      );\r\n *    }\r\n *\r\n *    // Imperative implementation\r\n *    removeName(): void {\r\n *        this.state.set(remove(this.get(), 'name'));\r\n *    }\r\n * }\r\n *\r\n * @returns Omit<T, K>\r\n *\r\n * @docsPage deleteProp\r\n * @docsCategory transformation-helpers\r\n */\r\nexport function deleteProp<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K\r\n): Omit<T, K> {\r\n  if (!isDefined(object) || !isObjectGuard(object)) {\r\n    console.warn(`DeleteProp: original value ${object} is not an object.`);\r\n    return object;\r\n  }\r\n\r\n  if (!isKeyOf<T>(key)) {\r\n    console.warn(`DeleteProp: provided key is not a string, number or symbol.`);\r\n    return { ...object };\r\n  }\r\n\r\n  const copy = { ...object };\r\n  delete copy[key];\r\n  return copy;\r\n}\r\n","import { isDefined, isObjectGuard } from '../../core';\r\n\r\n/**\r\n * @description\r\n * Converts a dictionary of type {[key: string]: T} to array T[].\r\n *\r\n * @example\r\n *\r\n * const creaturesDictionary = {\r\n *   '1': {id: 1, type: 'cat'},\r\n *   '2': {id: 2, type: 'dog'},\r\n *   '3': {id: 3, type: 'parrot'}\r\n * };\r\n *\r\n * const creaturesArray = dictionaryToArray(creaturesDictionary);\r\n *\r\n * // creaturesArray will be:\r\n * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'parrot'}];\r\n *\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class ListComponent {\r\n *    readonly removeName$ = new Subject();\r\n *\r\n *    constructor(\r\n *      private state: RxState<ComponentState>,\r\n *      private api: ApiService\r\n *    ) {\r\n *      // Reactive implementation\r\n *      state.connect(\r\n *        'creatures',\r\n *        this.api.creaturesDictionary$,\r\n *        (_, creatures) => {\r\n *            return dictionaryToArray(creatures);\r\n *        }\r\n *      );\r\n *    }\r\n *\r\n *    // Imperative implementation\r\n *    removeName(): void {\r\n *      this.api.creaturesDictionary$.pipe(\r\n *        // subscription handling logic\r\n *      ).subscribe(\r\n *        dictionary => this.set({creatures: dictionaryToArray(dictionary)})\r\n *      );\r\n *    }\r\n * }\r\n *\r\n * @returns T[];\r\n *\r\n * @docsPage dictionaryToArray\r\n * @docsCategory transformation-helpers\r\n */\r\nexport function dictionaryToArray<T>(dictionary: { [key: string]: T }): T[] {\r\n  if (!isDefined(dictionary)) {\r\n    return dictionary;\r\n  }\r\n\r\n  if (!isObjectGuard(dictionary)) {\r\n    console.warn(`DictionaryToArray: unexpected input.`);\r\n    return [];\r\n  }\r\n\r\n  return Object.values(dictionary);\r\n}\r\n","import { isObjectGuard } from '../../core';\r\n\r\n/**\r\n * @description\r\n * Merges an object of type T with updates of type Partial<T>.\r\n * Returns a new object where updates override original values while not mutating the original one.\r\n\r\n * @example\r\n * interface Creature {\r\n *  id: number,\r\n *  type: string,\r\n *  name: string\r\n * }\r\n *\r\n * const cat = {id: 1, type: 'cat'};\r\n *\r\n * const catWithname = patch(cat, {name: 'Fluffy'});\r\n *\r\n * // catWithname will be:\r\n * // {id: 1, type: 'cat', name: 'Fluffy'};\r\n *\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class ProfileComponent {\r\n *\r\n *    readonly changeName$ = new Subject<string>();\r\n *\r\n *    constructor(private state: RxState<ComponentState>) {\r\n *      // Reactive implementation\r\n *      state.connect(\r\n *        this.changeName$,\r\n *        (state, name) => {\r\n *            return patch(state, { name });\r\n *        }\r\n *      );\r\n *    }\r\n *\r\n *    // Imperative implementation\r\n *    changeName(name: string): void {\r\n *        this.state.set(patch(this.get(), { name }));\r\n *    }\r\n * }\r\n *\r\n * @returns T\r\n *\r\n * @docsPage patch\r\n * @docsCategory transformation-helpers\r\n */\r\nexport function patch<T extends object>(object: T, upd: Partial<T>): T {\r\n  const update = isObjectGuard(upd) ? upd : {};\r\n\r\n  if (!isObjectGuard(object) && isObjectGuard(upd)) {\r\n    console.warn(`Patch: original value ${object} is not an object.`);\r\n    return { ...update } as T;\r\n  }\r\n\r\n  if (!isObjectGuard(object) && !isObjectGuard(upd)) {\r\n    console.warn(\r\n      `Patch: original value ${object} and updates ${upd} are not objects.`\r\n    );\r\n    return object;\r\n  }\r\n\r\n  return { ...object, ...update };\r\n}\r\n","import { isDefined, isKeyOf, isObjectGuard } from '../../core';\r\n\r\n/**\r\n * @description\r\n * Accepts an object of type T, key of type K extends keyof T, and value of type T[K].\r\n * Sets the property and returns a newly updated shallow copy of an object while not mutating the original one.\r\n *\r\n * @example\r\n *\r\n * const cat = {id: 1, type: 'cat', name: 'Fluffy'};\r\n *\r\n * const renamedCat = setProp(cat, 'name', 'Bella');\r\n *\r\n * // renamedCat will be:\r\n * // {id: 1, type: 'cat', name: 'Bella'};\r\n *\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class ProfileComponent {\r\n *\r\n *    readonly changeName$ = new Subject<string>();\r\n *\r\n *    constructor(private state: RxState<ComponentState>) {\r\n *      // Reactive implementation\r\n *      state.connect(\r\n *        this.changeName$,\r\n *        (state, name) => {\r\n *            return setProp(state, 'name', name);\r\n *        }\r\n *      );\r\n *    }\r\n *\r\n *    // Imperative implementation\r\n *    changeName(name: string): void {\r\n *        this.state.set(setProp(this.get(), 'name', name));\r\n *    }\r\n * }\r\n *\r\n * @returns T\r\n *\r\n * @docsPage setProp\r\n * @docsCategory transformation-helpers\r\n */\r\nexport function setProp<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n  value: T[K]\r\n): T {\r\n  const objectIsObject = isObjectGuard(object);\r\n  const keyIsValid = isKeyOf<T>(key);\r\n  const initialObject = objectIsObject ? object : ({} as T);\r\n\r\n  if (!objectIsObject) {\r\n    console.warn(`SetProp: original value (${object}) is not an object.`);\r\n  }\r\n\r\n  if (!keyIsValid) {\r\n    console.warn(`SetProp: key argument (${key}) is invalid.`);\r\n  }\r\n\r\n  if (!isDefined(object) && !keyIsValid) {\r\n    return object;\r\n  }\r\n\r\n  if (keyIsValid) {\r\n    return {\r\n      ...initialObject,\r\n      [key]: value\r\n    };\r\n  }\r\n\r\n  return { ...initialObject };\r\n}\r\n","import { OnlyKeysOfSpecificType } from '../interfaces/only-keys-of-specific-type';\r\nimport { isDefined, isKeyOf, isObjectGuard } from '../../core';\r\n\r\n/**\r\n * @description\r\n * Toggles a boolean property in the object.\r\n * Accepts object of type T and key value of which is boolean.\r\n * Toggles the property and returns a shallow copy of an object, while not mutating the original one.\r\n *\r\n * @example\r\n *\r\n * const state = {items: [1,2,3], loading: true};\r\n *\r\n * const updatedState = toggle(state, 'loading');\r\n *\r\n * // updatedState will be:\r\n * // {items: [1,2,3], loading: false};\r\n *\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class ListComponent {\r\n *    readonly loadingChange$ = new Subject();\r\n *\r\n *    constructor(\r\n *      private state: RxState<ComponentState>\r\n *    ) {\r\n *      // Reactive implementation\r\n *      state.connect(\r\n *        this.api.loadingChange$,\r\n *        (state, _) => {\r\n *            return toggle(state, 'isLoading');\r\n *        }\r\n *      );\r\n *    }\r\n *\r\n *    // Imperative implementation\r\n *    toggleLoading(): void {\r\n *      this.set(toggle(state, 'isLoading'));\r\n *    }\r\n * }\r\n *\r\n * @returns T\r\n *\r\n * @docsPage toggle\r\n * @docsCategory transformation-helpers\r\n */\r\n\r\nexport function toggle<T extends object>(\r\n  object: T,\r\n  key: OnlyKeysOfSpecificType<T, boolean>\r\n): T {\r\n  const objectIsObject = isObjectGuard(object);\r\n  const keyIsValid = isKeyOf<T>(key);\r\n  const initialObject = objectIsObject ? object : ({} as T);\r\n\r\n  if (!objectIsObject) {\r\n    console.warn(`Toggle: original value (${object}) is not an object.`);\r\n  }\r\n\r\n  if (!keyIsValid) {\r\n    console.warn(`Toggle: key argument (${key}) is invalid.`);\r\n  }\r\n\r\n  if (keyIsValid && typeof initialObject[key] !== 'boolean') {\r\n    console.warn(`Toggle: value of the key (${key}) is not a boolean.`);\r\n  }\r\n\r\n  if (!isDefined(object) && !keyIsValid) {\r\n    return object;\r\n  }\r\n\r\n  if (\r\n    keyIsValid &&\r\n    (typeof initialObject[key] === 'boolean' ||\r\n      !initialObject.hasOwnProperty(key))\r\n  ) {\r\n    return { ...initialObject, [key]: !initialObject[key] };\r\n  }\r\n\r\n  return { ...initialObject };\r\n}\r\n","import { isDefined, isKeyOf, isObjectGuard } from '../../core';\r\n\r\n/**\r\n * @description\r\n * Accepts an object of type T and single key or array of keys (K extends keyof T).\r\n * Constructs new object based on provided keys.\r\n *\r\n * @example\r\n *\r\n * const cat = {id: 1, type: 'cat', name: 'Fluffy'};\r\n *\r\n * const catWithoutType = slice(cat, ['name', 'id']);\r\n *\r\n * // catWithoutType will be:\r\n * // {id: 1, name: 'Fluffy'};\r\n *\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class AnimalsListComponent {\r\n *\r\n *    constructor(private state: RxState<ComponentState>, private api: ApiService) {\r\n *      state.connect(\r\n *        'animals'\r\n *        this.api.getAnimals(),\r\n *        (state, animals) => {\r\n *            return animals.map(animal => slice(animal, ['id', 'name']));\r\n *        }\r\n *      );\r\n *    }\r\n * }\r\n *\r\n * @returns T\r\n *\r\n * @docsPage slice\r\n * @docsCategory transformation-helpers\r\n */\r\nexport function slice<T extends object, K extends keyof T>(\r\n  object: T,\r\n  keys: K | K[]\r\n): Pick<T, K> {\r\n  const objectIsObject = isDefined(object) && isObjectGuard(object);\r\n\r\n  if (!objectIsObject) {\r\n    console.warn(`slice: original value (${object}) is not an object.`);\r\n    return undefined as any;\r\n  }\r\n\r\n  const sanitizedKeys = (Array.isArray(keys) ? keys : [keys]).filter(\r\n    (k) => isKeyOf<T>(k) && k in object\r\n  );\r\n\r\n  if (!sanitizedKeys.length) {\r\n    console.warn(`slice: provided keys not found`);\r\n    return undefined as any;\r\n  }\r\n\r\n  return sanitizedKeys.reduce(\r\n    (acc, k) => ({ ...acc, [k]: object[k] }),\r\n    {} as Pick<T, K>\r\n  );\r\n}\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}