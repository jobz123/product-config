{"version":3,"file":"selectSlice.js","sourceRoot":"","sources":["../../../../../../../libs/state/src/lib/rxjs/operators/selectSlice.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,gBAAgB,CAAC;AAE7C,OAAO,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAEtE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwEG;AACH,MAAM,UAAU,WAAW,CACzB,IAAS,EACT,aAAiD;IAEjD,OAAO,CAAC,EAAiB,EAA+B,EAAE,CACxD,EAAE,CAAC,IAAI,CACL,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,KAAK,SAAS,CAAC,EACtC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;QACZ,eAAe;QACf,IAAI,KAAK,KAAK,IAAI,EAAE;YAClB,OAAO,IAAI,CAAC;SACb;QACD,yEAAyE;QACzE,MAAM,WAAW,GAAG,IAAI;YACtB,+DAA+D;aAC9D,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,CAAC;QAEpE,oDAAoD;QACpD,uEAAuE;QAEvE,4CAA4C;QAC5C,kDAAkD;QAClD,8DAA8D;QAC9D,gEAAgE;QAChE,4EAA4E;QAC5E,wEAAwE;QACxE,sFAAsF;QACtF,IAAI,WAAW,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE;YACpC,OAAO,SAAS,CAAC;SAClB;QAED,4BAA4B;QAC5B,OAAO,WAAW;aACf,MAAM,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE;YAClB,EAAE,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;YACrB,OAAO,EAAE,CAAC;QACZ,CAAC,EAAE,EAAqB,CAAC,CAAC;IAC9B,CAAC,CAAC,EACF,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,SAAS,CAAC,EAC9B,wBAAwB,CAAC,IAAI,EAAE,aAAa,CAAC,CAC9C,CAAC;AACN,CAAC","sourcesContent":["import { Observable, OperatorFunction } from 'rxjs';\r\nimport { filter, map } from 'rxjs/operators';\r\nimport { KeyCompareMap, PickSlice } from '../interfaces';\r\nimport { distinctUntilSomeChanged } from './distinctUntilSomeChanged';\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get\r\n * filtered to only emit _defined_ values as well as checked for distinct emissions.\r\n * Comparison will be done for each set key in the `keys` array.\r\n *\r\n * `selectSlice` will only emit _valid_ selections. A selection is _valid_ if every\r\n * selected key exists and is defined in the source Observable. This ensures that the `selectSlice`\r\n * operator will always return a complete slice with all values defined.\r\n *\r\n * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute\r\n * explicitly different\r\n *\r\n * @example\r\n *\r\n * // An example with a custom comparison applied to each key\r\n * import { of } from 'rxjs';\r\n * import { selectSlice } from 'rx-angular/state';\r\n *\r\n *\r\n * const state$: Observable<MyState> = of(\r\n *  { title: 'myTitle', panelOpen: true},\r\n *  { title: 'myTitle2', panelOpen: true},\r\n *  { title: 'newTitle', panelOpen: true},\r\n *  { title: 'newTitle', panelOpen: false}\r\n * )\r\n * .pipe(\r\n *     selectSlice(['title', 'panelOpen']),\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * //  { title: 'myTitle', panelOpen: true },\r\n * //  { title: 'myTitle2', panelOpen: true },\r\n * //  { title: 'newTitle', panelOpen: true },\r\n * //  { title: 'newTitle', panelOpen: false }\r\n *\r\n * @example\r\n *\r\n * import { of, Observable } from 'rxjs';\r\n * import { tap } from 'rxjs/operators';\r\n * import { selectSlice } from 'rx-angular/state';\r\n *\r\n * interface MyState {\r\n *    title: string;\r\n *    items: string[];\r\n *    panelOpen: boolean;\r\n * }\r\n * // Select items and title.\r\n * // apply custom compare logic for the items array\r\n * const customComparison: KeyCompareMap<MyState> = {\r\n *   items: (oldItems, newItems) => compareItems(oldItems, newItems)\r\n * };\r\n * const state$: Observable<MyState> = of(\r\n * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: true },\r\n * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: false },\r\n * { title: 'nextTitle', items: ['foo', 'baR'], panelOpen: true },\r\n * { title: 'nextTitle', items: ['fooRz', 'boo'], panelOpen: false },\r\n * );\r\n * const slice$ = state$.pipe(selectSlice(['title', 'items'], customComparison), tap(console.log)).subscribe();\r\n *\r\n * // displays:\r\n * // { title: 'myTitle', items: ['foo', 'bar'] }\r\n * // { title: 'nextTitle', items: ['foo', 'baR'] }\r\n * // { title: 'nextTitle', items: ['fooRz', 'boo'] }\r\n *\r\n * @param {(K)[]} keys - the array of keys which should be selected\r\n * @param {KeyCompareMap<{ [P in K]: T[P] }>} [keyCompareMap] Optional KeyCompareMap to provide custom compare logic\r\n * for some the keys\r\n * @docsPage selectSlice\r\n * @docsCategory operators\r\n */\r\nexport function selectSlice<T extends object, K extends keyof T>(\r\n  keys: K[],\r\n  keyCompareMap?: KeyCompareMap<{ [P in K]: T[P] }>\r\n): OperatorFunction<T, PickSlice<T, K>> {\r\n  return (o$: Observable<T>): Observable<PickSlice<T, K>> =>\r\n    o$.pipe(\r\n      filter((state) => state !== undefined),\r\n      map((state) => {\r\n        // forward null\r\n        if (state === null) {\r\n          return null;\r\n        }\r\n        // an array of all keys which exist and are _defined_ in the state object\r\n        const definedKeys = keys\r\n          // filter out undefined properties e. g. {}, { str: undefined }\r\n          .filter((k) => state.hasOwnProperty(k) && state[k] !== undefined);\r\n\r\n        // we want to ensure to only emit _valid_ selections\r\n        // a selection is _valid_ if every selected key exists and has a value:\r\n\r\n        // {} => selectSlice(['foo']) => no emission\r\n        // {str: 'test'} => selectSlice([]) => no emission\r\n        // {str: 'test'} => selectSlice(['notPresent']) => no emission\r\n        // {str: 'test'} => state.select(selectSlice([])) => no emission\r\n        // {str: 'test'} => state.select(selectSlice(['notPresent'])) => no emission\r\n        // {str: undefined} => state.select(selectSlice(['str'])) => no emission\r\n        // {str: 'test', foo: undefined } => state.select(selectSlice(['foo'])) => no emission\r\n        if (definedKeys.length < keys.length) {\r\n          return undefined;\r\n        }\r\n\r\n        // create the selected slice\r\n        return definedKeys\r\n          .reduce((vm, key) => {\r\n            vm[key] = state[key];\r\n            return vm;\r\n          }, {} as PickSlice<T, K>);\r\n      }),\r\n      filter((v) => v !== undefined),\r\n      distinctUntilSomeChanged(keys, keyCompareMap)\r\n    );\r\n}\r\n\r\n"]}