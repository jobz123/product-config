{"version":3,"file":"select.js","sourceRoot":"","sources":["../../../../../../../libs/state/src/lib/rxjs/operators/select.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,MAAM,gBAAgB,CAAC;AACvC,OAAO,EAAE,qBAAqB,EAAE,kBAAkB,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AAC5F,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AAgJtC;;GAEG;AACH,MAAM,UAAU,MAAM,CACpB,GAAG,SAAgD;IAEnD,OAAO,CAAC,MAAqB,EAAE,EAAE;QAC/B,IAAI,CAAC,SAAS,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;YACxC,OAAO,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;SAChC;aAAM,IAAI,kBAAkB,CAAC,SAAS,CAAC,EAAE;YACxC,OAAO,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;SACnD;aAAM,IAAI,qBAAqB,CAAC,SAAS,CAAC,EAAE;YAC3C,OAAO,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;SACxD;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;SAClD;IACH,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { MonoTypeOperatorFunction, Observable, OperatorFunction } from 'rxjs';\r\nimport { pluck } from 'rxjs/operators';\r\nimport { isOperateFnArrayGuard, isStringArrayGuard, pipeFromArray } from '../../core/utils';\r\nimport { stateful } from './stateful';\r\n\r\n/**\r\n * @description\r\n * returns the state as shared, replayed and distinct `Observable<T>`. This way you don't have to think about late\r\n * subscribers, multiple subscribers or multiple emissions of the same value.\r\n *\r\n * @example\r\n * const state$ = state.pipe(select());\r\n * state$.subscribe(state => doStuff(state));\r\n *\r\n * @returns Observable<T>\r\n */\r\n\r\nexport function select<T>(): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * @description\r\n * returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\r\n * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\r\n *\r\n * @example\r\n * const profilePicture$ = state.pipe(\r\n *   select(\r\n *    pluck('profilePicture'),\r\n *    switchMap(profilePicture => mapImageAsync(profilePicture))\r\n *   )\r\n * );\r\n * @param  { OperatorFunction<T, A> } op\r\n * @returns Observable<A>\r\n *\r\n * @docsPage select\r\n * @docsCategory operators\r\n */\r\nexport function select<T, A>(\r\n  op: OperatorFunction<T, A>\r\n): OperatorFunction<T, A>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>\r\n): OperatorFunction<T, B>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>\r\n): OperatorFunction<T, C>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C, D>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>\r\n): OperatorFunction<T, D>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, A, B, C, D, E>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>,\r\n  op5: OperatorFunction<D, E>\r\n): OperatorFunction<T, E>;\r\n\r\n/**\r\n * @description\r\n * Access a single property of the state by providing keys.\r\n * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\r\n *\r\n * @example\r\n *  // Access a single property\r\n * const bar$ = state$.pipe(select('bar'));\r\n *\r\n * // Access a nested property\r\n * const foo$ = state$.pipe(select('bar', 'foo'));\r\n *\r\n * @return Observable<T[K1]>\r\n */\r\nexport function select<T, K1 extends keyof T>(\r\n  k1: K1\r\n): OperatorFunction<T, T[K1]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T, K1 extends keyof T, K2 extends keyof T[K1]>(\r\n  k1: K1,\r\n  k2: K2\r\n): OperatorFunction<T, T[K1][K2]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2]>(k1: K1, k2: K2, k3: K3): OperatorFunction<T, T[K1][K2][K3]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3]>(k1: K1, k2: K2, k3: K3, k4: K4): OperatorFunction<T, T[K1][K2][K3][K4]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4]>(\r\n  k1: K1,\r\n  k2: K2,\r\n  k3: K3,\r\n  k4: K4,\r\n  k5: K5\r\n): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\r\n/**\r\n * @internal\r\n */\r\nexport function select<T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4],\r\n  K6 extends keyof T[K1][K2][K3][K4][K5]>(\r\n  k1: K1,\r\n  k2: K2,\r\n  k3: K3,\r\n  k4: K4,\r\n  k5: K5,\r\n  k6: K6\r\n): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function select<T>(\r\n  ...opOrMapFn: OperatorFunction<T, any>[] | string[]\r\n): OperatorFunction<T, any> {\r\n  return (state$: Observable<T>) => {\r\n    if (!opOrMapFn || opOrMapFn.length === 0) {\r\n      return state$.pipe(stateful());\r\n    } else if (isStringArrayGuard(opOrMapFn)) {\r\n      return state$.pipe(stateful(pluck(...opOrMapFn)));\r\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\r\n      return state$.pipe(stateful(pipeFromArray(opOrMapFn)));\r\n    } else {\r\n      throw new Error('wrong params passed to select');\r\n    }\r\n  };\r\n}\r\n"]}