{"version":3,"file":"stateful.js","sourceRoot":"","sources":["../../../../../../../libs/state/src/lib/rxjs/operators/stateful.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,oBAAoB,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;AAC3E,OAAO,EAAE,qBAAqB,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AAoFxE;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,MAAM,UAAU,QAAQ,CACtB,GAAG,cAAwC;IAE3C,OAAO,CAAC,CAAgB,EAAqB,EAAE;QAC7C,OAAO,CAAC,CAAC,IAAI;QACX,gHAAgH;QAChH,gDAAgD;QAChD,oBAAoB,EAAE;QACtB,oBAAoB;QACpB,CAAC,CAAgB,EAAqB,EAAE;YACtC,IAAI,qBAAqB,CAAC,cAAc,CAAC,EAAE;gBACzC,OAAO,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC,CAAC;aAC9C;YACD,OAAO,CAAC,CAAC;QACX,CAAC;QACD,wEAAwE;QACxE,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,SAAS,CAAC;QAC9B,iCAAiC;QACjC,oBAAoB,EAAE;QACtB,gGAAgG;QAChG,WAAW,CAAC,EAAE,UAAU,EAAE,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAC/C,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { MonoTypeOperatorFunction, Observable, OperatorFunction } from 'rxjs';\r\nimport { distinctUntilChanged, filter, shareReplay } from 'rxjs/operators';\r\nimport { isOperateFnArrayGuard, pipeFromArray } from '../../core/utils';\r\n\r\n/**\r\n * @description\r\n *\r\n * As the name `stateful` implies this operator is useful when you process an Observable which maintains state.\r\n *\r\n * Maintaining state as an `Observable` source comes with a handful of repetitive as well as use case specific tasks.\r\n *\r\n * It acts like the Observables `pipe` method.\r\n * It accepts RxJS operators and composes them like `Observable#pipe` and the standalone `pipe` method.\r\n *\r\n * Furthermore, it takes care of the above mentioned repetitive tasks as listed below.\r\n *\r\n * You will always (aka repetitive) want to ensure that:\r\n * - only distinct state changes are emitted\r\n * - only defined values are emitted (filter out undefined, which ensures lazy state)\r\n * - share and replay custom operations for multiple subscribers (saves performance)\r\n *\r\n * You will sometimes (aka situational) need:\r\n * - a subset of the state (derivations)\r\n * - compose the state with other Observables or change the Observables behaviour\r\n *\r\n *\r\n * @example\r\n * import { Observable } from 'rxjs';\r\n * import { map } from 'rxjs/operators';\r\n * import { stateful } from 'rx-angular/state';\r\n *\r\n * const state$: Observable<{ name: string; items: string[] }>;\r\n * const derivation$ = state$.pipe(\r\n *   stateful(\r\n *     map(state => state.list.length),\r\n *     filter(length => length > 3)\r\n *   )\r\n * );\r\n *\r\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\r\n * @return OperatorFunction<T, A>\r\n *\r\n * @docsPage stateful\r\n * @docsCategory operators\r\n */\r\nexport function stateful<T>(): MonoTypeOperatorFunction<T>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A>(\r\n  op: OperatorFunction<T, A>\r\n): OperatorFunction<T, A>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>\r\n): OperatorFunction<T, B>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>\r\n): OperatorFunction<T, C>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C, D>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>\r\n): OperatorFunction<T, D>;\r\n/**\r\n * @internal\r\n */\r\nexport function stateful<T, A, B, C, D, E>(\r\n  op1: OperatorFunction<T, A>,\r\n  op2: OperatorFunction<A, B>,\r\n  op3: OperatorFunction<B, C>,\r\n  op4: OperatorFunction<C, D>,\r\n  op5: OperatorFunction<D, E>\r\n): OperatorFunction<T, E>;\r\n/**\r\n * @description\r\n *\r\n * As it acts like the Observables `pipe` method, it accepts one or many RxJS operators as params.\r\n *\r\n * @example\r\n * import { Observable } from 'rxjs';\r\n * import { map } from 'rxjs/operators';\r\n * import { stateful } from 'rx-angular/state';\r\n *\r\n * const state$: Observable<{ name: string; items: string[] }>;\r\n * const derivation$ = state$.pipe(\r\n *   stateful(\r\n *     map(state => state.list.length),\r\n *     filter(length => length > 3)\r\n *   )\r\n * );\r\n *\r\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\r\n *\r\n * @docsPage stateful\r\n * @docsCategory operators\r\n */\r\nexport function stateful<T, R>(\r\n  ...optionalDerive: OperatorFunction<T, R>[]\r\n): OperatorFunction<T, T | R> {\r\n  return (s: Observable<T>): Observable<T | R> => {\r\n    return s.pipe(\r\n      // distinct same base-state objects (e.g. a default emission of default switch cases, incorrect mutable handling\r\n      // of data) @TODO evaluate benefits vs. overhead\r\n      distinctUntilChanged(),\r\n      // CUSTOM LOGIC HERE\r\n      (o: Observable<T>): Observable<T | R> => {\r\n        if (isOperateFnArrayGuard(optionalDerive)) {\r\n          return o.pipe(pipeFromArray(optionalDerive));\r\n        }\r\n        return o;\r\n      },\r\n      // initial emissions, undefined is no base-state, pollution with skip(1)\r\n      filter((v) => v !== undefined),\r\n      // distinct same derivation value\r\n      distinctUntilChanged(),\r\n      // reuse custom operations result for multiple subscribers and reemit the last calculated value.\r\n      shareReplay({ bufferSize: 1, refCount: true })\r\n    );\r\n  };\r\n}\r\n"]}