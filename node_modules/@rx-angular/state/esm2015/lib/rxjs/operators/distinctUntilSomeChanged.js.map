{"version":3,"file":"distinctUntilSomeChanged.js","sourceRoot":"","sources":["../../../../../../../libs/state/src/lib/rxjs/operators/distinctUntilSomeChanged.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,oBAAoB,EAAE,MAAM,gBAAgB,CAAC;AAEtD,OAAO,EAAE,SAAS,EAAE,MAAM,6BAA6B,CAAC;AAExD;;GAEG;AACH,SAAS,cAAc,CAAI,MAAS,EAAE,MAAS;IAC7C,OAAO,MAAM,KAAK,MAAM,CAAC;AAC3B,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuEG;AACH,MAAM,UAAU,wBAAwB,CACtC,IAAS,EACT,aAAgC;IAEhC,qDAAqD;IACrD,IAAI,eAAe,GAAiB,CAAC,QAAQ,EAAE,QAAQ,EAAE,EAAE,CACzD,IAAI,CAAC,IAAI,CACP,CAAC,GAAG,EAAE,EAAE,CACN,CAAC,cAAc,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAC1E,CAAC;IAEJ,4EAA4E;IAC5E,IAAI,aAAa,KAAK,SAAS,EAAE;QAC/B,MAAM,OAAO,GAAG,CAAC,GAAM,EAAE,EAAE;YACzB,OAAO,aAAa,CAAC,cAAc,CAAC,GAAG,CAAC;gBACxC,aAAa,CAAC,GAAG,CAAC,KAAK,SAAS;gBAC9B,CAAC,CAAE,aAAa,CAAC,GAAG,CAAqB;gBACzC,CAAC,CAAC,cAAc,CAAC;QACrB,CAAC,CAAC;QACF,eAAe,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,EAAE;YACvC,OAAO,IAAI,CAAC,IAAI,CACd,CAAC,GAAG,EAAE,EAAE,CACN,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CACxE,CAAC;QACJ,CAAC,CAAC;KACH;IACD,OAAO,oBAAoB,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;AAC5E,CAAC","sourcesContent":["import { MonoTypeOperatorFunction } from 'rxjs';\r\nimport { distinctUntilChanged } from 'rxjs/operators';\r\nimport { CompareFn, KeyCompareMap } from '../interfaces';\r\nimport { safePluck } from '../../core/utils/safe-pluck';\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction defaultCompare<T>(oldVal: T, newVal: T): boolean {\r\n  return oldVal === newVal;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\r\n * the previous item. Comparison will be done for each set key in the `keys` array.\r\n *\r\n * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute\r\n * explicitly different\r\n *\r\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\r\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\r\n * compute if values are distinct or not.\r\n *\r\n * @example\r\n *\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\r\n *\r\n * interface Person {\r\n *    age: number;\r\n *    name: string;\r\n * }\r\n *\r\n * of(\r\n *   { age: 4, name: 'Hans'},\r\n *   { age: 7, name: 'Sophie'},\r\n *   { age: 5, name: 'Han Solo'},\r\n *   { age: 5, name: 'HanSophie'},\r\n * ).pipe(\r\n *   distinctUntilSomeChanged(['age', 'name']),\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Hans'}\r\n * // { age: 7, name: 'Sophie'}\r\n * // { age: 5, name: 'Han Solo'}\r\n * // { age: 5, name: 'HanSophie'}\r\n *\r\n * @example\r\n * // An example with `KeyCompareMap`\r\n * import { of } from 'rxjs';\r\n * import { distinctUntilSomeChanged } from 'rxjs/operators';\r\n *\r\n * interface Person {\r\n *     age: number;\r\n *     name: string;\r\n *  }\r\n * const customComparison: KeyCompareMap<Person> = {\r\n *   name: (oldName, newName) => oldName.substring(0, 2) === newName.substring(0, 2)\r\n * };\r\n *\r\n * of(\r\n *     { age: 4, name: 'Hans'},\r\n *     { age: 7, name: 'Sophie'},\r\n *     { age: 5, name: 'Han Solo'},\r\n *     { age: 5, name: 'HanSophie'},\r\n *   ).pipe(\r\n *     distinctUntilSomeChanged(['age', 'name'], customComparison),\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Hans' }\r\n * // { age: 7, name: 'Sophie' }\r\n * // { age: 5, name: 'Han Solo' }\r\n *\r\n * @param {K[]} keys String key for object property lookup on each item.\r\n * @param {KeyCompareMap<T>} [compare] Optional KeyCompareMap to explicitly define comparisons for some of the keys\r\n * @docsPage distinctUntilSomeChanged\r\n * @docsCategory operators\r\n */\r\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\r\n  keys: K[],\r\n  keyCompareMap?: KeyCompareMap<T>\r\n): MonoTypeOperatorFunction<T> {\r\n  // default compare function applying === to every key\r\n  let distinctCompare: CompareFn<T> = (oldState, newState) =>\r\n    keys.some(\r\n      (key) =>\r\n        !defaultCompare(safePluck(oldState, [key]), safePluck(newState, [key]))\r\n    );\r\n\r\n  // generate compare function respecting every case of provided keyCompareMap\r\n  if (keyCompareMap !== undefined) {\r\n    const compare = (key: K) => {\r\n      return keyCompareMap.hasOwnProperty(key) &&\r\n      keyCompareMap[key] !== undefined\r\n        ? (keyCompareMap[key] as CompareFn<T[K]>)\r\n        : defaultCompare;\r\n    };\r\n    distinctCompare = (oldState, newState) => {\r\n      return keys.some(\r\n        (key) =>\r\n          !compare(key)(safePluck(oldState, [key]), safePluck(newState, [key]))\r\n      );\r\n    };\r\n  }\r\n  return distinctUntilChanged((oldV, newV) => !distinctCompare(oldV, newV));\r\n}\r\n"]}