import { isDefined, isKeyOf } from '../../core';
/**
 * @description
 * Accepts an array of objects of type T and single key or array of keys (K extends keyof T).
 * The `exctract` method is pure and immutable, thus not touching the input values and returning a shallow
 * copy of the extracted source.
 *
 * @example
 *
 * const cats = [{id: 1, type: 'cat', name: 'Fluffy'}, {id: 2, type: 'cat', name: 'Emma'}];
 *
 * const catsWithoutTypes = extract(cats, ['name', 'id']);
 *
 * // catsWithoutTypes will be:
 * // [{id: 1, name: 'Fluffy'}, {id: 2, name: 'Emma'}];
 *
 * @example
 * // Usage with RxState
 *
 * export class AnimalsListComponent {
 *
 *    constructor(private state: RxState<ComponentState>, private api: ApiService) {
 *      state.connect(
 *        'animals'
 *        this.api.getAnimals(),
 *        (state, animals) => extract(animals, ['id', 'name'])
 *      );
 *    }
 * }
 *
 * @returns T
 *
 * @docsPage slice
 * @docsCategory transformation-helpers
 */
export function extract(array, keys) {
    const arrayIsArray = isDefined(array) && Array.isArray(array);
    if (!arrayIsArray) {
        console.warn(`extract: original value (${array}) is not an array.`);
        return undefined;
    }
    const sanitizedKeys = (Array.isArray(keys) ? keys : [keys]).filter(k => isKeyOf(k) && array.some(i => k in i));
    const length = sanitizedKeys.length;
    if (!sanitizedKeys.length) {
        console.warn(`extract: provided keys not found`);
        return undefined;
    }
    return array.map(item => {
        let i = 0;
        const result = {};
        for (i; i < length; i++) {
            result[sanitizedKeys[i]] = item[sanitizedKeys[i]];
        }
        return result;
    });
}
//# sourceMappingURL=extract.js.map