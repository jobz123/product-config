{"version":3,"file":"upsert.js","sourceRoot":"","sources":["../../../../../../../libs/state/src/lib/transformation-helpers/array/upsert.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,yBAAyB,CAAC;AACxD,OAAO,EAAE,cAAc,EAAE,MAAM,mCAAmC,CAAC;AAGnE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwFG;AACH,MAAM,UAAU,MAAM,CACpB,MAAW,EACX,MAAiC,EACjC,OAA2B;IAE3B,4BAA4B;IAC5B,MAAM,cAAc,GAClB,MAAM,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IACpE,4BAA4B;IAC5B,MAAM,aAAa,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IAC5C,MAAM,YAAY,GAAG,CAAC,aAAa,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,CAAC;IACnE,6FAA6F;IAC7F,sCAAsC;IACtC,0DAA0D;IAC1D,IAAI,YAAY,EAAE;QAChB,OAAO,MAAM,CAAC;KACf;IAED,uEAAuE;IACvE,iDAAiD;IACjD,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC,aAAa,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC,EAAE;QACxE,OAAO,CAAC,GAAG,cAAc,CAAQ,CAAC;KACnC;IAED,MAAM,OAAO,GAAQ,EAAE,CAAC;IACxB,MAAM,OAAO,GAA+B,EAAE,CAAC;IAC/C,0BAA0B;IAC1B,cAAc,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC9B,MAAM,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,UAAU,EAAE,EAAE,CAC5C,cAAc,CAAC,IAAS,EAAE,UAAU,EAAE,OAAO,CAAC,CAC/C,CAAC;QACF,4CAA4C;QAC5C,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;YAChB,OAAO,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;SACvB;aAAM;YACL,oCAAoC;YACpC,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;gBACvB,6CAA6C;gBAC7C,OAAO,CAAC,IAAI,mBAAO,IAAU,EAAG,CAAC;aAClC;iBAAM;gBACL,yBAAyB;gBACzB,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACpB;SACF;IACH,CAAC,CAAC,CAAC;IACH,IAAI,OAAO,GAAG,MAAM,CAAC;IACrB,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;QACnC,gCAAgC;QAChC,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE;YAChC,MAAM,WAAW,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YAC/B,sBAAsB;YACtB,IAAI,WAAW,IAAI,IAAI,EAAE;gBACvB,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;oBACvB,uCAAY,IAAI,GAAK,WAAW,EAAG;iBACpC;qBAAM;oBACL,OAAO,WAAgB,CAAC;iBACzB;aACF;YACD,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;KACJ;IACD,0EAA0E;IAC1E,OAAO,CAAC,GAAG,OAAO,EAAE,GAAG,OAAO,CAAC,CAAC;AAClC,CAAC","sourcesContent":["import { isObjectGuard } from '../../core/utils/guards';\r\nimport { valuesComparer } from '../_internals/valuesComparer.util';\r\nimport { ComparableData } from '../interfaces/comparable-data-type';\r\n\r\n/**\r\n * @description\r\n * Updates or inserts (if does not exist) one or multiple items in an array T[].\r\n * For comparison you can provide a key, an array of keys or a custom comparison function that should return true if\r\n * items match.\r\n * If no comparison is provided, an equality check is used by default.\r\n * upsert is `pure` and `immutable`, your inputs won't be changed\r\n *\r\n *\r\n * @example\r\n * // Upsert (update) with key\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\r\n *\r\n * const newCat = {id: 1, type: 'lion'};\r\n *\r\n * const updatedCreatures = upsert(creatures, newCat, 'id');\r\n *\r\n * // updatedCreatures will be:\r\n * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];\r\n *\r\n * @example\r\n * // Upsert (insert) with key\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\r\n *\r\n * const newCat = {id: 3, type: 'lion'};\r\n *\r\n * const updatedCreatures = upsert(creatures, newCat, 'id');\r\n *\r\n * // updatedCreatures will be:\r\n * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];\r\n *\r\n * @example\r\n * // Upsert (update) with array of keys\r\n *\r\n * const creatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\r\n *\r\n * const newCat = {id: 1, type: 'lion', name: 'Bella'};\r\n *\r\n * const updatedCreatures = upsert(creatures, newCat, ['id', 'name']);\r\n *\r\n * // updatedCreatures will be:\r\n * // [{id: 1, type: 'lion', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\r\n *\r\n * @example\r\n * // Update (insert) with comparison function\r\n *\r\n * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];\r\n *\r\n * const newCat = {id: 3, type: 'lion'};\r\n *\r\n * const updatedCreatures = upsert(creatures, newCat, (a, b) => a.id === b.id);\r\n *\r\n * // updatedCreatures will be:\r\n * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];\r\n *\r\n * @example\r\n * // Usage with RxState\r\n *\r\n * export class ListComponent {\r\n *\r\n *    // trigger which gets called on add/update (for reactive implementation)\r\n *    readonly addOrUpdateCreature = new Subject<Creature>();\r\n *\r\n *    constructor(private state: RxState<ComponentState>) {\r\n *      const initialCreatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];\r\n *      state.set({ creatures: initialCreatures });\r\n *      // Reactive implementation\r\n *      state.connect(\r\n *        'creatures',\r\n *        this.addOrUpdateCreature,\r\n *        ({ creatures }, creatureToUpsert) => {\r\n *            return upsert(creatures, creatureToUpsert, 'id');\r\n *        }\r\n *      );\r\n *    }\r\n *\r\n *    // Imperative implementation\r\n *    updateCreature(creatureToUpdate: Creature): void {\r\n *        this.state.set({ creatures: upsert(this.state.get('creatures'), creatureToUpdate, 'id')});\r\n *    }\r\n * }\r\n *\r\n * @returns T[]\r\n *\r\n * @docsPage upsert\r\n * @docsCategory transformation-helpers\r\n */\r\nexport function upsert<T>(\r\n  source: T[],\r\n  update: Partial<T>[] | Partial<T>,\r\n  compare?: ComparableData<T>\r\n): T[] {\r\n  // check inputs for validity\r\n  const updatesAsArray =\r\n    update != null ? (Array.isArray(update) ? update : [update]) : [];\r\n  // check inputs for validity\r\n  const sourceIsArray = Array.isArray(source);\r\n  const invalidInput = !sourceIsArray && updatesAsArray.length === 0;\r\n  // if the source value is not an Array or the input is not defined return the original source\r\n  // this is the case for any edge case:\r\n  // '', null, undefined, CustomObjectOfDoomAndDarkness, ...\r\n  if (invalidInput) {\r\n    return source;\r\n  }\r\n\r\n  // if source is empty array or not an array, but the updates are valid:\r\n  // return a shallow copy of the updates as result\r\n  if (updatesAsArray.length > 0 && (!sourceIsArray || source.length === 0)) {\r\n    return [...updatesAsArray] as T[];\r\n  }\r\n\r\n  const inserts: T[] = [];\r\n  const updates: Record<number, Partial<T>> = {};\r\n  // process updates/inserts\r\n  updatesAsArray.forEach((item) => {\r\n    const match = source.findIndex((sourceItem) =>\r\n      valuesComparer(item as T, sourceItem, compare)\r\n    );\r\n    // if item already exists, save it as update\r\n    if (match !== -1) {\r\n      updates[match] = item;\r\n    } else {\r\n      // otherwise consider this as insert\r\n      if (isObjectGuard(item)) {\r\n        // create a shallow copy if item is an object\r\n        inserts.push({ ...(item as T) });\r\n      } else {\r\n        // otherwise just push it\r\n        inserts.push(item);\r\n      }\r\n    }\r\n  });\r\n  let updated = source;\r\n  if (Object.keys(updates).length > 0) {\r\n    // if we have updates to process\r\n    updated = updated.map((item, i) => {\r\n      const updatedItem = updates[i];\r\n      // process the updated\r\n      if (updatedItem != null) {\r\n        if (isObjectGuard(item)) {\r\n          return { ...item, ...updatedItem };\r\n        } else {\r\n          return updatedItem as T;\r\n        }\r\n      }\r\n      return item;\r\n    });\r\n  }\r\n  // return the combination of the updated source & the inserts as new array\r\n  return [...updated, ...inserts];\r\n}\r\n"]}