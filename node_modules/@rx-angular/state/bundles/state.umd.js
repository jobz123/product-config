(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('rxjs/operators'), require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('@rx-angular/state', ['exports', 'rxjs', 'rxjs/operators', '@angular/core'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['rx-angular'] = global['rx-angular'] || {}, global['rx-angular'].state = {}), global.rxjs, global.rxjs.operators, global.ng.core));
}(this, (function (exports, rxjs, operators, core) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || from);
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var defaultAccumulator = function (st, sl) {
        return Object.assign(Object.assign({}, st), sl);
    };
    var ɵ0 = defaultAccumulator;
    function createAccumulationObservable(stateObservables, stateSlices, accumulatorObservable) {
        if (stateObservables === void 0) { stateObservables = new rxjs.Subject(); }
        if (stateSlices === void 0) { stateSlices = new rxjs.Subject(); }
        if (accumulatorObservable === void 0) { accumulatorObservable = new rxjs.BehaviorSubject(defaultAccumulator); }
        var signal$ = rxjs.merge(stateObservables.pipe(operators.distinctUntilChanged(), operators.mergeAll(), operators.observeOn(rxjs.queueScheduler)), stateSlices.pipe(operators.observeOn(rxjs.queueScheduler))).pipe(operators.withLatestFrom(accumulatorObservable.pipe(operators.observeOn(rxjs.queueScheduler))), operators.scan(function (state, _a) {
            var _b = __read(_a, 2), slice = _b[0], stateAccumulator = _b[1];
            return stateAccumulator(state, slice);
        }, {}), operators.tap(function (newState) { return (compositionObservable.state = newState); }, function (error) { return console.error(error); }), 
        // @Notice We catch the error here as it get lost in between `publish` and `publishReplay`. We return empty to
        operators.catchError(function (e) { return rxjs.EMPTY; }), operators.publish());
        var state$ = signal$.pipe(operators.publishReplay(1));
        var compositionObservable = {
            state: {},
            signal$: signal$,
            state$: state$,
            nextSlice: nextSlice,
            nextSliceObservable: nextSliceObservable,
            nextAccumulator: nextAccumulator,
            subscribe: subscribe
        };
        // ======
        return compositionObservable;
        // ======
        function nextAccumulator(accumulatorFn) {
            accumulatorObservable.next(accumulatorFn);
        }
        function nextSlice(stateSlice) {
            stateSlices.next(stateSlice);
        }
        function nextSliceObservable(stateObservable) {
            stateObservables.next(stateObservable);
        }
        function subscribe() {
            var sub = compositionObservable.signal$.connect();
            sub.add(compositionObservable.state$.connect());
            sub.add(function () {
                accumulatorObservable.complete();
                stateObservables.complete();
                stateSlices.complete();
            });
            return sub;
        }
    }

    function createSideEffectObservable(stateObservables) {
        if (stateObservables === void 0) { stateObservables = new rxjs.Subject(); }
        var effects$ = rxjs.merge(stateObservables.pipe(operators.mergeAll(), operators.observeOn(rxjs.queueScheduler)));
        function nextEffectObservable(effect$) {
            stateObservables.next(effect$);
        }
        function subscribe() {
            return effects$.subscribe();
        }
        return {
            effects$: effects$,
            nextEffectObservable: nextEffectObservable,
            subscribe: subscribe
        };
    }

    function pipeFromArray(fns) {
        if (!fns) {
            return rxjs.noop;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }

    function isPromiseGuard(value) {
        return (!!value &&
            typeof value.subscribe !== 'function' &&
            typeof value.then === 'function');
    }
    function isOperateFnArrayGuard(op) {
        if (!Array.isArray(op)) {
            return false;
        }
        return op.length > 0 && op.every(function (i) { return typeof i === 'function'; });
    }
    function isStringArrayGuard(op) {
        if (!Array.isArray(op)) {
            return false;
        }
        return op.length > 0 && op.every(function (i) { return typeof i === 'string'; });
    }
    function isIterableGuard(obj) {
        if (obj === null || obj === undefined) {
            return false;
        }
        return typeof obj[Symbol.iterator] === 'function';
    }
    function isKeyOf(k) {
        return (!!k &&
            (typeof k === 'string' || typeof k === 'symbol' || typeof k === 'number'));
    }
    function isObjectGuard(obj) {
        return !!obj && typeof obj === 'object' && !Array.isArray(obj);
    }
    function isDefined(val) {
        return val !== null && val !== undefined;
    }

    function safePluck(stateObject, keys) {
        // needed to match null and undefined conventions of RxAngular core components
        // safePluck(null) -> return null
        // safePluck(undefined) -> return undefined
        // safePluck(obj, ['wrongKey']) -> return undefined
        // safePluck(obj, ['correctKey']) -> return value of key
        // safePluck(obj, '') -> return undefined
        // safePluck(obj, null) -> return undefined
        if (!isDefined(stateObject)) {
            return stateObject;
        }
        if (!isDefined(keys)) {
            return undefined;
        }
        // sanitize keys -> keep only valid keys (string, number, symbol)
        var keysArr = (Array.isArray(keys) ? keys : [keys]).filter(function (k) { return isKeyOf(k); });
        if (keysArr.length === 0 ||
            !isObjectGuard(stateObject) ||
            Object.keys(stateObject).length === 0) {
            return undefined;
        }
        var prop = stateObject[keysArr.shift()];
        keysArr.forEach(function (key) {
            if (isObjectGuard(prop) && isKeyOf(key)) {
                prop = prop[key];
            }
        });
        return prop;
    }

    /**
     * @description
     *
     * As it acts like the Observables `pipe` method, it accepts one or many RxJS operators as params.
     *
     * @example
     * import { Observable } from 'rxjs';
     * import { map } from 'rxjs/operators';
     * import { stateful } from 'rx-angular/state';
     *
     * const state$: Observable<{ name: string; items: string[] }>;
     * const derivation$ = state$.pipe(
     *   stateful(
     *     map(state => state.list.length),
     *     filter(length => length > 3)
     *   )
     * );
     *
     * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated
     *
     * @docsPage stateful
     * @docsCategory operators
     */
    function stateful() {
        var optionalDerive = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            optionalDerive[_i] = arguments[_i];
        }
        return function (s) {
            return s.pipe(
            // distinct same base-state objects (e.g. a default emission of default switch cases, incorrect mutable handling
            // of data) @TODO evaluate benefits vs. overhead
            operators.distinctUntilChanged(), 
            // CUSTOM LOGIC HERE
            function (o) {
                if (isOperateFnArrayGuard(optionalDerive)) {
                    return o.pipe(pipeFromArray(optionalDerive));
                }
                return o;
            }, 
            // initial emissions, undefined is no base-state, pollution with skip(1)
            operators.filter(function (v) { return v !== undefined; }), 
            // distinct same derivation value
            operators.distinctUntilChanged(), 
            // reuse custom operations result for multiple subscribers and reemit the last calculated value.
            operators.shareReplay({ bufferSize: 1, refCount: true }));
        };
    }

    /**
     * @internal
     */
    function select() {
        var opOrMapFn = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            opOrMapFn[_i] = arguments[_i];
        }
        return function (state$) {
            if (!opOrMapFn || opOrMapFn.length === 0) {
                return state$.pipe(stateful());
            }
            else if (isStringArrayGuard(opOrMapFn)) {
                return state$.pipe(stateful(operators.pluck.apply(void 0, __spreadArray([], __read(opOrMapFn)))));
            }
            else if (isOperateFnArrayGuard(opOrMapFn)) {
                return state$.pipe(stateful(pipeFromArray(opOrMapFn)));
            }
            else {
                throw new Error('wrong params passed to select');
            }
        };
    }

    /**
     * @internal
     */
    function defaultCompare(oldVal, newVal) {
        return oldVal === newVal;
    }
    /**
     * @description
     *
     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from
     * the previous item. Comparison will be done for each set key in the `keys` array.
     *
     * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute
     * explicitly different
     *
     * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the
     * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to
     * compute if values are distinct or not.
     *
     * @example
     *
     * import { of } from 'rxjs';
     * import { distinctUntilSomeChanged } from 'rx-angular/state';
     *
     * interface Person {
     *    age: number;
     *    name: string;
     * }
     *
     * of(
     *   { age: 4, name: 'Hans'},
     *   { age: 7, name: 'Sophie'},
     *   { age: 5, name: 'Han Solo'},
     *   { age: 5, name: 'HanSophie'},
     * ).pipe(
     *   distinctUntilSomeChanged(['age', 'name']),
     * )
     * .subscribe(x => console.log(x));
     *
     * // displays:
     * // { age: 4, name: 'Hans'}
     * // { age: 7, name: 'Sophie'}
     * // { age: 5, name: 'Han Solo'}
     * // { age: 5, name: 'HanSophie'}
     *
     * @example
     * // An example with `KeyCompareMap`
     * import { of } from 'rxjs';
     * import { distinctUntilSomeChanged } from 'rxjs/operators';
     *
     * interface Person {
     *     age: number;
     *     name: string;
     *  }
     * const customComparison: KeyCompareMap<Person> = {
     *   name: (oldName, newName) => oldName.substring(0, 2) === newName.substring(0, 2)
     * };
     *
     * of(
     *     { age: 4, name: 'Hans'},
     *     { age: 7, name: 'Sophie'},
     *     { age: 5, name: 'Han Solo'},
     *     { age: 5, name: 'HanSophie'},
     *   ).pipe(
     *     distinctUntilSomeChanged(['age', 'name'], customComparison),
     *   )
     *   .subscribe(x => console.log(x));
     *
     * // displays:
     * // { age: 4, name: 'Hans' }
     * // { age: 7, name: 'Sophie' }
     * // { age: 5, name: 'Han Solo' }
     *
     * @param {K[]} keys String key for object property lookup on each item.
     * @param {KeyCompareMap<T>} [compare] Optional KeyCompareMap to explicitly define comparisons for some of the keys
     * @docsPage distinctUntilSomeChanged
     * @docsCategory operators
     */
    function distinctUntilSomeChanged(keys, keyCompareMap) {
        // default compare function applying === to every key
        var distinctCompare = function (oldState, newState) { return keys.some(function (key) { return !defaultCompare(safePluck(oldState, [key]), safePluck(newState, [key])); }); };
        // generate compare function respecting every case of provided keyCompareMap
        if (keyCompareMap !== undefined) {
            var compare_1 = function (key) {
                return keyCompareMap.hasOwnProperty(key) &&
                    keyCompareMap[key] !== undefined
                    ? keyCompareMap[key]
                    : defaultCompare;
            };
            distinctCompare = function (oldState, newState) {
                return keys.some(function (key) { return !compare_1(key)(safePluck(oldState, [key]), safePluck(newState, [key])); });
            };
        }
        return operators.distinctUntilChanged(function (oldV, newV) { return !distinctCompare(oldV, newV); });
    }

    /**
     * @description
     *
     * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get
     * filtered to only emit _defined_ values as well as checked for distinct emissions.
     * Comparison will be done for each set key in the `keys` array.
     *
     * `selectSlice` will only emit _valid_ selections. A selection is _valid_ if every
     * selected key exists and is defined in the source Observable. This ensures that the `selectSlice`
     * operator will always return a complete slice with all values defined.
     *
     * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute
     * explicitly different
     *
     * @example
     *
     * // An example with a custom comparison applied to each key
     * import { of } from 'rxjs';
     * import { selectSlice } from 'rx-angular/state';
     *
     *
     * const state$: Observable<MyState> = of(
     *  { title: 'myTitle', panelOpen: true},
     *  { title: 'myTitle2', panelOpen: true},
     *  { title: 'newTitle', panelOpen: true},
     *  { title: 'newTitle', panelOpen: false}
     * )
     * .pipe(
     *     selectSlice(['title', 'panelOpen']),
     *   )
     *   .subscribe(x => console.log(x));
     *
     * // displays:
     * //  { title: 'myTitle', panelOpen: true },
     * //  { title: 'myTitle2', panelOpen: true },
     * //  { title: 'newTitle', panelOpen: true },
     * //  { title: 'newTitle', panelOpen: false }
     *
     * @example
     *
     * import { of, Observable } from 'rxjs';
     * import { tap } from 'rxjs/operators';
     * import { selectSlice } from 'rx-angular/state';
     *
     * interface MyState {
     *    title: string;
     *    items: string[];
     *    panelOpen: boolean;
     * }
     * // Select items and title.
     * // apply custom compare logic for the items array
     * const customComparison: KeyCompareMap<MyState> = {
     *   items: (oldItems, newItems) => compareItems(oldItems, newItems)
     * };
     * const state$: Observable<MyState> = of(
     * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: true },
     * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: false },
     * { title: 'nextTitle', items: ['foo', 'baR'], panelOpen: true },
     * { title: 'nextTitle', items: ['fooRz', 'boo'], panelOpen: false },
     * );
     * const slice$ = state$.pipe(selectSlice(['title', 'items'], customComparison), tap(console.log)).subscribe();
     *
     * // displays:
     * // { title: 'myTitle', items: ['foo', 'bar'] }
     * // { title: 'nextTitle', items: ['foo', 'baR'] }
     * // { title: 'nextTitle', items: ['fooRz', 'boo'] }
     *
     * @param {(K)[]} keys - the array of keys which should be selected
     * @param {KeyCompareMap<{ [P in K]: T[P] }>} [keyCompareMap] Optional KeyCompareMap to provide custom compare logic
     * for some the keys
     * @docsPage selectSlice
     * @docsCategory operators
     */
    function selectSlice(keys, keyCompareMap) {
        return function (o$) { return o$.pipe(operators.filter(function (state) { return state !== undefined; }), operators.map(function (state) {
            // forward null
            if (state === null) {
                return null;
            }
            // an array of all keys which exist and are _defined_ in the state object
            var definedKeys = keys
                // filter out undefined properties e. g. {}, { str: undefined }
                .filter(function (k) { return state.hasOwnProperty(k) && state[k] !== undefined; });
            // we want to ensure to only emit _valid_ selections
            // a selection is _valid_ if every selected key exists and has a value:
            // {} => selectSlice(['foo']) => no emission
            // {str: 'test'} => selectSlice([]) => no emission
            // {str: 'test'} => selectSlice(['notPresent']) => no emission
            // {str: 'test'} => state.select(selectSlice([])) => no emission
            // {str: 'test'} => state.select(selectSlice(['notPresent'])) => no emission
            // {str: undefined} => state.select(selectSlice(['str'])) => no emission
            // {str: 'test', foo: undefined } => state.select(selectSlice(['foo'])) => no emission
            if (definedKeys.length < keys.length) {
                return undefined;
            }
            // create the selected slice
            return definedKeys
                .reduce(function (vm, key) {
                vm[key] = state[key];
                return vm;
            }, {});
        }), operators.filter(function (v) { return v !== undefined; }), distinctUntilSomeChanged(keys, keyCompareMap)); };
    }

    /**
     * @description
     * RxState is a light-weight reactive state management service for managing local state in angular.
     *
     * @example
     * Component({
     *   selector: 'app-stateful',
     *   template: `<div>{{ state$ | async | json }}</div>`,
     *   providers: [RxState]
     * })
     * export class StatefulComponent {
     *   readonly state$ = this.state.select();
     *
     *   constructor(private state: RxState<{ foo: string }>) {}
     * }
     *
     * @docsCategory RxState
     * @docsPage RxState
     */
    var RxState = /** @class */ (function () {
        /**
         * @internal
         */
        function RxState() {
            this.subscription = new rxjs.Subscription();
            this.accumulator = createAccumulationObservable();
            this.effectObservable = createSideEffectObservable();
            /**
             * @description
             * The unmodified state exposed as `Observable<T>`. It is not shared, distinct or gets replayed.
             * Use the `$` property if you want to read the state without having applied {@link stateful} to it.
             */
            this.$ = this.accumulator.signal$;
            this.subscription.add(this.subscribe());
        }
        /**
         * @internal
         */
        RxState.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        /**
         * @description
         *
         * Allows to customize state accumulation function.
         * This can be helpful to implement deep updates and tackle other immutability problems in a custom way.
         * @example
         *
         * ```typescript
         * const myAccumulator = (state: MyState, slice: Partial<MyState>) => deepCopy(state, slice);
         *
         * this.state.setAccumulator(myAccumulator);
         * ```
         */
        RxState.prototype.setAccumulator = function (accumulatorFn) {
            this.accumulator.nextAccumulator(accumulatorFn);
        };
        /** @internal **/
        RxState.prototype.get = function () {
            var keys = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                keys[_i] = arguments[_i];
            }
            var hasStateAnyKeys = Object.keys(this.accumulator.state).length > 0;
            if (!!keys && keys.length) {
                return safePluck(this.accumulator.state, keys);
            }
            else {
                return hasStateAnyKeys ?
                    this.accumulator.state :
                    undefined;
            }
        };
        /**
         * @internal
         */
        RxState.prototype.set = function (keyOrStateOrProjectState, stateOrSliceProjectFn) {
            if (typeof keyOrStateOrProjectState === 'object' &&
                stateOrSliceProjectFn === undefined) {
                this.accumulator.nextSlice(keyOrStateOrProjectState);
                return;
            }
            if (typeof keyOrStateOrProjectState === 'function' &&
                stateOrSliceProjectFn === undefined) {
                this.accumulator.nextSlice(keyOrStateOrProjectState(this.accumulator.state));
                return;
            }
            if (isKeyOf(keyOrStateOrProjectState) &&
                typeof stateOrSliceProjectFn === 'function') {
                var state = {};
                state[keyOrStateOrProjectState] = stateOrSliceProjectFn(this.accumulator.state);
                this.accumulator.nextSlice(state);
                return;
            }
            throw new Error('wrong params passed to set');
        };
        /**
         * @internal
         */
        RxState.prototype.connect = function (keyOrInputOrSlice$, projectOrSlices$, projectValueFn) {
            var _this = this;
            if (rxjs.isObservable(keyOrInputOrSlice$) &&
                projectOrSlices$ === undefined &&
                projectValueFn === undefined) {
                this.accumulator.nextSliceObservable(keyOrInputOrSlice$);
                return;
            }
            if (rxjs.isObservable(keyOrInputOrSlice$) &&
                typeof projectOrSlices$ === 'function' &&
                !rxjs.isObservable(projectOrSlices$) &&
                projectValueFn === undefined) {
                var project_1 = projectOrSlices$;
                var slice$ = keyOrInputOrSlice$.pipe(operators.map(function (v) { return project_1(_this.get(), v); }));
                this.accumulator.nextSliceObservable(slice$);
                return;
            }
            if (isKeyOf(keyOrInputOrSlice$) &&
                rxjs.isObservable(projectOrSlices$) &&
                projectValueFn === undefined) {
                var key_1 = keyOrInputOrSlice$;
                var slice$ = projectOrSlices$.pipe(operators.map(function (value) {
                    var _a;
                    return (Object.assign({}, (_a = {}, _a[key_1] = value, _a)));
                }));
                this.accumulator.nextSliceObservable(slice$);
                return;
            }
            if (isKeyOf(keyOrInputOrSlice$) &&
                rxjs.isObservable(projectOrSlices$) &&
                typeof projectValueFn === 'function') {
                var key_2 = keyOrInputOrSlice$;
                var slice$ = projectOrSlices$.pipe(operators.map(function (value) {
                    var _a;
                    return (Object.assign({}, (_a = {}, _a[key_2] = projectValueFn(_this.get(), value), _a)));
                }));
                this.accumulator.nextSliceObservable(slice$);
                return;
            }
            throw new Error('wrong params passed to connect');
        };
        /**
         * @internal
         */
        RxState.prototype.select = function () {
            var opOrMapFn = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                opOrMapFn[_i] = arguments[_i];
            }
            if (!opOrMapFn || opOrMapFn.length === 0) {
                return this.accumulator.state$.pipe(stateful());
            }
            else if (isStringArrayGuard(opOrMapFn)) {
                return this.accumulator.state$.pipe(stateful(operators.pluck.apply(void 0, __spreadArray([], __read(opOrMapFn)))));
            }
            else if (isOperateFnArrayGuard(opOrMapFn)) {
                return this.accumulator.state$.pipe(stateful(pipeFromArray(opOrMapFn)));
            }
            throw new Error('wrong params passed to select');
        };
        /**
         * @description
         * Manages side-effects of your state. Provide an `Observable<any>` **side-effect** and an optional
         * `sideEffectFunction`.
         * Subscription handling is done automatically.
         *
         * @example
         * // Directly pass an observable side-effect
         * const localStorageEffect$ = changes$.pipe(
         *  tap(changes => storeChanges(changes))
         * );
         * state.hold(localStorageEffect$);
         *
         * // Pass an additional `sideEffectFunction`
         *
         * const localStorageEffectFn = changes => storeChanges(changes);
         * state.hold(changes$, localStorageEffectFn);
         *
         * @param {Observable<S>} obsOrObsWithSideEffect
         * @param {function} [sideEffectFn]
         */
        RxState.prototype.hold = function (obsOrObsWithSideEffect, sideEffectFn) {
            var sideEffect = obsOrObsWithSideEffect.pipe(operators.catchError(function (e) { return rxjs.EMPTY; }));
            if (typeof sideEffectFn === 'function') {
                this.effectObservable.nextEffectObservable(sideEffect.pipe(operators.tap(sideEffectFn)));
                return;
            }
            this.effectObservable.nextEffectObservable(sideEffect);
        };
        /**
         * @internal
         */
        RxState.prototype.subscribe = function () {
            var subscription = new rxjs.Subscription();
            subscription.add(this.accumulator.subscribe());
            subscription.add(this.effectObservable.subscribe());
            return subscription;
        };
        return RxState;
    }());
    RxState.decorators = [
        { type: core.Injectable }
    ];
    /** @nocollapse */
    RxState.ctorParameters = function () { return []; };

    /**
     * @description
     * Inserts one or multiple items to an array T[].
     * Returns a shallow copy of the updated array T[], and does not mutate the original one.
     *
     * @example
     * // Inserting single value
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const updatedCreatures = insert(creatures, {id: 3, type: 'parrot'});
     *
     * // updatedCreatures will be:
     * //  [{id: 1, type: 'cat'}, {id: 2, type: 'dog}, {id: 3, type: 'parrot}];
     *
     * @example
     * // Inserting multiple values
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const updatedCreatures = insert(creatures, [{id: 3, type: 'parrot'}, {id: 4, type: 'hamster'}]);
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'parrot'}, {id: 4, type: 'hamster'}];
     *
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *
     *    readonly insertCreature$ = new Subject<void>();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        'creatures',
     *        this.insertCreature$,
     *        ({ creatures }) => {
     *            const creatureToAdd = {id: generateId(), name: 'newCreature', type: 'dinosaur' };
     *            return insert(creatures, creatureToAdd);
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    insertCeature(): void {
     *        const creatureToAdd = {id: generateId(), name: 'newCreature', type: 'dinosaur' };
     *        this.state.set({ creatures: insert(this.state.get().creatures, creatureToAdd)});
     *    }
     * }
     *
     *
     * @returns T[]
     *
     * @docsPage insert
     * @docsCategory transformation-helpers
     */
    function insert(source, updates) {
        var updatesDefined = isDefined(updates);
        var sourceIsArray = Array.isArray(source);
        var invalidInput = !sourceIsArray && !updatesDefined;
        if (!sourceIsArray && isDefined(source)) {
            console.warn("Insert: Original value (" + source + ") is not an array.");
        }
        if (invalidInput) {
            return source;
        }
        return __spreadArray(__spreadArray([], __read((sourceIsArray ? source : []))), __read((updatesDefined ? (Array.isArray(updates) ? updates : [updates]) : [])));
    }

    function valuesComparer(original, incoming, compare) {
        var defaultCompare = function (a, b) { return a === b; };
        if (isKeyOf(compare)) {
            return original[compare] === incoming[compare];
        }
        if (Array.isArray(compare)) {
            var sanitizedKeys = compare.filter(function (k) { return isKeyOf(k); });
            return !!sanitizedKeys.length
                ? sanitizedKeys.every(function (k) { return original[k] === incoming[k]; })
                : defaultCompare(original, incoming);
        }
        return (compare || defaultCompare)(original, incoming);
    }

    /**
     * @description
     * Removes one or multiple items from an array T[].
     * For comparison you can provide a key, an array of keys or a custom comparison function that should return true if items match.
     * If no comparison data is provided, an equality check is used by default.
     * Returns a shallow copy of the updated array T[], and does not mutate the original one.
     *
     * @example
     * // Removing value without comparison data
     *
     * const items = [1,2,3,4,5];
     *
     * const updatedItems = remove(items, [1,2,3]);
     *
     * // updatedItems will be: [4,5];
     *
     * @example
     * // Removing values with comparison function
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
     *
     * const nonExistingCreatures = [{id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
     *
     * const realCreatures = remove(creatures, nonExistingCreatures, (a, b) => a.id === b.id);
     *
     * // realCreatures will be: [{id: 1, type: 'cat'}];
     *
     * @example
     * // Removing values with key
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
     *
     * const nonExistingCreatures = [{id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
     *
     * const realCreatures = remove(creatures, nonExistingCreatures, 'id');
     *
     * // realCreatures will be: [{id: 1, type: 'cat'}];
     *
     * @example
     * // Removing values with array of keys
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
     *
     * const nonExistingCreatures = [{id: 2, type: 'unicorn'}, {id: 3, type: 'kobold'}];
     *
     * const realCreatures = remove(creatures, nonExistingCreatures, ['id', 'type']);
     *
     * // realCreatures will be: [{id: 1, type: 'cat'}];
     *
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *
     *    readonly removeCreature$ = new Subject<Creature>();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        'creatures',
     *        this.removeCreature$,
     *        ({ creatures }, creatureToRemove) => {
     *            return remove(creatures, creatureToRemove, (a, b) => a.id === b.id);
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    removeCreature(creatureToRemove: Creature): void {
     *        this.state.set({ creatures: remove(this.state.get().creatures, creatureToRemove, (a, b) => a.id === b.id)});
     *    }
     * }
     *
     * @returns T[]
     *
     * @docsPage remove
     * @docsCategory transformation-helpers
     */
    function remove(source, scrap, compare) {
        var scrapAsArray = isDefined(scrap)
            ? Array.isArray(scrap)
                ? scrap
                : [scrap]
            : [];
        var invalidInput = !Array.isArray(source);
        if (invalidInput) {
            console.warn("Remove: original value (" + source + ") is not an array");
            return source;
        }
        return source.filter(function (existingItem) {
            return !scrapAsArray.some(function (item) { return valuesComparer(item, existingItem, compare); });
        });
    }

    /**
     * @description
     * Converts an array of objects to a dictionary {[key: string]: T}.
     * Accepts array T[] and key of type string, number or symbol as inputs.
     *
     *
     * @example
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'parrot'}];
     *
     * const creaturesDictionary = toDictionary(creatures, 'id');
     *
     * // creaturesDictionary will be:
     * // {
     * //  1: {id: 1, type: 'cat'},
     * //  2: {id: 2, type: 'dog'},
     * //  3: {id: 3, type: 'parrot'}
     * // };
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *
     *    readonly convertToDictionary$ = new Subject();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        'creaturesDictionary',
     *        this.convertToDictionary$,
     *        ({ creatures }) => {
     *            return toDictionary(creatures, 'id');
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    convertToDictionary(): void {
     *        this.state.set({ creaturesDictionary: toDictionary(this.state.get().creatures, 'id'});
     *    }
     * }
     *
     * @see {@link OnlyKeysOfSpecificType}
     * @param {OnlyKeysOfSpecificType<T, S>} key
     * @returns { [key: string]: T[] }
     * @docsPage toDictionary
     * @docsCategory transformation-helpers
     */
    function toDictionary(source, key) {
        if (!isDefined(source)) {
            return source;
        }
        var sourceEmpty = !source.length;
        if (!Array.isArray(source) || sourceEmpty || !isKeyOf(source[0][key])) {
            if (!sourceEmpty) {
                console.warn('ToDictionary: unexpected input params.');
            }
            return {};
        }
        var dictionary = {};
        var length = source.length;
        var i = 0;
        for (i; i < length; i++) {
            dictionary["" + source[i][key]] = Object.assign({}, source[i]);
        }
        return dictionary;
    }

    /**
     * @description
     * Updates one or multiple items in an array T[].
     * For comparison you can provide key, array of keys or a custom comparison function that should return true if items match.
     * If no comparison is provided, an equality check is used by default.
     * Returns a shallow copy of the array T[] and updated items, does not mutate the original array.
     *
     * @example
     * // Update with comparison function
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const newCat = {id: 1, type: 'lion'};
     *
     * const updatedCreatures = update(creatures, newCat, (a, b) => a.id === b.id);
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];
     *
     * @example
     * // Update with key
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const newCat = {id: 1, type: 'lion'};
     *
     * const updatedCreatures = update(creatures, newCat, 'id');
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];
     *
     * @example
     * // Update with array of keys
     *
     * const creatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
     *
     * const newCat = {id: 1, type: 'lion', name: 'Bella'};
     *
     * const updatedCreatures = update(creatures, newCat, ['id', 'name']);
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'lion', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
     *
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *
     *    readonly updateCreature$ = new Subject<Creature>();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        'creatures',
     *        this.updateCreature$,
     *        ({ creatures }, creatureToUpdate) => {
     *            return update(creatures, creatureToUpdate, (a, b) => a.id === b.id);
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    updateCreature(creatureToUpdate: Creature): void {
     *        this.state.set({ creatures: update(this.state.get().creatures, creatureToUpdate, (a, b) => a.id === b.id)});
     *    }
     * }
     *
     * @returns T[]
     *
     * @docsPage update
     * @docsCategory transformation-helpers
     */
    function update(source, updates, compare) {
        var updatesDefined = updates != null;
        var updatesAsArray = updatesDefined
            ? Array.isArray(updates)
                ? updates
                : [updates]
            : [];
        var sourceDefined = source != null;
        var sourceIsArray = Array.isArray(source);
        var invalidInput = !sourceIsArray || source.length === 0 || updatesAsArray.length === 0;
        if (sourceDefined && !sourceIsArray) {
            console.warn("Update: Original value (" + source + ") is not an array.");
        }
        if (invalidInput) {
            return source;
        }
        return source.map(function (existingItem) {
            var match = updatesAsArray.find(function (item) { return valuesComparer(item, existingItem, compare); });
            if (match) {
                return Object.assign(Object.assign({}, existingItem), match);
            }
            return existingItem;
        });
    }

    /**
     * @description
     * Accepts an array of objects of type T and single key or array of keys (K extends keyof T).
     * The `exctract` method is pure and immutable, thus not touching the input values and returning a shallow
     * copy of the extracted source.
     *
     * @example
     *
     * const cats = [{id: 1, type: 'cat', name: 'Fluffy'}, {id: 2, type: 'cat', name: 'Emma'}];
     *
     * const catsWithoutTypes = extract(cats, ['name', 'id']);
     *
     * // catsWithoutTypes will be:
     * // [{id: 1, name: 'Fluffy'}, {id: 2, name: 'Emma'}];
     *
     * @example
     * // Usage with RxState
     *
     * export class AnimalsListComponent {
     *
     *    constructor(private state: RxState<ComponentState>, private api: ApiService) {
     *      state.connect(
     *        'animals'
     *        this.api.getAnimals(),
     *        (state, animals) => extract(animals, ['id', 'name'])
     *      );
     *    }
     * }
     *
     * @returns T
     *
     * @docsPage slice
     * @docsCategory transformation-helpers
     */
    function extract(array, keys) {
        var arrayIsArray = isDefined(array) && Array.isArray(array);
        if (!arrayIsArray) {
            console.warn("extract: original value (" + array + ") is not an array.");
            return undefined;
        }
        var sanitizedKeys = (Array.isArray(keys) ? keys : [keys]).filter(function (k) { return isKeyOf(k) && array.some(function (i) { return k in i; }); });
        var length = sanitizedKeys.length;
        if (!sanitizedKeys.length) {
            console.warn("extract: provided keys not found");
            return undefined;
        }
        return array.map(function (item) {
            var i = 0;
            var result = {};
            for (i; i < length; i++) {
                result[sanitizedKeys[i]] = item[sanitizedKeys[i]];
            }
            return result;
        });
    }

    /**
     * @description
     * Updates or inserts (if does not exist) one or multiple items in an array T[].
     * For comparison you can provide a key, an array of keys or a custom comparison function that should return true if
     * items match.
     * If no comparison is provided, an equality check is used by default.
     * upsert is `pure` and `immutable`, your inputs won't be changed
     *
     *
     * @example
     * // Upsert (update) with key
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const newCat = {id: 1, type: 'lion'};
     *
     * const updatedCreatures = upsert(creatures, newCat, 'id');
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'lion'}, {id: 2, type: 'dog'}];
     *
     * @example
     * // Upsert (insert) with key
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const newCat = {id: 3, type: 'lion'};
     *
     * const updatedCreatures = upsert(creatures, newCat, 'id');
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];
     *
     * @example
     * // Upsert (update) with array of keys
     *
     * const creatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
     *
     * const newCat = {id: 1, type: 'lion', name: 'Bella'};
     *
     * const updatedCreatures = upsert(creatures, newCat, ['id', 'name']);
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'lion', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
     *
     * @example
     * // Update (insert) with comparison function
     *
     * const creatures = [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}];
     *
     * const newCat = {id: 3, type: 'lion'};
     *
     * const updatedCreatures = upsert(creatures, newCat, (a, b) => a.id === b.id);
     *
     * // updatedCreatures will be:
     * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'lion'}];
     *
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *
     *    // trigger which gets called on add/update (for reactive implementation)
     *    readonly addOrUpdateCreature = new Subject<Creature>();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      const initialCreatures = [{id: 1, type: 'cat', name: 'Bella'}, {id: 2, type: 'dog', name: 'Sparky'}];
     *      state.set({ creatures: initialCreatures });
     *      // Reactive implementation
     *      state.connect(
     *        'creatures',
     *        this.addOrUpdateCreature,
     *        ({ creatures }, creatureToUpsert) => {
     *            return upsert(creatures, creatureToUpsert, 'id');
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    updateCreature(creatureToUpdate: Creature): void {
     *        this.state.set({ creatures: upsert(this.state.get('creatures'), creatureToUpdate, 'id')});
     *    }
     * }
     *
     * @returns T[]
     *
     * @docsPage upsert
     * @docsCategory transformation-helpers
     */
    function upsert(source, update, compare) {
        // check inputs for validity
        var updatesAsArray = update != null ? (Array.isArray(update) ? update : [update]) : [];
        // check inputs for validity
        var sourceIsArray = Array.isArray(source);
        var invalidInput = !sourceIsArray && updatesAsArray.length === 0;
        // if the source value is not an Array or the input is not defined return the original source
        // this is the case for any edge case:
        // '', null, undefined, CustomObjectOfDoomAndDarkness, ...
        if (invalidInput) {
            return source;
        }
        // if source is empty array or not an array, but the updates are valid:
        // return a shallow copy of the updates as result
        if (updatesAsArray.length > 0 && (!sourceIsArray || source.length === 0)) {
            return __spreadArray([], __read(updatesAsArray));
        }
        var inserts = [];
        var updates = {};
        // process updates/inserts
        updatesAsArray.forEach(function (item) {
            var match = source.findIndex(function (sourceItem) { return valuesComparer(item, sourceItem, compare); });
            // if item already exists, save it as update
            if (match !== -1) {
                updates[match] = item;
            }
            else {
                // otherwise consider this as insert
                if (isObjectGuard(item)) {
                    // create a shallow copy if item is an object
                    inserts.push(Object.assign({}, item));
                }
                else {
                    // otherwise just push it
                    inserts.push(item);
                }
            }
        });
        var updated = source;
        if (Object.keys(updates).length > 0) {
            // if we have updates to process
            updated = updated.map(function (item, i) {
                var updatedItem = updates[i];
                // process the updated
                if (updatedItem != null) {
                    if (isObjectGuard(item)) {
                        return Object.assign(Object.assign({}, item), updatedItem);
                    }
                    else {
                        return updatedItem;
                    }
                }
                return item;
            });
        }
        // return the combination of the updated source & the inserts as new array
        return __spreadArray(__spreadArray([], __read(updated)), __read(inserts));
    }

    /**
     * @description
     * Accepts an object of type T and key of type K extends keyof T.
     * Removes property from an object and returns a shallow copy of the updated object without specified property.
     * If property not found returns copy of the original object.
     * Not mutating original object.
     *
     * @example
     *
     * const cat = {id: 1, type: 'cat', name: 'Fluffy'};
     *
     * const anonymusCat = deleteProp(cat, 'name');
     *
     * // anonymusCat will be:
     * // {id: 1, type: 'cat'};
     *
     * @example
     * // Usage with RxState
     *
     * export class ProfileComponent {
     *
     *    readonly removeName$ = new Subject();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        this.removeName$,
     *        (state) => {
     *            return deleteProp(state, 'name');
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    removeName(): void {
     *        this.state.set(remove(this.get(), 'name'));
     *    }
     * }
     *
     * @returns Omit<T, K>
     *
     * @docsPage deleteProp
     * @docsCategory transformation-helpers
     */
    function deleteProp(object, key) {
        if (!isDefined(object) || !isObjectGuard(object)) {
            console.warn("DeleteProp: original value " + object + " is not an object.");
            return object;
        }
        if (!isKeyOf(key)) {
            console.warn("DeleteProp: provided key is not a string, number or symbol.");
            return Object.assign({}, object);
        }
        var copy = Object.assign({}, object);
        delete copy[key];
        return copy;
    }

    /**
     * @description
     * Converts a dictionary of type {[key: string]: T} to array T[].
     *
     * @example
     *
     * const creaturesDictionary = {
     *   '1': {id: 1, type: 'cat'},
     *   '2': {id: 2, type: 'dog'},
     *   '3': {id: 3, type: 'parrot'}
     * };
     *
     * const creaturesArray = dictionaryToArray(creaturesDictionary);
     *
     * // creaturesArray will be:
     * // [{id: 1, type: 'cat'}, {id: 2, type: 'dog'}, {id: 3, type: 'parrot'}];
     *
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *    readonly removeName$ = new Subject();
     *
     *    constructor(
     *      private state: RxState<ComponentState>,
     *      private api: ApiService
     *    ) {
     *      // Reactive implementation
     *      state.connect(
     *        'creatures',
     *        this.api.creaturesDictionary$,
     *        (_, creatures) => {
     *            return dictionaryToArray(creatures);
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    removeName(): void {
     *      this.api.creaturesDictionary$.pipe(
     *        // subscription handling logic
     *      ).subscribe(
     *        dictionary => this.set({creatures: dictionaryToArray(dictionary)})
     *      );
     *    }
     * }
     *
     * @returns T[];
     *
     * @docsPage dictionaryToArray
     * @docsCategory transformation-helpers
     */
    function dictionaryToArray(dictionary) {
        if (!isDefined(dictionary)) {
            return dictionary;
        }
        if (!isObjectGuard(dictionary)) {
            console.warn("DictionaryToArray: unexpected input.");
            return [];
        }
        return Object.values(dictionary);
    }

    /**
     * @description
     * Merges an object of type T with updates of type Partial<T>.
     * Returns a new object where updates override original values while not mutating the original one.

     * @example
     * interface Creature {
     *  id: number,
     *  type: string,
     *  name: string
     * }
     *
     * const cat = {id: 1, type: 'cat'};
     *
     * const catWithname = patch(cat, {name: 'Fluffy'});
     *
     * // catWithname will be:
     * // {id: 1, type: 'cat', name: 'Fluffy'};
     *
     * @example
     * // Usage with RxState
     *
     * export class ProfileComponent {
     *
     *    readonly changeName$ = new Subject<string>();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        this.changeName$,
     *        (state, name) => {
     *            return patch(state, { name });
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    changeName(name: string): void {
     *        this.state.set(patch(this.get(), { name }));
     *    }
     * }
     *
     * @returns T
     *
     * @docsPage patch
     * @docsCategory transformation-helpers
     */
    function patch(object, upd) {
        var update = isObjectGuard(upd) ? upd : {};
        if (!isObjectGuard(object) && isObjectGuard(upd)) {
            console.warn("Patch: original value " + object + " is not an object.");
            return Object.assign({}, update);
        }
        if (!isObjectGuard(object) && !isObjectGuard(upd)) {
            console.warn("Patch: original value " + object + " and updates " + upd + " are not objects.");
            return object;
        }
        return Object.assign(Object.assign({}, object), update);
    }

    /**
     * @description
     * Accepts an object of type T, key of type K extends keyof T, and value of type T[K].
     * Sets the property and returns a newly updated shallow copy of an object while not mutating the original one.
     *
     * @example
     *
     * const cat = {id: 1, type: 'cat', name: 'Fluffy'};
     *
     * const renamedCat = setProp(cat, 'name', 'Bella');
     *
     * // renamedCat will be:
     * // {id: 1, type: 'cat', name: 'Bella'};
     *
     * @example
     * // Usage with RxState
     *
     * export class ProfileComponent {
     *
     *    readonly changeName$ = new Subject<string>();
     *
     *    constructor(private state: RxState<ComponentState>) {
     *      // Reactive implementation
     *      state.connect(
     *        this.changeName$,
     *        (state, name) => {
     *            return setProp(state, 'name', name);
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    changeName(name: string): void {
     *        this.state.set(setProp(this.get(), 'name', name));
     *    }
     * }
     *
     * @returns T
     *
     * @docsPage setProp
     * @docsCategory transformation-helpers
     */
    function setProp(object, key, value) {
        var _a;
        var objectIsObject = isObjectGuard(object);
        var keyIsValid = isKeyOf(key);
        var initialObject = objectIsObject ? object : {};
        if (!objectIsObject) {
            console.warn("SetProp: original value (" + object + ") is not an object.");
        }
        if (!keyIsValid) {
            console.warn("SetProp: key argument (" + key + ") is invalid.");
        }
        if (!isDefined(object) && !keyIsValid) {
            return object;
        }
        if (keyIsValid) {
            return Object.assign(Object.assign({}, initialObject), (_a = {}, _a[key] = value, _a));
        }
        return Object.assign({}, initialObject);
    }

    /**
     * @description
     * Toggles a boolean property in the object.
     * Accepts object of type T and key value of which is boolean.
     * Toggles the property and returns a shallow copy of an object, while not mutating the original one.
     *
     * @example
     *
     * const state = {items: [1,2,3], loading: true};
     *
     * const updatedState = toggle(state, 'loading');
     *
     * // updatedState will be:
     * // {items: [1,2,3], loading: false};
     *
     * @example
     * // Usage with RxState
     *
     * export class ListComponent {
     *    readonly loadingChange$ = new Subject();
     *
     *    constructor(
     *      private state: RxState<ComponentState>
     *    ) {
     *      // Reactive implementation
     *      state.connect(
     *        this.api.loadingChange$,
     *        (state, _) => {
     *            return toggle(state, 'isLoading');
     *        }
     *      );
     *    }
     *
     *    // Imperative implementation
     *    toggleLoading(): void {
     *      this.set(toggle(state, 'isLoading'));
     *    }
     * }
     *
     * @returns T
     *
     * @docsPage toggle
     * @docsCategory transformation-helpers
     */
    function toggle(object, key) {
        var _a;
        var objectIsObject = isObjectGuard(object);
        var keyIsValid = isKeyOf(key);
        var initialObject = objectIsObject ? object : {};
        if (!objectIsObject) {
            console.warn("Toggle: original value (" + object + ") is not an object.");
        }
        if (!keyIsValid) {
            console.warn("Toggle: key argument (" + key + ") is invalid.");
        }
        if (keyIsValid && typeof initialObject[key] !== 'boolean') {
            console.warn("Toggle: value of the key (" + key + ") is not a boolean.");
        }
        if (!isDefined(object) && !keyIsValid) {
            return object;
        }
        if (keyIsValid &&
            (typeof initialObject[key] === 'boolean' ||
                !initialObject.hasOwnProperty(key))) {
            return Object.assign(Object.assign({}, initialObject), (_a = {}, _a[key] = !initialObject[key], _a));
        }
        return Object.assign({}, initialObject);
    }

    /**
     * @description
     * Accepts an object of type T and single key or array of keys (K extends keyof T).
     * Constructs new object based on provided keys.
     *
     * @example
     *
     * const cat = {id: 1, type: 'cat', name: 'Fluffy'};
     *
     * const catWithoutType = slice(cat, ['name', 'id']);
     *
     * // catWithoutType will be:
     * // {id: 1, name: 'Fluffy'};
     *
     * @example
     * // Usage with RxState
     *
     * export class AnimalsListComponent {
     *
     *    constructor(private state: RxState<ComponentState>, private api: ApiService) {
     *      state.connect(
     *        'animals'
     *        this.api.getAnimals(),
     *        (state, animals) => {
     *            return animals.map(animal => slice(animal, ['id', 'name']));
     *        }
     *      );
     *    }
     * }
     *
     * @returns T
     *
     * @docsPage slice
     * @docsCategory transformation-helpers
     */
    function slice(object, keys) {
        var objectIsObject = isDefined(object) && isObjectGuard(object);
        if (!objectIsObject) {
            console.warn("slice: original value (" + object + ") is not an object.");
            return undefined;
        }
        var sanitizedKeys = (Array.isArray(keys) ? keys : [keys]).filter(function (k) { return isKeyOf(k) && k in object; });
        if (!sanitizedKeys.length) {
            console.warn("slice: provided keys not found");
            return undefined;
        }
        return sanitizedKeys.reduce(function (acc, k) {
            var _a;
            return (Object.assign(Object.assign({}, acc), (_a = {}, _a[k] = object[k], _a)));
        }, {});
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.RxState = RxState;
    exports.createAccumulationObservable = createAccumulationObservable;
    exports.createSideEffectObservable = createSideEffectObservable;
    exports.deleteProp = deleteProp;
    exports.dictionaryToArray = dictionaryToArray;
    exports.distinctUntilSomeChanged = distinctUntilSomeChanged;
    exports.extract = extract;
    exports.insert = insert;
    exports.patch = patch;
    exports.remove = remove;
    exports.select = select;
    exports.selectSlice = selectSlice;
    exports.setProp = setProp;
    exports.slice = slice;
    exports.stateful = stateful;
    exports.toDictionary = toDictionary;
    exports.toggle = toggle;
    exports.update = update;
    exports.upsert = upsert;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=state.umd.js.map
