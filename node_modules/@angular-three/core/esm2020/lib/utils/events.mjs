/**
 * From r3f https://github.com/pmndrs/react-three-fiber/blob/master/packages/fiber/src/core/events.ts
 */
import * as THREE from 'three';
import { makeId } from './make-id';
/** Release pointer captures.
 * This is called by releasePointerCapture in the API, and when an object is removed.
 */
function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {
    const captureData = captures.get(obj);
    if (captureData) {
        captures.delete(obj);
        // If this was the last capturing object for this pointer
        if (captures.size === 0) {
            capturedMap.delete(pointerId);
            captureData.target.releasePointerCapture(pointerId);
        }
    }
}
export function removeInteractivity(eventsStateGetter, object) {
    const { internal } = eventsStateGetter();
    // Removes every trace of an object from the data store
    internal.interaction = internal.interaction.filter((o) => o !== object);
    internal.initialHits = internal.initialHits.filter((o) => o !== object);
    internal.hovered.forEach((value, key) => {
        if (value.eventObject === object || value.object === object) {
            internal.hovered.delete(key);
        }
    });
    internal.capturedMap.forEach((captures, pointerId) => {
        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);
    });
}
function getRenderState(state) {
    const { mouse, camera, clock, renderer, scene, size, viewport } = state;
    const delta = clock.getDelta();
    return {
        size,
        mouse,
        camera: camera,
        delta,
        clock,
        renderer: renderer,
        scene: scene,
        viewport,
    };
}
export function createEvents(stateGetter, eventsStateGetter) {
    const temp = new THREE.Vector3();
    /** Sets up defaultRaycaster */
    function prepareRay(event) {
        const state = stateGetter();
        const { raycaster, mouse, camera, size } = state;
        // https://github.com/pmndrs/react-three-fiber/pull/782
        // Events trigger outside of canvas when moved
        if (raycaster && camera) {
            const { offsetX, offsetY } = raycaster?.computeOffsets?.(event, getRenderState(state)) ?? event;
            const { width, height } = size;
            mouse.set((offsetX / width) * 2 - 1, -(offsetY / height) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
        }
    }
    /** Calculates delta */
    function calculateDistance(event) {
        const { internal } = eventsStateGetter();
        const dx = event.offsetX - internal.initialClick[0];
        const dy = event.offsetY - internal.initialClick[1];
        return Math.round(Math.sqrt(dx * dx + dy * dy));
    }
    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */
    function filterPointerEvents(objects) {
        return objects.filter((obj) => ['move', 'over', 'enter', 'out', 'leave'].some((name) => obj.__ngt?.handlers?.[('pointer' + name)]));
    }
    function intersect(filter) {
        const canvasState = stateGetter();
        const { internal } = eventsStateGetter();
        const { raycaster } = canvasState;
        // Skip event handling when noEvents is set
        if (!raycaster?.enabled)
            return [];
        const seen = new Set();
        const intersections = [];
        // Allow callers to eliminate event objects
        const eventsObjects = filter
            ? filter(internal.interaction)
            : internal.interaction;
        // Intersect known handler objects and filter against duplicates
        let intersects = raycaster
            .intersectObjects(eventsObjects, true)
            .filter((item) => {
            const id = makeId(item);
            if (seen.has(id))
                return false;
            seen.add(id);
            return true;
        });
        // https://github.com/mrdoob/three.js/issues/16031
        // Allow custom userland intersect sort order
        if (raycaster.filter)
            intersects = raycaster.filter(intersects, getRenderState(canvasState));
        for (const intersect of intersects) {
            let eventObject = intersect.object;
            // Bubble event up
            while (eventObject) {
                if (eventObject.__ngt?.eventCount)
                    intersections.push({ ...intersect, eventObject });
                eventObject = eventObject.parent;
            }
        }
        return intersections;
    }
    /**  Creates filtered intersects and returns an array of positive hits */
    function patchIntersects(intersections, event) {
        const { internal } = eventsStateGetter();
        // If the interaction is captured, make all capturing targets  part of the
        // intersect.
        if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {
            for (let captureData of internal.capturedMap
                .get(event.pointerId)
                .values()) {
                intersections.push(captureData.intersection);
            }
        }
        return intersections;
    }
    function cancelPointer(hits) {
        const { internal } = eventsStateGetter();
        Array.from(internal.hovered.values()).forEach((hoveredObj) => {
            // When no objects were hit or the the hovered object wasn't found underneath the cursor
            // we call onPointerOut and delete the object from the hovered-elements map
            if (!hits.length ||
                !hits.find((hit) => hit.object === hoveredObj.object &&
                    hit.index === hoveredObj.index &&
                    hit.instanceId === hoveredObj.instanceId)) {
                const eventObject = hoveredObj.eventObject;
                const instance = eventObject.__ngt;
                const handlers = instance?.handlers;
                internal.hovered.delete(makeId(hoveredObj));
                if (instance?.eventCount) {
                    // Clear out intersects, they are outdated by now
                    const data = { ...hoveredObj, intersections: hits || [] };
                    handlers?.pointerout?.(data);
                    handlers?.pointerleave?.(data);
                }
            }
        });
    }
    /**  Handles intersections by forwarding them to handlers */
    function handleIntersects(intersections, event, delta, callback) {
        const { raycaster, mouse, camera } = stateGetter();
        const { internal } = eventsStateGetter();
        // If anything has been found, forward it to the event listeners
        if (intersections.length && camera) {
            const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);
            const localState = { stopped: false };
            for (const hit of intersections) {
                const hasPointerCapture = (id) => internal.capturedMap.get(id)?.has(hit.eventObject) ?? false;
                const setPointerCapture = (id) => {
                    const captureData = {
                        intersection: hit,
                        target: event.target,
                    };
                    if (internal.capturedMap.has(id)) {
                        // if the pointerId was previously captured, we add the hit to the
                        // event capturedMap.
                        internal.capturedMap.get(id).set(hit.eventObject, captureData);
                    }
                    else {
                        // if the pointerId was not previously captured, we create a map
                        // containing the hitObject, and the hit. hitObject is used for
                        // faster access.
                        internal.capturedMap.set(id, new Map([[hit.eventObject, captureData]]));
                    }
                    // Call the original event now
                    event.target.setPointerCapture(id);
                };
                const releasePointerCapture = (id) => {
                    const captures = internal.capturedMap.get(id);
                    if (captures) {
                        releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);
                    }
                };
                // Add native event props
                let extractEventProps = {};
                // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return "own" properties; nor Object.getPrototypeOf(event) as that *doesn't* return "own" properties, only inherited ones.
                for (let prop in event) {
                    let property = event[prop];
                    // Only copy over atomics, leave functions alone as these should be
                    // called as event.nativeEvent.fn()
                    if (typeof property !== 'function')
                        extractEventProps[prop] = property;
                }
                let raycastEvent = {
                    ...hit,
                    ...extractEventProps,
                    spaceX: mouse.x,
                    spaceY: mouse.y,
                    intersections,
                    stopped: localState.stopped,
                    delta,
                    unprojectedPoint,
                    ray: raycaster?.ray,
                    camera: camera,
                    // Hijack stopPropagation, which just sets a flag
                    stopPropagation: () => {
                        // https://github.com/pmndrs/react-three-fiber/issues/596
                        // Events are not allowed to stop propagation if the pointer has been captured
                        const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId);
                        // We only authorize stopPropagation...
                        if (
                        // ...if this pointer hasn't been captured
                        !capturesForPointer ||
                            // ... or if the hit object is capturing the pointer
                            capturesForPointer.has(hit.eventObject)) {
                            raycastEvent.stopped = localState.stopped = true;
                            // Propagation is stopped, remove all other hover records
                            // An event handler is only allowed to flush other handlers if it is hovered itself
                            if (internal.hovered.size &&
                                Array.from(internal.hovered.values()).find((i) => i.eventObject === hit.eventObject)) {
                                // Objects cannot flush out higher up objects that have already caught the event
                                const higher = intersections.slice(0, intersections.indexOf(hit));
                                cancelPointer([...higher, hit]);
                            }
                        }
                    },
                    // there should be a distinction between target and currentTarget
                    target: {
                        hasPointerCapture,
                        setPointerCapture,
                        releasePointerCapture,
                    },
                    currentTarget: {
                        hasPointerCapture,
                        setPointerCapture,
                        releasePointerCapture,
                    },
                    sourceEvent: event,
                    nativeEvent: event,
                };
                // Call subscribers
                callback(raycastEvent);
                // Event bubbling may be interrupted by stopPropagation
                if (localState.stopped)
                    break;
            }
        }
        return intersections;
    }
    const handlePointer = (name) => {
        // Deal with cancelation
        switch (name) {
            case 'pointerleave':
            case 'pointercancel':
                return () => cancelPointer([]);
            case 'lostpointercapture':
                return (event) => {
                    const { internal: { capturedMap }, } = eventsStateGetter();
                    if ('pointerId' in event && !capturedMap.has(event.pointerId)) {
                        // If the object event interface had onLostPointerCapture, we'd call it here on every
                        // object that's getting removed.
                        capturedMap.delete(event.pointerId);
                        cancelPointer([]);
                    }
                };
        }
        // Any other pointer goes here ...
        return (event) => {
            const { pointerMissed, internal } = eventsStateGetter();
            prepareRay(event);
            // Get fresh intersects
            const isPointerMove = name === 'pointermove';
            const isClickEvent = name === 'click' || name === 'contextmenu' || name === 'dblclick';
            const filter = isPointerMove ? filterPointerEvents : undefined;
            const hits = patchIntersects(intersect(filter), event);
            const delta = isClickEvent ? calculateDistance(event) : 0;
            // Save initial coordinates on pointer-down
            if (name === 'pointerdown') {
                internal.initialClick = [event.offsetX, event.offsetY];
                internal.initialHits = hits.map((hit) => hit.eventObject);
            }
            // If a click yields no results, pass it back to the user as a miss
            // Missed events have to come first in order to establish user-land side-effect clean up
            if (isClickEvent && !hits.length) {
                if (delta <= 2) {
                    objectPointerMissed(event, internal.interaction);
                    if (pointerMissed)
                        pointerMissed(event);
                }
            }
            // Take care of unhover
            if (isPointerMove)
                cancelPointer(hits);
            handleIntersects(hits, event, delta, (data) => {
                const eventObject = data.eventObject;
                const instance = eventObject.__ngt;
                const handlers = instance?.handlers;
                // Check presence of handlers
                if (!instance?.eventCount)
                    return;
                if (isPointerMove) {
                    // Move event ...
                    if (handlers?.pointerover ||
                        handlers?.pointerenter ||
                        handlers?.pointerout ||
                        handlers?.pointerleave) {
                        // When enter or out is present take care of hover-state
                        const id = makeId(data);
                        const hoveredItem = internal.hovered.get(id);
                        if (!hoveredItem) {
                            // If the object wasn't previously hovered, book it and call its handler
                            internal.hovered.set(id, data);
                            handlers.pointerover?.(data);
                            handlers.pointerenter?.(data);
                        }
                        else if (hoveredItem.stopped) {
                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed
                            data.stopPropagation();
                        }
                    }
                    // Call mouse move
                    handlers?.pointermove?.(data);
                }
                else {
                    // All other events ...
                    const handler = handlers?.[name];
                    if (handler) {
                        // Forward all events back to their respective handlers with the exception of click events,
                        // which must use the initial target
                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {
                            // Missed events have to come first
                            objectPointerMissed(event, internal.interaction.filter((object) => !internal.initialHits.includes(object)));
                            // Now call the handler
                            handler(data);
                        }
                    }
                }
            });
        };
    };
    function objectPointerMissed(event, objects) {
        objects.forEach((object) => object.__ngt?.handlers?.pointermissed?.(event));
    }
    return { handlePointer };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvbGliL3V0aWxzL2V2ZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7R0FFRztBQUVILE9BQU8sS0FBSyxLQUFLLE1BQU0sT0FBTyxDQUFDO0FBYS9CLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFFbkM7O0dBRUc7QUFDSCxTQUFTLDZCQUE2QixDQUNwQyxXQUFzRSxFQUN0RSxHQUFtQixFQUNuQixRQUFzRCxFQUN0RCxTQUFpQjtJQUVqQixNQUFNLFdBQVcsR0FBd0MsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMzRSxJQUFJLFdBQVcsRUFBRTtRQUNmLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDckIseURBQXlEO1FBQ3pELElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7WUFDdkIsV0FBVyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUM5QixXQUFXLENBQUMsTUFBTSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQ3JEO0tBQ0Y7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLG1CQUFtQixDQUNqQyxpQkFBNEMsRUFDNUMsTUFBc0I7SUFFdEIsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLGlCQUFpQixFQUFFLENBQUM7SUFDekMsdURBQXVEO0lBQ3ZELFFBQVEsQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxNQUFNLENBQUMsQ0FBQztJQUN4RSxRQUFRLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUFDLENBQUM7SUFDeEUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDdEMsSUFBSSxLQUFLLENBQUMsV0FBVyxLQUFLLE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLE1BQU0sRUFBRTtZQUMzRCxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUM5QjtJQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0gsUUFBUSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLEVBQUU7UUFDbkQsNkJBQTZCLENBQzNCLFFBQVEsQ0FBQyxXQUFXLEVBQ3BCLE1BQU0sRUFDTixRQUFRLEVBQ1IsU0FBUyxDQUNWLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFlO0lBQ3JDLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsR0FBRyxLQUFLLENBQUM7SUFDeEUsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBRS9CLE9BQU87UUFDTCxJQUFJO1FBQ0osS0FBSztRQUNMLE1BQU0sRUFBRSxNQUFtQjtRQUMzQixLQUFLO1FBQ0wsS0FBSztRQUNMLFFBQVEsRUFBRSxRQUErQjtRQUN6QyxLQUFLLEVBQUUsS0FBb0I7UUFDM0IsUUFBUTtLQUNULENBQUM7QUFDSixDQUFDO0FBRUQsTUFBTSxVQUFVLFlBQVksQ0FDMUIsV0FBMkIsRUFDM0IsaUJBQTRDO0lBRTVDLE1BQU0sSUFBSSxHQUFHLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBRWpDLCtCQUErQjtJQUMvQixTQUFTLFVBQVUsQ0FBQyxLQUFrQjtRQUNwQyxNQUFNLEtBQUssR0FBRyxXQUFXLEVBQUUsQ0FBQztRQUM1QixNQUFNLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDO1FBQ2pELHVEQUF1RDtRQUN2RCw4Q0FBOEM7UUFDOUMsSUFBSSxTQUFTLElBQUksTUFBTSxFQUFFO1lBQ3ZCLE1BQU0sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLEdBQ3hCLFNBQVMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxLQUFLLEVBQUUsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDO1lBRXJFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDO1lBQy9CLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNsRSxTQUFTLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztTQUN4QztJQUNILENBQUM7SUFFRCx1QkFBdUI7SUFDdkIsU0FBUyxpQkFBaUIsQ0FBQyxLQUFrQjtRQUMzQyxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQztRQUN6QyxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEQsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVELHlHQUF5RztJQUN6RyxTQUFTLG1CQUFtQixDQUFDLE9BQXlCO1FBQ3BELE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQzVCLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FDNUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUNOLEdBQThCLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxDQUMvQyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQTJCLENBQzdDLENBQ0osQ0FDRixDQUFDO0lBQ0osQ0FBQztJQUVELFNBQVMsU0FBUyxDQUFDLE1BQXdEO1FBQ3pFLE1BQU0sV0FBVyxHQUFHLFdBQVcsRUFBRSxDQUFDO1FBQ2xDLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxpQkFBaUIsRUFBRSxDQUFDO1FBRXpDLE1BQU0sRUFBRSxTQUFTLEVBQUUsR0FBRyxXQUFXLENBQUM7UUFFbEMsMkNBQTJDO1FBQzNDLElBQUksQ0FBQyxTQUFTLEVBQUUsT0FBTztZQUFFLE9BQU8sRUFBRSxDQUFDO1FBRW5DLE1BQU0sSUFBSSxHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7UUFDL0IsTUFBTSxhQUFhLEdBQXNCLEVBQUUsQ0FBQztRQUU1QywyQ0FBMkM7UUFDM0MsTUFBTSxhQUFhLEdBQUcsTUFBTTtZQUMxQixDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUM7WUFDOUIsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUM7UUFFekIsZ0VBQWdFO1FBQ2hFLElBQUksVUFBVSxHQUFHLFNBQVM7YUFDdkIsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQzthQUNyQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUNmLE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxJQUF1QixDQUFDLENBQUM7WUFDM0MsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFBRSxPQUFPLEtBQUssQ0FBQztZQUMvQixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2IsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLENBQUMsQ0FBQztRQUVMLGtEQUFrRDtRQUNsRCw2Q0FBNkM7UUFDN0MsSUFBSSxTQUFTLENBQUMsTUFBTTtZQUNsQixVQUFVLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFFekUsS0FBSyxNQUFNLFNBQVMsSUFBSSxVQUFVLEVBQUU7WUFDbEMsSUFBSSxXQUFXLEdBQTBCLFNBQVMsQ0FBQyxNQUFNLENBQUM7WUFDMUQsa0JBQWtCO1lBQ2xCLE9BQU8sV0FBVyxFQUFFO2dCQUNsQixJQUFLLFdBQXNDLENBQUMsS0FBSyxFQUFFLFVBQVU7b0JBQzNELGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLFNBQVMsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDO2dCQUNwRCxXQUFXLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQzthQUNsQztTQUNGO1FBQ0QsT0FBTyxhQUFhLENBQUM7SUFDdkIsQ0FBQztJQUVELHlFQUF5RTtJQUN6RSxTQUFTLGVBQWUsQ0FDdEIsYUFBZ0MsRUFDaEMsS0FBa0I7UUFFbEIsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLGlCQUFpQixFQUFFLENBQUM7UUFDekMsMEVBQTBFO1FBQzFFLGFBQWE7UUFDYixJQUFJLFdBQVcsSUFBSSxLQUFLLElBQUksUUFBUSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ3JFLEtBQUssSUFBSSxXQUFXLElBQUksUUFBUSxDQUFDLFdBQVc7aUJBQ3pDLEdBQUcsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFFO2lCQUNyQixNQUFNLEVBQUUsRUFBRTtnQkFDWCxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUM5QztTQUNGO1FBQ0QsT0FBTyxhQUFhLENBQUM7SUFDdkIsQ0FBQztJQUVELFNBQVMsYUFBYSxDQUFDLElBQXVCO1FBQzVDLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3pDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQzNELHdGQUF3RjtZQUN4RiwyRUFBMkU7WUFDM0UsSUFDRSxDQUFDLElBQUksQ0FBQyxNQUFNO2dCQUNaLENBQUMsSUFBSSxDQUFDLElBQUksQ0FDUixDQUFDLEdBQUcsRUFBRSxFQUFFLENBQ04sR0FBRyxDQUFDLE1BQU0sS0FBSyxVQUFVLENBQUMsTUFBTTtvQkFDaEMsR0FBRyxDQUFDLEtBQUssS0FBSyxVQUFVLENBQUMsS0FBSztvQkFDOUIsR0FBRyxDQUFDLFVBQVUsS0FBSyxVQUFVLENBQUMsVUFBVSxDQUMzQyxFQUNEO2dCQUNBLE1BQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUM7Z0JBQzNDLE1BQU0sUUFBUSxHQUFJLFdBQXNDLENBQUMsS0FBSyxDQUFDO2dCQUMvRCxNQUFNLFFBQVEsR0FBRyxRQUFRLEVBQUUsUUFBUSxDQUFDO2dCQUNwQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztnQkFDNUMsSUFBSSxRQUFRLEVBQUUsVUFBVSxFQUFFO29CQUN4QixpREFBaUQ7b0JBQ2pELE1BQU0sSUFBSSxHQUFHLEVBQUUsR0FBRyxVQUFVLEVBQUUsYUFBYSxFQUFFLElBQUksSUFBSSxFQUFFLEVBQUUsQ0FBQztvQkFDMUQsUUFBUSxFQUFFLFVBQVUsRUFBRSxDQUFDLElBQThCLENBQUMsQ0FBQztvQkFDdkQsUUFBUSxFQUFFLFlBQVksRUFBRSxDQUFDLElBQThCLENBQUMsQ0FBQztpQkFDMUQ7YUFDRjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELDREQUE0RDtJQUM1RCxTQUFTLGdCQUFnQixDQUN2QixhQUFnQyxFQUNoQyxLQUFrQixFQUNsQixLQUFhLEVBQ2IsUUFBZ0Q7UUFFaEQsTUFBTSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsV0FBVyxFQUFFLENBQUM7UUFDbkQsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLGlCQUFpQixFQUFFLENBQUM7UUFDekMsZ0VBQWdFO1FBQ2hFLElBQUksYUFBYSxDQUFDLE1BQU0sSUFBSSxNQUFNLEVBQUU7WUFDbEMsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFekUsTUFBTSxVQUFVLEdBQUcsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUM7WUFFdEMsS0FBSyxNQUFNLEdBQUcsSUFBSSxhQUFhLEVBQUU7Z0JBQy9CLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxFQUFVLEVBQUUsRUFBRSxDQUN2QyxRQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssQ0FBQztnQkFFOUQsTUFBTSxpQkFBaUIsR0FBRyxDQUFDLEVBQVUsRUFBRSxFQUFFO29CQUN2QyxNQUFNLFdBQVcsR0FBRzt3QkFDbEIsWUFBWSxFQUFFLEdBQUc7d0JBQ2pCLE1BQU0sRUFBRSxLQUFLLENBQUMsTUFBaUI7cUJBQ2hDLENBQUM7b0JBQ0YsSUFBSSxRQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRTt3QkFDaEMsa0VBQWtFO3dCQUNsRSxxQkFBcUI7d0JBQ3JCLFFBQVEsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDO3FCQUNqRTt5QkFBTTt3QkFDTCxnRUFBZ0U7d0JBQ2hFLCtEQUErRDt3QkFDL0QsaUJBQWlCO3dCQUNqQixRQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FDdEIsRUFBRSxFQUNGLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FDMUMsQ0FBQztxQkFDSDtvQkFDRCw4QkFBOEI7b0JBQzdCLEtBQUssQ0FBQyxNQUFrQixDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUNsRCxDQUFDLENBQUM7Z0JBRUYsTUFBTSxxQkFBcUIsR0FBRyxDQUFDLEVBQVUsRUFBRSxFQUFFO29CQUMzQyxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDOUMsSUFBSSxRQUFRLEVBQUU7d0JBQ1osNkJBQTZCLENBQzNCLFFBQVEsQ0FBQyxXQUFXLEVBQ3BCLEdBQUcsQ0FBQyxXQUFXLEVBQ2YsUUFBUSxFQUNSLEVBQUUsQ0FDSCxDQUFDO3FCQUNIO2dCQUNILENBQUMsQ0FBQztnQkFFRix5QkFBeUI7Z0JBQ3pCLElBQUksaUJBQWlCLEdBQTRCLEVBQUUsQ0FBQztnQkFDcEQsdWFBQXVhO2dCQUN2YSxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssRUFBRTtvQkFDdEIsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDLElBQXlCLENBQUMsQ0FBQztvQkFDaEQsbUVBQW1FO29CQUNuRSxtQ0FBbUM7b0JBQ25DLElBQUksT0FBTyxRQUFRLEtBQUssVUFBVTt3QkFDaEMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDO2lCQUN0QztnQkFFRCxJQUFJLFlBQVksR0FBUTtvQkFDdEIsR0FBRyxHQUFHO29CQUNOLEdBQUcsaUJBQWlCO29CQUNwQixNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7b0JBQ2YsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUNmLGFBQWE7b0JBQ2IsT0FBTyxFQUFFLFVBQVUsQ0FBQyxPQUFPO29CQUMzQixLQUFLO29CQUNMLGdCQUFnQjtvQkFDaEIsR0FBRyxFQUFFLFNBQVMsRUFBRSxHQUFHO29CQUNuQixNQUFNLEVBQUUsTUFBTTtvQkFDZCxpREFBaUQ7b0JBQ2pELGVBQWUsRUFBRSxHQUFHLEVBQUU7d0JBQ3BCLHlEQUF5RDt3QkFDekQsOEVBQThFO3dCQUM5RSxNQUFNLGtCQUFrQixHQUN0QixXQUFXLElBQUksS0FBSyxJQUFJLFFBQVEsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQzt3QkFFcEUsdUNBQXVDO3dCQUN2Qzt3QkFDRSwwQ0FBMEM7d0JBQzFDLENBQUMsa0JBQWtCOzRCQUNuQixvREFBb0Q7NEJBQ3BELGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQ3ZDOzRCQUNBLFlBQVksQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7NEJBQ2pELHlEQUF5RDs0QkFDekQsbUZBQW1GOzRCQUNuRixJQUNFLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSTtnQ0FDckIsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsSUFBSSxDQUN4QyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsS0FBSyxHQUFHLENBQUMsV0FBVyxDQUN6QyxFQUNEO2dDQUNBLGdGQUFnRjtnQ0FDaEYsTUFBTSxNQUFNLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FDaEMsQ0FBQyxFQUNELGFBQWEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQzNCLENBQUM7Z0NBQ0YsYUFBYSxDQUFDLENBQUMsR0FBRyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQzs2QkFDakM7eUJBQ0Y7b0JBQ0gsQ0FBQztvQkFDRCxpRUFBaUU7b0JBQ2pFLE1BQU0sRUFBRTt3QkFDTixpQkFBaUI7d0JBQ2pCLGlCQUFpQjt3QkFDakIscUJBQXFCO3FCQUN0QjtvQkFDRCxhQUFhLEVBQUU7d0JBQ2IsaUJBQWlCO3dCQUNqQixpQkFBaUI7d0JBQ2pCLHFCQUFxQjtxQkFDdEI7b0JBQ0QsV0FBVyxFQUFFLEtBQUs7b0JBQ2xCLFdBQVcsRUFBRSxLQUFLO2lCQUNuQixDQUFDO2dCQUVGLG1CQUFtQjtnQkFDbkIsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUN2Qix1REFBdUQ7Z0JBQ3ZELElBQUksVUFBVSxDQUFDLE9BQU87b0JBQUUsTUFBTTthQUMvQjtTQUNGO1FBQ0QsT0FBTyxhQUFhLENBQUM7SUFDdkIsQ0FBQztJQUVELE1BQU0sYUFBYSxHQUFHLENBQUMsSUFBWSxFQUFFLEVBQUU7UUFDckMsd0JBQXdCO1FBQ3hCLFFBQVEsSUFBSSxFQUFFO1lBQ1osS0FBSyxjQUFjLENBQUM7WUFDcEIsS0FBSyxlQUFlO2dCQUNsQixPQUFPLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNqQyxLQUFLLG9CQUFvQjtnQkFDdkIsT0FBTyxDQUFDLEtBQWtCLEVBQUUsRUFBRTtvQkFDNUIsTUFBTSxFQUNKLFFBQVEsRUFBRSxFQUFFLFdBQVcsRUFBRSxHQUMxQixHQUFHLGlCQUFpQixFQUFFLENBQUM7b0JBQ3hCLElBQUksV0FBVyxJQUFJLEtBQUssSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxFQUFFO3dCQUM3RCxxRkFBcUY7d0JBQ3JGLGlDQUFpQzt3QkFDakMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7d0JBQ3BDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQztxQkFDbkI7Z0JBQ0gsQ0FBQyxDQUFDO1NBQ0w7UUFFRCxrQ0FBa0M7UUFDbEMsT0FBTyxDQUFDLEtBQWtCLEVBQUUsRUFBRTtZQUM1QixNQUFNLEVBQUUsYUFBYSxFQUFFLFFBQVEsRUFBRSxHQUFHLGlCQUFpQixFQUFFLENBQUM7WUFFeEQsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBRWxCLHVCQUF1QjtZQUN2QixNQUFNLGFBQWEsR0FBRyxJQUFJLEtBQUssYUFBYSxDQUFDO1lBQzdDLE1BQU0sWUFBWSxHQUNoQixJQUFJLEtBQUssT0FBTyxJQUFJLElBQUksS0FBSyxhQUFhLElBQUksSUFBSSxLQUFLLFVBQVUsQ0FBQztZQUNwRSxNQUFNLE1BQU0sR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7WUFDL0QsTUFBTSxJQUFJLEdBQUcsZUFBZSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUV2RCxNQUFNLEtBQUssR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUQsMkNBQTJDO1lBQzNDLElBQUksSUFBSSxLQUFLLGFBQWEsRUFBRTtnQkFDMUIsUUFBUSxDQUFDLFlBQVksR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUN2RCxRQUFRLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUMzRDtZQUVELG1FQUFtRTtZQUNuRSx3RkFBd0Y7WUFDeEYsSUFBSSxZQUFZLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNoQyxJQUFJLEtBQUssSUFBSSxDQUFDLEVBQUU7b0JBQ2QsbUJBQW1CLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQztvQkFDakQsSUFBSSxhQUFhO3dCQUFFLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDekM7YUFDRjtZQUNELHVCQUF1QjtZQUN2QixJQUFJLGFBQWE7Z0JBQUUsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRXZDLGdCQUFnQixDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsSUFBMkIsRUFBRSxFQUFFO2dCQUNuRSxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO2dCQUNyQyxNQUFNLFFBQVEsR0FBSSxXQUFzQyxDQUFDLEtBQUssQ0FBQztnQkFDL0QsTUFBTSxRQUFRLEdBQUcsUUFBUSxFQUFFLFFBQVEsQ0FBQztnQkFFcEMsNkJBQTZCO2dCQUM3QixJQUFJLENBQUMsUUFBUSxFQUFFLFVBQVU7b0JBQUUsT0FBTztnQkFFbEMsSUFBSSxhQUFhLEVBQUU7b0JBQ2pCLGlCQUFpQjtvQkFDakIsSUFDRSxRQUFRLEVBQUUsV0FBVzt3QkFDckIsUUFBUSxFQUFFLFlBQVk7d0JBQ3RCLFFBQVEsRUFBRSxVQUFVO3dCQUNwQixRQUFRLEVBQUUsWUFBWSxFQUN0Qjt3QkFDQSx3REFBd0Q7d0JBQ3hELE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDeEIsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7d0JBQzdDLElBQUksQ0FBQyxXQUFXLEVBQUU7NEJBQ2hCLHdFQUF3RTs0QkFDeEUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDOzRCQUMvQixRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBOEIsQ0FBQyxDQUFDOzRCQUN2RCxRQUFRLENBQUMsWUFBWSxFQUFFLENBQUMsSUFBOEIsQ0FBQyxDQUFDO3lCQUN6RDs2QkFBTSxJQUFJLFdBQVcsQ0FBQyxPQUFPLEVBQUU7NEJBQzlCLDhGQUE4Rjs0QkFDOUYsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO3lCQUN4QjtxQkFDRjtvQkFDRCxrQkFBa0I7b0JBQ2xCLFFBQVEsRUFBRSxXQUFXLEVBQUUsQ0FBQyxJQUE4QixDQUFDLENBQUM7aUJBQ3pEO3FCQUFNO29CQUNMLHVCQUF1QjtvQkFDdkIsTUFBTSxPQUFPLEdBQUcsUUFBUSxFQUFFLENBQUMsSUFBOEIsQ0FFaEQsQ0FBQztvQkFDVixJQUFJLE9BQU8sRUFBRTt3QkFDWCwyRkFBMkY7d0JBQzNGLG9DQUFvQzt3QkFDcEMsSUFBSSxDQUFDLFlBQVksSUFBSSxRQUFRLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsRUFBRTs0QkFDL0QsbUNBQW1DOzRCQUNuQyxtQkFBbUIsQ0FDakIsS0FBSyxFQUNMLFFBQVEsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUN6QixDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FDbkQsQ0FDRixDQUFDOzRCQUNGLHVCQUF1Qjs0QkFDdkIsT0FBTyxDQUFDLElBQThCLENBQUMsQ0FBQzt5QkFDekM7cUJBQ0Y7aUJBQ0Y7WUFDSCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQztJQUVGLFNBQVMsbUJBQW1CLENBQUMsS0FBaUIsRUFBRSxPQUF5QjtRQUN2RSxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBc0IsRUFBRSxFQUFFLENBQ3hDLE1BQWlDLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FDM0UsQ0FBQztJQUNKLENBQUM7SUFFRCxPQUFPLEVBQUUsYUFBYSxFQUFFLENBQUM7QUFDM0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRnJvbSByM2YgaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9ibG9iL21hc3Rlci9wYWNrYWdlcy9maWJlci9zcmMvY29yZS9ldmVudHMudHNcbiAqL1xuXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgdHlwZSB7XG4gIE5ndENhbWVyYSxcbiAgTmd0RG9tRXZlbnQsXG4gIE5ndEV2ZW50LFxuICBOZ3RFdmVudEhhbmRsZXJzLFxuICBOZ3RFdmVudHNTdG9yZVN0YXRlLFxuICBOZ3RJbnN0YW5jZSxcbiAgTmd0SW50ZXJzZWN0aW9uLFxuICBOZ3RQb2ludGVyQ2FwdHVyZVRhcmdldCxcbiAgTmd0UmVuZGVyLFxuICBOZ3RTdGF0ZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgbWFrZUlkIH0gZnJvbSAnLi9tYWtlLWlkJztcblxuLyoqIFJlbGVhc2UgcG9pbnRlciBjYXB0dXJlcy5cbiAqIFRoaXMgaXMgY2FsbGVkIGJ5IHJlbGVhc2VQb2ludGVyQ2FwdHVyZSBpbiB0aGUgQVBJLCBhbmQgd2hlbiBhbiBvYmplY3QgaXMgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoXG4gIGNhcHR1cmVkTWFwOiBNYXA8bnVtYmVyLCBNYXA8VEhSRUUuT2JqZWN0M0QsIE5ndFBvaW50ZXJDYXB0dXJlVGFyZ2V0Pj4sXG4gIG9iajogVEhSRUUuT2JqZWN0M0QsXG4gIGNhcHR1cmVzOiBNYXA8VEhSRUUuT2JqZWN0M0QsIE5ndFBvaW50ZXJDYXB0dXJlVGFyZ2V0PixcbiAgcG9pbnRlcklkOiBudW1iZXJcbik6IHZvaWQge1xuICBjb25zdCBjYXB0dXJlRGF0YTogTmd0UG9pbnRlckNhcHR1cmVUYXJnZXQgfCB1bmRlZmluZWQgPSBjYXB0dXJlcy5nZXQob2JqKTtcbiAgaWYgKGNhcHR1cmVEYXRhKSB7XG4gICAgY2FwdHVyZXMuZGVsZXRlKG9iaik7XG4gICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3QgY2FwdHVyaW5nIG9iamVjdCBmb3IgdGhpcyBwb2ludGVyXG4gICAgaWYgKGNhcHR1cmVzLnNpemUgPT09IDApIHtcbiAgICAgIGNhcHR1cmVkTWFwLmRlbGV0ZShwb2ludGVySWQpO1xuICAgICAgY2FwdHVyZURhdGEudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlSW50ZXJhY3Rpdml0eShcbiAgZXZlbnRzU3RhdGVHZXR0ZXI6ICgpID0+IE5ndEV2ZW50c1N0b3JlU3RhdGUsXG4gIG9iamVjdDogVEhSRUUuT2JqZWN0M0Rcbikge1xuICBjb25zdCB7IGludGVybmFsIH0gPSBldmVudHNTdGF0ZUdldHRlcigpO1xuICAvLyBSZW1vdmVzIGV2ZXJ5IHRyYWNlIG9mIGFuIG9iamVjdCBmcm9tIHRoZSBkYXRhIHN0b3JlXG4gIGludGVybmFsLmludGVyYWN0aW9uID0gaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKChvKSA9PiBvICE9PSBvYmplY3QpO1xuICBpbnRlcm5hbC5pbml0aWFsSGl0cyA9IGludGVybmFsLmluaXRpYWxIaXRzLmZpbHRlcigobykgPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaG92ZXJlZC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKHZhbHVlLmV2ZW50T2JqZWN0ID09PSBvYmplY3QgfHwgdmFsdWUub2JqZWN0ID09PSBvYmplY3QpIHtcbiAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9KTtcbiAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZm9yRWFjaCgoY2FwdHVyZXMsIHBvaW50ZXJJZCkgPT4ge1xuICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKFxuICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAsXG4gICAgICBvYmplY3QsXG4gICAgICBjYXB0dXJlcyxcbiAgICAgIHBvaW50ZXJJZFxuICAgICk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRSZW5kZXJTdGF0ZShzdGF0ZTogTmd0U3RhdGUpOiBOZ3RSZW5kZXIge1xuICBjb25zdCB7IG1vdXNlLCBjYW1lcmEsIGNsb2NrLCByZW5kZXJlciwgc2NlbmUsIHNpemUsIHZpZXdwb3J0IH0gPSBzdGF0ZTtcbiAgY29uc3QgZGVsdGEgPSBjbG9jay5nZXREZWx0YSgpO1xuXG4gIHJldHVybiB7XG4gICAgc2l6ZSxcbiAgICBtb3VzZSxcbiAgICBjYW1lcmE6IGNhbWVyYSBhcyBOZ3RDYW1lcmEsXG4gICAgZGVsdGEsXG4gICAgY2xvY2ssXG4gICAgcmVuZGVyZXI6IHJlbmRlcmVyIGFzIFRIUkVFLldlYkdMUmVuZGVyZXIsXG4gICAgc2NlbmU6IHNjZW5lIGFzIFRIUkVFLlNjZW5lLFxuICAgIHZpZXdwb3J0LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnRzKFxuICBzdGF0ZUdldHRlcjogKCkgPT4gTmd0U3RhdGUsXG4gIGV2ZW50c1N0YXRlR2V0dGVyOiAoKSA9PiBOZ3RFdmVudHNTdG9yZVN0YXRlXG4pIHtcbiAgY29uc3QgdGVtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgLyoqIFNldHMgdXAgZGVmYXVsdFJheWNhc3RlciAqL1xuICBmdW5jdGlvbiBwcmVwYXJlUmF5KGV2ZW50OiBOZ3REb21FdmVudCkge1xuICAgIGNvbnN0IHN0YXRlID0gc3RhdGVHZXR0ZXIoKTtcbiAgICBjb25zdCB7IHJheWNhc3RlciwgbW91c2UsIGNhbWVyYSwgc2l6ZSB9ID0gc3RhdGU7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzc4MlxuICAgIC8vIEV2ZW50cyB0cmlnZ2VyIG91dHNpZGUgb2YgY2FudmFzIHdoZW4gbW92ZWRcbiAgICBpZiAocmF5Y2FzdGVyICYmIGNhbWVyYSkge1xuICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPVxuICAgICAgICByYXljYXN0ZXI/LmNvbXB1dGVPZmZzZXRzPy4oZXZlbnQsIGdldFJlbmRlclN0YXRlKHN0YXRlKSkgPz8gZXZlbnQ7XG5cbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc2l6ZTtcbiAgICAgIG1vdXNlLnNldCgob2Zmc2V0WCAvIHdpZHRoKSAqIDIgLSAxLCAtKG9mZnNldFkgLyBoZWlnaHQpICogMiArIDEpO1xuICAgICAgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEobW91c2UsIGNhbWVyYSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIENhbGN1bGF0ZXMgZGVsdGEgKi9cbiAgZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQ6IE5ndERvbUV2ZW50KSB7XG4gICAgY29uc3QgeyBpbnRlcm5hbCB9ID0gZXZlbnRzU3RhdGVHZXR0ZXIoKTtcbiAgICBjb25zdCBkeCA9IGV2ZW50Lm9mZnNldFggLSBpbnRlcm5hbC5pbml0aWFsQ2xpY2tbMF07XG4gICAgY29uc3QgZHkgPSBldmVudC5vZmZzZXRZIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzFdO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbnN0YW5jZSBoYXMgYSB2YWxpZCBwb2ludGVyLWV2ZW50IHJlZ2lzdGVyZWQsIHRoaXMgZXhjbHVkZXMgc2Nyb2xsLCBjbGlja3MgZXRjICovXG4gIGZ1bmN0aW9uIGZpbHRlclBvaW50ZXJFdmVudHMob2JqZWN0czogVEhSRUUuT2JqZWN0M0RbXSkge1xuICAgIHJldHVybiBvYmplY3RzLmZpbHRlcigob2JqKSA9PlxuICAgICAgWydtb3ZlJywgJ292ZXInLCAnZW50ZXInLCAnb3V0JywgJ2xlYXZlJ10uc29tZShcbiAgICAgICAgKG5hbWUpID0+XG4gICAgICAgICAgKG9iaiBhcyB1bmtub3duIGFzIE5ndEluc3RhbmNlKS5fX25ndD8uaGFuZGxlcnM/LltcbiAgICAgICAgICAgICgncG9pbnRlcicgKyBuYW1lKSBhcyBrZXlvZiBOZ3RFdmVudEhhbmRsZXJzXG4gICAgICAgICAgXVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnNlY3QoZmlsdGVyPzogKG9iamVjdHM6IFRIUkVFLk9iamVjdDNEW10pID0+IFRIUkVFLk9iamVjdDNEW10pIHtcbiAgICBjb25zdCBjYW52YXNTdGF0ZSA9IHN0YXRlR2V0dGVyKCk7XG4gICAgY29uc3QgeyBpbnRlcm5hbCB9ID0gZXZlbnRzU3RhdGVHZXR0ZXIoKTtcblxuICAgIGNvbnN0IHsgcmF5Y2FzdGVyIH0gPSBjYW52YXNTdGF0ZTtcblxuICAgIC8vIFNraXAgZXZlbnQgaGFuZGxpbmcgd2hlbiBub0V2ZW50cyBpcyBzZXRcbiAgICBpZiAoIXJheWNhc3Rlcj8uZW5hYmxlZCkgcmV0dXJuIFtdO1xuXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbnM6IE5ndEludGVyc2VjdGlvbltdID0gW107XG5cbiAgICAvLyBBbGxvdyBjYWxsZXJzIHRvIGVsaW1pbmF0ZSBldmVudCBvYmplY3RzXG4gICAgY29uc3QgZXZlbnRzT2JqZWN0cyA9IGZpbHRlclxuICAgICAgPyBmaWx0ZXIoaW50ZXJuYWwuaW50ZXJhY3Rpb24pXG4gICAgICA6IGludGVybmFsLmludGVyYWN0aW9uO1xuXG4gICAgLy8gSW50ZXJzZWN0IGtub3duIGhhbmRsZXIgb2JqZWN0cyBhbmQgZmlsdGVyIGFnYWluc3QgZHVwbGljYXRlc1xuICAgIGxldCBpbnRlcnNlY3RzID0gcmF5Y2FzdGVyXG4gICAgICAuaW50ZXJzZWN0T2JqZWN0cyhldmVudHNPYmplY3RzLCB0cnVlKVxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IG1ha2VJZChpdGVtIGFzIE5ndEludGVyc2VjdGlvbik7XG4gICAgICAgIGlmIChzZWVuLmhhcyhpZCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc2Vlbi5hZGQoaWQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTYwMzFcbiAgICAvLyBBbGxvdyBjdXN0b20gdXNlcmxhbmQgaW50ZXJzZWN0IHNvcnQgb3JkZXJcbiAgICBpZiAocmF5Y2FzdGVyLmZpbHRlcilcbiAgICAgIGludGVyc2VjdHMgPSByYXljYXN0ZXIuZmlsdGVyKGludGVyc2VjdHMsIGdldFJlbmRlclN0YXRlKGNhbnZhc1N0YXRlKSk7XG5cbiAgICBmb3IgKGNvbnN0IGludGVyc2VjdCBvZiBpbnRlcnNlY3RzKSB7XG4gICAgICBsZXQgZXZlbnRPYmplY3Q6IFRIUkVFLk9iamVjdDNEIHwgbnVsbCA9IGludGVyc2VjdC5vYmplY3Q7XG4gICAgICAvLyBCdWJibGUgZXZlbnQgdXBcbiAgICAgIHdoaWxlIChldmVudE9iamVjdCkge1xuICAgICAgICBpZiAoKGV2ZW50T2JqZWN0IGFzIHVua25vd24gYXMgTmd0SW5zdGFuY2UpLl9fbmd0Py5ldmVudENvdW50KVxuICAgICAgICAgIGludGVyc2VjdGlvbnMucHVzaCh7IC4uLmludGVyc2VjdCwgZXZlbnRPYmplY3QgfSk7XG4gICAgICAgIGV2ZW50T2JqZWN0ID0gZXZlbnRPYmplY3QucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuXG4gIC8qKiAgQ3JlYXRlcyBmaWx0ZXJlZCBpbnRlcnNlY3RzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHBvc2l0aXZlIGhpdHMgKi9cbiAgZnVuY3Rpb24gcGF0Y2hJbnRlcnNlY3RzKFxuICAgIGludGVyc2VjdGlvbnM6IE5ndEludGVyc2VjdGlvbltdLFxuICAgIGV2ZW50OiBOZ3REb21FdmVudFxuICApIHtcbiAgICBjb25zdCB7IGludGVybmFsIH0gPSBldmVudHNTdGF0ZUdldHRlcigpO1xuICAgIC8vIElmIHRoZSBpbnRlcmFjdGlvbiBpcyBjYXB0dXJlZCwgbWFrZSBhbGwgY2FwdHVyaW5nIHRhcmdldHMgIHBhcnQgb2YgdGhlXG4gICAgLy8gaW50ZXJzZWN0LlxuICAgIGlmICgncG9pbnRlcklkJyBpbiBldmVudCAmJiBpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgZm9yIChsZXQgY2FwdHVyZURhdGEgb2YgaW50ZXJuYWwuY2FwdHVyZWRNYXBcbiAgICAgICAgLmdldChldmVudC5wb2ludGVySWQpIVxuICAgICAgICAudmFsdWVzKCkpIHtcbiAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsUG9pbnRlcihoaXRzOiBOZ3RJbnRlcnNlY3Rpb25bXSkge1xuICAgIGNvbnN0IHsgaW50ZXJuYWwgfSA9IGV2ZW50c1N0YXRlR2V0dGVyKCk7XG4gICAgQXJyYXkuZnJvbShpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKS5mb3JFYWNoKChob3ZlcmVkT2JqKSA9PiB7XG4gICAgICAvLyBXaGVuIG5vIG9iamVjdHMgd2VyZSBoaXQgb3IgdGhlIHRoZSBob3ZlcmVkIG9iamVjdCB3YXNuJ3QgZm91bmQgdW5kZXJuZWF0aCB0aGUgY3Vyc29yXG4gICAgICAvLyB3ZSBjYWxsIG9uUG9pbnRlck91dCBhbmQgZGVsZXRlIHRoZSBvYmplY3QgZnJvbSB0aGUgaG92ZXJlZC1lbGVtZW50cyBtYXBcbiAgICAgIGlmIChcbiAgICAgICAgIWhpdHMubGVuZ3RoIHx8XG4gICAgICAgICFoaXRzLmZpbmQoXG4gICAgICAgICAgKGhpdCkgPT5cbiAgICAgICAgICAgIGhpdC5vYmplY3QgPT09IGhvdmVyZWRPYmoub2JqZWN0ICYmXG4gICAgICAgICAgICBoaXQuaW5kZXggPT09IGhvdmVyZWRPYmouaW5kZXggJiZcbiAgICAgICAgICAgIGhpdC5pbnN0YW5jZUlkID09PSBob3ZlcmVkT2JqLmluc3RhbmNlSWRcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gaG92ZXJlZE9iai5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAoZXZlbnRPYmplY3QgYXMgdW5rbm93biBhcyBOZ3RJbnN0YW5jZSkuX19uZ3Q7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gaW5zdGFuY2U/LmhhbmRsZXJzO1xuICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLmRlbGV0ZShtYWtlSWQoaG92ZXJlZE9iaikpO1xuICAgICAgICBpZiAoaW5zdGFuY2U/LmV2ZW50Q291bnQpIHtcbiAgICAgICAgICAvLyBDbGVhciBvdXQgaW50ZXJzZWN0cywgdGhleSBhcmUgb3V0ZGF0ZWQgYnkgbm93XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHsgLi4uaG92ZXJlZE9iaiwgaW50ZXJzZWN0aW9uczogaGl0cyB8fCBbXSB9O1xuICAgICAgICAgIGhhbmRsZXJzPy5wb2ludGVyb3V0Py4oZGF0YSBhcyBOZ3RFdmVudDxQb2ludGVyRXZlbnQ+KTtcbiAgICAgICAgICBoYW5kbGVycz8ucG9pbnRlcmxlYXZlPy4oZGF0YSBhcyBOZ3RFdmVudDxQb2ludGVyRXZlbnQ+KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqICBIYW5kbGVzIGludGVyc2VjdGlvbnMgYnkgZm9yd2FyZGluZyB0aGVtIHRvIGhhbmRsZXJzICovXG4gIGZ1bmN0aW9uIGhhbmRsZUludGVyc2VjdHMoXG4gICAgaW50ZXJzZWN0aW9uczogTmd0SW50ZXJzZWN0aW9uW10sXG4gICAgZXZlbnQ6IE5ndERvbUV2ZW50LFxuICAgIGRlbHRhOiBudW1iZXIsXG4gICAgY2FsbGJhY2s6IChldmVudDogTmd0RXZlbnQ8Tmd0RG9tRXZlbnQ+KSA9PiB2b2lkXG4gICkge1xuICAgIGNvbnN0IHsgcmF5Y2FzdGVyLCBtb3VzZSwgY2FtZXJhIH0gPSBzdGF0ZUdldHRlcigpO1xuICAgIGNvbnN0IHsgaW50ZXJuYWwgfSA9IGV2ZW50c1N0YXRlR2V0dGVyKCk7XG4gICAgLy8gSWYgYW55dGhpbmcgaGFzIGJlZW4gZm91bmQsIGZvcndhcmQgaXQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCAmJiBjYW1lcmEpIHtcbiAgICAgIGNvbnN0IHVucHJvamVjdGVkUG9pbnQgPSB0ZW1wLnNldChtb3VzZS54LCBtb3VzZS55LCAwKS51bnByb2plY3QoY2FtZXJhKTtcblxuICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHsgc3RvcHBlZDogZmFsc2UgfTtcblxuICAgICAgZm9yIChjb25zdCBoaXQgb2YgaW50ZXJzZWN0aW9ucykge1xuICAgICAgICBjb25zdCBoYXNQb2ludGVyQ2FwdHVyZSA9IChpZDogbnVtYmVyKSA9PlxuICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCk/LmhhcyhoaXQuZXZlbnRPYmplY3QpID8/IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHNldFBvaW50ZXJDYXB0dXJlID0gKGlkOiBudW1iZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlRGF0YSA9IHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbjogaGl0LFxuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQgYXMgRWxlbWVudCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBhZGQgdGhlIGhpdCB0byB0aGVcbiAgICAgICAgICAgIC8vIGV2ZW50IGNhcHR1cmVkTWFwLlxuICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKSEuc2V0KGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBub3QgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgY3JlYXRlIGEgbWFwXG4gICAgICAgICAgICAvLyBjb250YWluaW5nIHRoZSBoaXRPYmplY3QsIGFuZCB0aGUgaGl0LiBoaXRPYmplY3QgaXMgdXNlZCBmb3JcbiAgICAgICAgICAgIC8vIGZhc3RlciBhY2Nlc3MuXG4gICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5zZXQoXG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBuZXcgTWFwKFtbaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlRGF0YV1dKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ2FsbCB0aGUgb3JpZ2luYWwgZXZlbnQgbm93XG4gICAgICAgICAgKGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KS5zZXRQb2ludGVyQ2FwdHVyZShpZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVsZWFzZVBvaW50ZXJDYXB0dXJlID0gKGlkOiBudW1iZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlcyA9IGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCk7XG4gICAgICAgICAgaWYgKGNhcHR1cmVzKSB7XG4gICAgICAgICAgICByZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZShcbiAgICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAsXG4gICAgICAgICAgICAgIGhpdC5ldmVudE9iamVjdCxcbiAgICAgICAgICAgICAgY2FwdHVyZXMsXG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBZGQgbmF0aXZlIGV2ZW50IHByb3BzXG4gICAgICAgIGxldCBleHRyYWN0RXZlbnRQcm9wczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcbiAgICAgICAgLy8gVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBldmVudCdzIHByb3BlcnRpZXMgaW5jbHVkaW5nIHRoZSBpbmhlcml0ZWQgb25lcy4gTmF0aXZlIFBvaW50ZXJFdmVudHMgaGF2ZSBtb3N0IG9mIHRoZWlyIHByb3BzIGFzIGdldHRlcnMgd2hpY2ggYXJlIGluaGVyaXRlZCwgYnV0IHBvbHlmaWxsZWQgUG9pbnRlckV2ZW50cyBoYXZlIHRoZW0gYWxsIGFzIHRoZWlyIG93biBwcm9wZXJ0aWVzIChpLmUuIG5vdCBpbmhlcml0ZWQpLiBXZSBjYW4ndCB1c2UgT2JqZWN0LmtleXMoKSBvciBPYmplY3QuZW50cmllcygpIGFzIHRoZXkgb25seSByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzOyBub3IgT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSBhcyB0aGF0ICpkb2Vzbid0KiByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzLCBvbmx5IGluaGVyaXRlZCBvbmVzLlxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGV2ZW50KSB7XG4gICAgICAgICAgbGV0IHByb3BlcnR5ID0gZXZlbnRbcHJvcCBhcyBrZXlvZiBOZ3REb21FdmVudF07XG4gICAgICAgICAgLy8gT25seSBjb3B5IG92ZXIgYXRvbWljcywgbGVhdmUgZnVuY3Rpb25zIGFsb25lIGFzIHRoZXNlIHNob3VsZCBiZVxuICAgICAgICAgIC8vIGNhbGxlZCBhcyBldmVudC5uYXRpdmVFdmVudC5mbigpXG4gICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGV4dHJhY3RFdmVudFByb3BzW3Byb3BdID0gcHJvcGVydHk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmF5Y2FzdEV2ZW50OiBhbnkgPSB7XG4gICAgICAgICAgLi4uaGl0LFxuICAgICAgICAgIC4uLmV4dHJhY3RFdmVudFByb3BzLFxuICAgICAgICAgIHNwYWNlWDogbW91c2UueCxcbiAgICAgICAgICBzcGFjZVk6IG1vdXNlLnksXG4gICAgICAgICAgaW50ZXJzZWN0aW9ucyxcbiAgICAgICAgICBzdG9wcGVkOiBsb2NhbFN0YXRlLnN0b3BwZWQsXG4gICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgdW5wcm9qZWN0ZWRQb2ludCxcbiAgICAgICAgICByYXk6IHJheWNhc3Rlcj8ucmF5LFxuICAgICAgICAgIGNhbWVyYTogY2FtZXJhLFxuICAgICAgICAgIC8vIEhpamFjayBzdG9wUHJvcGFnYXRpb24sIHdoaWNoIGp1c3Qgc2V0cyBhIGZsYWdcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzU5NlxuICAgICAgICAgICAgLy8gRXZlbnRzIGFyZSBub3QgYWxsb3dlZCB0byBzdG9wIHByb3BhZ2F0aW9uIGlmIHRoZSBwb2ludGVyIGhhcyBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlc0ZvclBvaW50ZXIgPVxuICAgICAgICAgICAgICAncG9pbnRlcklkJyBpbiBldmVudCAmJiBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoZXZlbnQucG9pbnRlcklkKTtcblxuICAgICAgICAgICAgLy8gV2Ugb25seSBhdXRob3JpemUgc3RvcFByb3BhZ2F0aW9uLi4uXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIC8vIC4uLmlmIHRoaXMgcG9pbnRlciBoYXNuJ3QgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgICAhY2FwdHVyZXNGb3JQb2ludGVyIHx8XG4gICAgICAgICAgICAgIC8vIC4uLiBvciBpZiB0aGUgaGl0IG9iamVjdCBpcyBjYXB0dXJpbmcgdGhlIHBvaW50ZXJcbiAgICAgICAgICAgICAgY2FwdHVyZXNGb3JQb2ludGVyLmhhcyhoaXQuZXZlbnRPYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmF5Y2FzdEV2ZW50LnN0b3BwZWQgPSBsb2NhbFN0YXRlLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBQcm9wYWdhdGlvbiBpcyBzdG9wcGVkLCByZW1vdmUgYWxsIG90aGVyIGhvdmVyIHJlY29yZHNcbiAgICAgICAgICAgICAgLy8gQW4gZXZlbnQgaGFuZGxlciBpcyBvbmx5IGFsbG93ZWQgdG8gZmx1c2ggb3RoZXIgaGFuZGxlcnMgaWYgaXQgaXMgaG92ZXJlZCBpdHNlbGZcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGludGVybmFsLmhvdmVyZWQuc2l6ZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmZyb20oaW50ZXJuYWwuaG92ZXJlZC52YWx1ZXMoKSkuZmluZChcbiAgICAgICAgICAgICAgICAgIChpKSA9PiBpLmV2ZW50T2JqZWN0ID09PSBoaXQuZXZlbnRPYmplY3RcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIE9iamVjdHMgY2Fubm90IGZsdXNoIG91dCBoaWdoZXIgdXAgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBjYXVnaHQgdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgY29uc3QgaGlnaGVyID0gaW50ZXJzZWN0aW9ucy5zbGljZShcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25zLmluZGV4T2YoaGl0KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbLi4uaGlnaGVyLCBoaXRdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gdGhlcmUgc2hvdWxkIGJlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB0YXJnZXQgYW5kIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgIGhhc1BvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB7XG4gICAgICAgICAgICBoYXNQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHNldFBvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50LCAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbGwgc3Vic2NyaWJlcnNcbiAgICAgICAgY2FsbGJhY2socmF5Y2FzdEV2ZW50KTtcbiAgICAgICAgLy8gRXZlbnQgYnViYmxpbmcgbWF5IGJlIGludGVycnVwdGVkIGJ5IHN0b3BQcm9wYWdhdGlvblxuICAgICAgICBpZiAobG9jYWxTdGF0ZS5zdG9wcGVkKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICBjb25zdCBoYW5kbGVQb2ludGVyID0gKG5hbWU6IHN0cmluZykgPT4ge1xuICAgIC8vIERlYWwgd2l0aCBjYW5jZWxhdGlvblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAncG9pbnRlcmxlYXZlJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICBjYXNlICdsb3N0cG9pbnRlcmNhcHR1cmUnOlxuICAgICAgICByZXR1cm4gKGV2ZW50OiBOZ3REb21FdmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGludGVybmFsOiB7IGNhcHR1cmVkTWFwIH0sXG4gICAgICAgICAgfSA9IGV2ZW50c1N0YXRlR2V0dGVyKCk7XG4gICAgICAgICAgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50ICYmICFjYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBldmVudCBpbnRlcmZhY2UgaGFkIG9uTG9zdFBvaW50ZXJDYXB0dXJlLCB3ZSdkIGNhbGwgaXQgaGVyZSBvbiBldmVyeVxuICAgICAgICAgICAgLy8gb2JqZWN0IHRoYXQncyBnZXR0aW5nIHJlbW92ZWQuXG4gICAgICAgICAgICBjYXB0dXJlZE1hcC5kZWxldGUoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGNhbmNlbFBvaW50ZXIoW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBbnkgb3RoZXIgcG9pbnRlciBnb2VzIGhlcmUgLi4uXG4gICAgcmV0dXJuIChldmVudDogTmd0RG9tRXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgcG9pbnRlck1pc3NlZCwgaW50ZXJuYWwgfSA9IGV2ZW50c1N0YXRlR2V0dGVyKCk7XG5cbiAgICAgIHByZXBhcmVSYXkoZXZlbnQpO1xuXG4gICAgICAvLyBHZXQgZnJlc2ggaW50ZXJzZWN0c1xuICAgICAgY29uc3QgaXNQb2ludGVyTW92ZSA9IG5hbWUgPT09ICdwb2ludGVybW92ZSc7XG4gICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPVxuICAgICAgICBuYW1lID09PSAnY2xpY2snIHx8IG5hbWUgPT09ICdjb250ZXh0bWVudScgfHwgbmFtZSA9PT0gJ2RibGNsaWNrJztcbiAgICAgIGNvbnN0IGZpbHRlciA9IGlzUG9pbnRlck1vdmUgPyBmaWx0ZXJQb2ludGVyRXZlbnRzIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaGl0cyA9IHBhdGNoSW50ZXJzZWN0cyhpbnRlcnNlY3QoZmlsdGVyKSwgZXZlbnQpO1xuXG4gICAgICBjb25zdCBkZWx0YSA9IGlzQ2xpY2tFdmVudCA/IGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSA6IDA7XG4gICAgICAvLyBTYXZlIGluaXRpYWwgY29vcmRpbmF0ZXMgb24gcG9pbnRlci1kb3duXG4gICAgICBpZiAobmFtZSA9PT0gJ3BvaW50ZXJkb3duJykge1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsQ2xpY2sgPSBbZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gICAgICAgIGludGVybmFsLmluaXRpYWxIaXRzID0gaGl0cy5tYXAoKGhpdCkgPT4gaGl0LmV2ZW50T2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSBjbGljayB5aWVsZHMgbm8gcmVzdWx0cywgcGFzcyBpdCBiYWNrIHRvIHRoZSB1c2VyIGFzIGEgbWlzc1xuICAgICAgLy8gTWlzc2VkIGV2ZW50cyBoYXZlIHRvIGNvbWUgZmlyc3QgaW4gb3JkZXIgdG8gZXN0YWJsaXNoIHVzZXItbGFuZCBzaWRlLWVmZmVjdCBjbGVhbiB1cFxuICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiAhaGl0cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRlbHRhIDw9IDIpIHtcbiAgICAgICAgICBvYmplY3RQb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbik7XG4gICAgICAgICAgaWYgKHBvaW50ZXJNaXNzZWQpIHBvaW50ZXJNaXNzZWQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUYWtlIGNhcmUgb2YgdW5ob3ZlclxuICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIGNhbmNlbFBvaW50ZXIoaGl0cyk7XG5cbiAgICAgIGhhbmRsZUludGVyc2VjdHMoaGl0cywgZXZlbnQsIGRlbHRhLCAoZGF0YTogTmd0RXZlbnQ8Tmd0RG9tRXZlbnQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gZGF0YS5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAoZXZlbnRPYmplY3QgYXMgdW5rbm93biBhcyBOZ3RJbnN0YW5jZSkuX19uZ3Q7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gaW5zdGFuY2U/LmhhbmRsZXJzO1xuXG4gICAgICAgIC8vIENoZWNrIHByZXNlbmNlIG9mIGhhbmRsZXJzXG4gICAgICAgIGlmICghaW5zdGFuY2U/LmV2ZW50Q291bnQpIHJldHVybjtcblxuICAgICAgICBpZiAoaXNQb2ludGVyTW92ZSkge1xuICAgICAgICAgIC8vIE1vdmUgZXZlbnQgLi4uXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaGFuZGxlcnM/LnBvaW50ZXJvdmVyIHx8XG4gICAgICAgICAgICBoYW5kbGVycz8ucG9pbnRlcmVudGVyIHx8XG4gICAgICAgICAgICBoYW5kbGVycz8ucG9pbnRlcm91dCB8fFxuICAgICAgICAgICAgaGFuZGxlcnM/LnBvaW50ZXJsZWF2ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gV2hlbiBlbnRlciBvciBvdXQgaXMgcHJlc2VudCB0YWtlIGNhcmUgb2YgaG92ZXItc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZEl0ZW0gPSBpbnRlcm5hbC5ob3ZlcmVkLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoIWhvdmVyZWRJdGVtKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2Fzbid0IHByZXZpb3VzbHkgaG92ZXJlZCwgYm9vayBpdCBhbmQgY2FsbCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLnNldChpZCwgZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLnBvaW50ZXJvdmVyPy4oZGF0YSBhcyBOZ3RFdmVudDxQb2ludGVyRXZlbnQ+KTtcbiAgICAgICAgICAgICAgaGFuZGxlcnMucG9pbnRlcmVudGVyPy4oZGF0YSBhcyBOZ3RFdmVudDxQb2ludGVyRXZlbnQ+KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0uc3RvcHBlZCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhcyBwcmV2aW91c2x5IGhvdmVyZWQgYW5kIHN0b3BwZWQsIHdlIHNob3VsZG4ndCBhbGxvdyBvdGhlciBpdGVtcyB0byBwcm9jZWVkXG4gICAgICAgICAgICAgIGRhdGEuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhbGwgbW91c2UgbW92ZVxuICAgICAgICAgIGhhbmRsZXJzPy5wb2ludGVybW92ZT8uKGRhdGEgYXMgTmd0RXZlbnQ8UG9pbnRlckV2ZW50Pik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxsIG90aGVyIGV2ZW50cyAuLi5cbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnM/LltuYW1lIGFzIGtleW9mIE5ndEV2ZW50SGFuZGxlcnNdIGFzIChcbiAgICAgICAgICAgIGV2ZW50OiBOZ3RFdmVudDxQb2ludGVyRXZlbnQ+XG4gICAgICAgICAgKSA9PiB2b2lkO1xuICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyBGb3J3YXJkIGFsbCBldmVudHMgYmFjayB0byB0aGVpciByZXNwZWN0aXZlIGhhbmRsZXJzIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBjbGljayBldmVudHMsXG4gICAgICAgICAgICAvLyB3aGljaCBtdXN0IHVzZSB0aGUgaW5pdGlhbCB0YXJnZXRcbiAgICAgICAgICAgIGlmICghaXNDbGlja0V2ZW50IHx8IGludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdFxuICAgICAgICAgICAgICBvYmplY3RQb2ludGVyTWlzc2VkKFxuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgIChvYmplY3QpID0+ICFpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhvYmplY3QpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvLyBOb3cgY2FsbCB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICBoYW5kbGVyKGRhdGEgYXMgTmd0RXZlbnQ8UG9pbnRlckV2ZW50Pik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9iamVjdFBvaW50ZXJNaXNzZWQoZXZlbnQ6IE1vdXNlRXZlbnQsIG9iamVjdHM6IFRIUkVFLk9iamVjdDNEW10pIHtcbiAgICBvYmplY3RzLmZvckVhY2goKG9iamVjdDogVEhSRUUuT2JqZWN0M0QpID0+XG4gICAgICAob2JqZWN0IGFzIHVua25vd24gYXMgTmd0SW5zdGFuY2UpLl9fbmd0Py5oYW5kbGVycz8ucG9pbnRlcm1pc3NlZD8uKGV2ZW50KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4geyBoYW5kbGVQb2ludGVyIH07XG59XG4iXX0=