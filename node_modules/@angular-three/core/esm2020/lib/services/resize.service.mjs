import { DOCUMENT } from '@angular/common';
import { ElementRef, Inject, Injectable, NgZone } from '@angular/core';
import { debounceTime, fromEvent, Observable, pipe, ReplaySubject, share, Subject, takeUntil, } from 'rxjs';
import { NGT_RESIZE_OBSERVER_SUPPORT, NGT_RESIZE_OPTIONS, } from '../di/resize';
import * as i0 from "@angular/core";
export class NgtResize extends Observable {
    constructor({ nativeElement }, ngZone, document, isSupport, { box, offsetSize, scroll, debounce }) {
        let observer;
        let lastBounds;
        let lastEntries = [];
        const torndown$ = new Subject();
        const scrollContainers = findScrollContainers(nativeElement);
        // set actual debounce values early, so effects know if they should react accordingly
        const scrollDebounce = debounce
            ? typeof debounce === 'number'
                ? debounce
                : debounce.scroll
            : null;
        const resizeDebounce = debounce
            ? typeof debounce === 'number'
                ? debounce
                : debounce.resize
            : null;
        const debounceAndDestroy = (debounce) => {
            return pipe(debounceTime(debounce ?? 0), takeUntil(torndown$));
        };
        super((subscriber) => {
            if (!isSupport) {
                subscriber.error('ResizeObserver is not supported in your browser. Please use a polyfill');
                return;
            }
            ngZone.runOutsideAngular(() => {
                const callback = (entries) => {
                    lastEntries = entries;
                    const { left, top, width, height, bottom, right, x, y } = nativeElement.getBoundingClientRect();
                    const size = {
                        left,
                        top,
                        width,
                        height,
                        bottom,
                        right,
                        x,
                        y,
                    };
                    if (nativeElement instanceof HTMLElement && offsetSize) {
                        size.height = nativeElement.offsetHeight;
                        size.width = nativeElement.offsetWidth;
                    }
                    Object.freeze(size);
                    subscriber.next({
                        entries,
                        dpr: document.defaultView.devicePixelRatio,
                        ...size,
                    });
                    if (!areBoundsEqual(lastBounds || {}, size)) {
                        lastBounds = size;
                    }
                };
                const boundEntriesCallback = () => {
                    callback(lastEntries);
                };
                observer = new ResizeObserver(callback);
                observer.observe(nativeElement, { box });
                if (scroll) {
                    if (scrollContainers) {
                        scrollContainers.forEach((scrollContainer) => {
                            fromEvent(scrollContainer, 'scroll', {
                                capture: true,
                                passive: true,
                            })
                                .pipe(debounceAndDestroy(scrollDebounce))
                                .subscribe(boundEntriesCallback);
                        });
                    }
                    fromEvent(document.defaultView, 'scroll', {
                        capture: true,
                        passive: true,
                    })
                        .pipe(debounceAndDestroy(scrollDebounce))
                        .subscribe(boundEntriesCallback);
                }
                fromEvent(document.defaultView, 'resize')
                    .pipe(debounceAndDestroy(resizeDebounce))
                    .subscribe(boundEntriesCallback);
            });
            return () => {
                if (observer) {
                    observer.unobserve(nativeElement);
                    observer.disconnect();
                }
                torndown$.next();
                torndown$.complete();
            };
        });
        return this.pipe(debounceTime(scrollDebounce || 0), share({
            connector: () => new ReplaySubject(1),
            resetOnRefCountZero: true,
            resetOnComplete: true,
        }));
    }
}
NgtResize.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtResize, deps: [{ token: ElementRef }, { token: NgZone }, { token: DOCUMENT }, { token: NGT_RESIZE_OBSERVER_SUPPORT }, { token: NGT_RESIZE_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });
NgtResize.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtResize });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtResize, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i0.NgZone, decorators: [{
                    type: Inject,
                    args: [NgZone]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NGT_RESIZE_OBSERVER_SUPPORT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NGT_RESIZE_OPTIONS]
                }] }]; } });
// Returns a list of scroll offsets
function findScrollContainers(element) {
    const result = [];
    if (!element || element === document.body)
        return result;
    const { overflow, overflowX, overflowY } = window.getComputedStyle(element);
    if ([overflow, overflowX, overflowY].some((prop) => prop === 'auto' || prop === 'scroll'))
        result.push(element);
    return [
        ...result,
        ...findScrollContainers(element.parentElement),
    ];
}
// Checks if element boundaries are equal
const keys = [
    'x',
    'y',
    'top',
    'bottom',
    'left',
    'right',
    'width',
    'height',
];
const areBoundsEqual = (a, b) => keys.every((key) => a[key] === b[key]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXplLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9saWIvc2VydmljZXMvcmVzaXplLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdkUsT0FBTyxFQUNMLFlBQVksRUFDWixTQUFTLEVBRVQsVUFBVSxFQUNWLElBQUksRUFDSixhQUFhLEVBQ2IsS0FBSyxFQUNMLE9BQU8sRUFDUCxTQUFTLEdBQ1YsTUFBTSxNQUFNLENBQUM7QUFDZCxPQUFPLEVBQ0wsMkJBQTJCLEVBQzNCLGtCQUFrQixHQUVuQixNQUFNLGNBQWMsQ0FBQzs7QUFnQnRCLE1BQU0sT0FBTyxTQUFVLFNBQVEsVUFBMkI7SUFDeEQsWUFDc0IsRUFBRSxhQUFhLEVBQXVCLEVBQzFDLE1BQWMsRUFDWixRQUFrQixFQUNDLFNBQWtCLEVBRXZELEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFvQjtRQUV2RCxJQUFJLFFBQXdCLENBQUM7UUFDN0IsSUFBSSxVQUFvRCxDQUFDO1FBQ3pELElBQUksV0FBVyxHQUEwQixFQUFFLENBQUM7UUFFNUMsTUFBTSxTQUFTLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztRQUN0QyxNQUFNLGdCQUFnQixHQUE4QixvQkFBb0IsQ0FDdEUsYUFBNEIsQ0FDN0IsQ0FBQztRQUVGLHFGQUFxRjtRQUNyRixNQUFNLGNBQWMsR0FBRyxRQUFRO1lBQzdCLENBQUMsQ0FBQyxPQUFPLFFBQVEsS0FBSyxRQUFRO2dCQUM1QixDQUFDLENBQUMsUUFBUTtnQkFDVixDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU07WUFDbkIsQ0FBQyxDQUFD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Z0M7SUFFaEMsTUFBTSxNQUFNLEdBQXVCLEVBQUUsQ0FBQztJQUN0QyxJQUFJLENBQUMsT0FBTyxJQUFJLE9BQU8sS0FBSyxRQUFRLENBQUMsSUFBSTtRQUFFLE9BQU8sTUFBTSxDQUFDO0lBQ3pELE1BQU0sRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FDaEUsT0FBc0IsQ0FDdkIsQ0FBQztJQUNGLElBQ0UsQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FDbkMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLFFBQVEsQ0FDL0M7UUFFRCxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3ZCLE9BQU87UUFDTCxHQUFHLE1BQU07UUFDVCxHQUFHLG9CQUFvQixDQUFFLE9BQXVCLENBQUMsYUFBYSxDQUFDO0tBQ2hFLENBQUM7QUFDSixDQUFDO0FBRUQseUNBQXlDO0FBQ3pDLE1BQU0sSUFBSSxHQUF1RDtJQUMvRCxHQUFHO0lBQ0gsR0FBRztJQUNILEtBQUs7SUFDTCxRQUFRO0lBQ1IsTUFBTTtJQUNOLE9BQU87SUFDUCxPQUFPO0lBQ1AsUUFBUTtDQUNULENBQUM7QUFDRixNQUFNLGNBQWMsR0FBRyxDQUNyQixDQUEyQyxFQUMzQyxDQUEyQyxFQUNsQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIGRlYm91bmNlVGltZSxcbiAgZnJvbUV2ZW50LFxuICBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24sXG4gIE9ic2VydmFibGUsXG4gIHBpcGUsXG4gIFJlcGxheVN1YmplY3QsXG4gIHNoYXJlLFxuICBTdWJqZWN0LFxuICB0YWtlVW50aWwsXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgTkdUX1JFU0laRV9PQlNFUlZFUl9TVVBQT1JULFxuICBOR1RfUkVTSVpFX09QVElPTlMsXG4gIE5ndFJlc2l6ZU9wdGlvbnMsXG59IGZyb20gJy4uL2RpL3Jlc2l6ZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmd0UmVzaXplUmVzdWx0IHtcbiAgcmVhZG9ubHkgZW50cmllczogUmVhZG9ubHlBcnJheTxSZXNpemVPYnNlcnZlckVudHJ5PjtcbiAgcmVhZG9ubHkgeDogbnVtYmVyO1xuICByZWFkb25seSB5OiBudW1iZXI7XG4gIHJlYWRvbmx5IHdpZHRoOiBudW1iZXI7XG4gIHJlYWRvbmx5IGhlaWdodDogbnVtYmVyO1xuICByZWFkb25seSB0b3A6IG51bWJlcjtcbiAgcmVhZG9ubHkgcmlnaHQ6IG51bWJlcjtcbiAgcmVhZG9ubHkgYm90dG9tOiBudW1iZXI7XG4gIHJlYWRvbmx5IGxlZnQ6IG51bWJlcjtcbiAgcmVhZG9ubHkgZHByOiBudW1iZXI7XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOZ3RSZXNpemUgZXh0ZW5kcyBPYnNlcnZhYmxlPE5ndFJlc2l6ZVJlc3VsdD4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KEVsZW1lbnRSZWYpIHsgbmF0aXZlRWxlbWVudCB9OiBFbGVtZW50UmVmPEVsZW1lbnQ+LFxuICAgIEBJbmplY3QoTmdab25lKSBuZ1pvbmU6IE5nWm9uZSxcbiAgICBASW5qZWN0KERPQ1VNRU5UKSBkb2N1bWVudDogRG9jdW1lbnQsXG4gICAgQEluamVjdChOR1RfUkVTSVpFX09CU0VSVkVSX1NVUFBPUlQpIGlzU3VwcG9ydDogYm9vbGVhbixcbiAgICBASW5qZWN0KE5HVF9SRVNJWkVfT1BUSU9OUylcbiAgICB7IGJveCwgb2Zmc2V0U2l6ZSwgc2Nyb2xsLCBkZWJvdW5jZSB9OiBOZ3RSZXNpemVPcHRpb25zXG4gICkge1xuICAgIGxldCBvYnNlcnZlcjogUmVzaXplT2JzZXJ2ZXI7XG4gICAgbGV0IGxhc3RCb3VuZHM6IE9taXQ8Tmd0UmVzaXplUmVzdWx0LCAnZW50cmllcycgfCAnZHByJz47XG4gICAgbGV0IGxhc3RFbnRyaWVzOiBSZXNpemVPYnNlcnZlckVudHJ5W10gPSBbXTtcblxuICAgIGNvbnN0IHRvcm5kb3duJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyczogSFRNTE9yU1ZHRWxlbWVudFtdIHwgbnVsbCA9IGZpbmRTY3JvbGxDb250YWluZXJzKFxuICAgICAgbmF0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgICk7XG5cbiAgICAvLyBzZXQgYWN0dWFsIGRlYm91bmNlIHZhbHVlcyBlYXJseSwgc28gZWZmZWN0cyBrbm93IGlmIHRoZXkgc2hvdWxkIHJlYWN0IGFjY29yZGluZ2x5XG4gICAgY29uc3Qgc2Nyb2xsRGVib3VuY2UgPSBkZWJvdW5jZVxuICAgICAgPyB0eXBlb2YgZGVib3VuY2UgPT09ICdudW1iZXInXG4gICAgICAgID8gZGVib3VuY2VcbiAgICAgICAgOiBkZWJvdW5jZS5zY3JvbGxcbiAgICAgIDogbnVsbDtcblxuICAgIGNvbnN0IHJlc2l6ZURlYm91bmNlID0gZGVib3VuY2VcbiAgICAgID8gdHlwZW9mIGRlYm91bmNlID09PSAnbnVtYmVyJ1xuICAgICAgICA/IGRlYm91bmNlXG4gICAgICAgIDogZGVib3VuY2UucmVzaXplXG4gICAgICA6IG51bGw7XG5cbiAgICBjb25zdCBkZWJvdW5jZUFuZERlc3Ryb3kgPSA8VD4oXG4gICAgICBkZWJvdW5jZTogbnVtYmVyIHwgbnVsbFxuICAgICk6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPiA9PiB7XG4gICAgICByZXR1cm4gcGlwZShkZWJvdW5jZVRpbWUoZGVib3VuY2UgPz8gMCksIHRha2VVbnRpbCh0b3JuZG93biQpKTtcbiAgICB9O1xuXG4gICAgc3VwZXIoKHN1YnNjcmliZXIpID0+IHtcbiAgICAgIGlmICghaXNTdXBwb3J0KSB7XG4gICAgICAgIHN1YnNjcmliZXIuZXJyb3IoXG4gICAgICAgICAgJ1Jlc2l6ZU9ic2VydmVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyLiBQbGVhc2UgdXNlIGEgcG9seWZpbGwnXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoZW50cmllczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKSA9PiB7XG4gICAgICAgICAgbGFzdEVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgICAgIGNvbnN0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCBib3R0b20sIHJpZ2h0LCB4LCB5IH0gPVxuICAgICAgICAgICAgbmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBhcyB1bmtub3duIGFzIE9taXQ8XG4gICAgICAgICAgICAgIE5ndFJlc2l6ZVJlc3VsdCxcbiAgICAgICAgICAgICAgJ2VudHJpZXMnXG4gICAgICAgICAgICA+O1xuXG4gICAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChuYXRpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgb2Zmc2V0U2l6ZSkge1xuICAgICAgICAgICAgc2l6ZS5oZWlnaHQgPSBuYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIHNpemUud2lkdGggPSBuYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIE9iamVjdC5mcmVlemUoc2l6ZSk7XG4gICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHtcbiAgICAgICAgICAgIGVudHJpZXMsXG4gICAgICAgICAgICBkcHI6IGRvY3VtZW50LmRlZmF1bHRWaWV3IS5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgICAgLi4uc2l6ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWFyZUJvdW5kc0VxdWFsKGxhc3RCb3VuZHMgfHwge30sIHNpemUpKSB7XG4gICAgICAgICAgICBsYXN0Qm91bmRzID0gc2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgYm91bmRFbnRyaWVzQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sobGFzdEVudHJpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShuYXRpdmVFbGVtZW50LCB7IGJveCB9KTtcbiAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgIGlmIChzY3JvbGxDb250YWluZXJzKSB7XG4gICAgICAgICAgICBzY3JvbGxDb250YWluZXJzLmZvckVhY2goKHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICAgICAgICAgICAgICBmcm9tRXZlbnQoc2Nyb2xsQ29udGFpbmVyIGFzIEhUTUxFbGVtZW50LCAnc2Nyb2xsJywge1xuICAgICAgICAgICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucGlwZShkZWJvdW5jZUFuZERlc3Ryb3koc2Nyb2xsRGVib3VuY2UpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoYm91bmRFbnRyaWVzQ2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3IGFzIFdpbmRvdywgJ3Njcm9sbCcsIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgICAucGlwZShkZWJvdW5jZUFuZERlc3Ryb3koc2Nyb2xsRGVib3VuY2UpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShib3VuZEVudHJpZXNDYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBmcm9tRXZlbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcgYXMgV2luZG93LCAncmVzaXplJylcbiAgICAgICAgICAucGlwZShkZWJvdW5jZUFuZERlc3Ryb3kocmVzaXplRGVib3VuY2UpKVxuICAgICAgICAgIC5zdWJzY3JpYmUoYm91bmRFbnRyaWVzQ2FsbGJhY2spO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShuYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ybmRvd24kLm5leHQoKTtcbiAgICAgICAgdG9ybmRvd24kLmNvbXBsZXRlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMucGlwZShcbiAgICAgIGRlYm91bmNlVGltZShzY3JvbGxEZWJvdW5jZSB8fCAwKSxcbiAgICAgIHNoYXJlKHtcbiAgICAgICAgY29ubmVjdG9yOiAoKSA9PiBuZXcgUmVwbGF5U3ViamVjdCgxKSxcbiAgICAgICAgcmVzZXRPblJlZkNvdW50WmVybzogdHJ1ZSxcbiAgICAgICAgcmVzZXRPbkNvbXBsZXRlOiB0cnVlLFxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5cbi8vIFJldHVybnMgYSBsaXN0IG9mIHNjcm9sbCBvZmZzZXRzXG5mdW5jdGlvbiBmaW5kU2Nyb2xsQ29udGFpbmVycyhcbiAgZWxlbWVudDogSFRNTE9yU1ZHRWxlbWVudCB8IG51bGxcbik6IEhUTUxPclNWR0VsZW1lbnRbXSB7XG4gIGNvbnN0IHJlc3VsdDogSFRNTE9yU1ZHRWxlbWVudFtdID0gW107XG4gIGlmICghZWxlbWVudCB8fCBlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSByZXR1cm4gcmVzdWx0O1xuICBjb25zdCB7IG92ZXJmbG93LCBvdmVyZmxvd1gsIG92ZXJmbG93WSB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoXG4gICAgZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICApO1xuICBpZiAoXG4gICAgW292ZXJmbG93LCBvdmVyZmxvd1gsIG92ZXJmbG93WV0uc29tZShcbiAgICAgIChwcm9wKSA9PiBwcm9wID09PSAnYXV0bycgfHwgcHJvcCA9PT0gJ3Njcm9sbCdcbiAgICApXG4gIClcbiAgICByZXN1bHQucHVzaChlbGVtZW50KTtcbiAgcmV0dXJuIFtcbiAgICAuLi5yZXN1bHQsXG4gICAgLi4uZmluZFNjcm9sbENvbnRhaW5lcnMoKGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLnBhcmVudEVsZW1lbnQpLFxuICBdO1xufVxuXG4vLyBDaGVja3MgaWYgZWxlbWVudCBib3VuZGFyaWVzIGFyZSBlcXVhbFxuY29uc3Qga2V5czogKGtleW9mIE9taXQ8Tmd0UmVzaXplUmVzdWx0LCAnZW50cmllcycgfCAnZHByJz4pW10gPSBbXG4gICd4JyxcbiAgJ3knLFxuICAndG9wJyxcbiAgJ2JvdHRvbScsXG4gICdsZWZ0JyxcbiAgJ3JpZ2h0JyxcbiAgJ3dpZHRoJyxcbiAgJ2hlaWdodCcsXG5dO1xuY29uc3QgYXJlQm91bmRzRXF1YWwgPSAoXG4gIGE6IE9taXQ8Tmd0UmVzaXplUmVzdWx0LCAnZW50cmllcycgfCAnZHByJz4sXG4gIGI6IE9taXQ8Tmd0UmVzaXplUmVzdWx0LCAnZW50cmllcycgfCAnZHByJz5cbik6IGJvb2xlYW4gPT4ga2V5cy5ldmVyeSgoa2V5KSA9PiBhW2tleV0gPT09IGJba2V5XSk7XG4iXX0=