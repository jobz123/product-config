import * as i6 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { InjectionToken, Directive, Injectable, inject, ElementRef, NgZone, Inject, EventEmitter, Component, ChangeDetectionStrategy, Self, HostBinding, Input, Output, ViewChild, NgModule, Optional, ChangeDetectorRef, SkipSelf, Pipe, ViewContainerRef, TemplateRef, ContentChild } from '@angular/core';
import * as THREE from 'three';
import { MathUtils } from 'three';
import { __classPrivateFieldGet, __classPrivateFieldSet } from 'tslib';
import { requestAnimationFrame, clearTimeout, setTimeout } from '@rx-angular/cdk/zone-less';
import * as i1 from 'rxjs';
import { Subject, noop, catchError, EMPTY, tap, Observable, pipe, debounceTime, takeUntil, fromEvent, share, ReplaySubject, map, defer, merge, take, mapTo, forkJoin, of, throwError } from 'rxjs';
import { RxState, createSideEffectObservable, selectSlice } from '@rx-angular/state';

const DEFAULT_NGT_CANVAS_OPTIONS = {
    projectContent: false,
};
const NGT_CANVAS_OPTIONS = new InjectionToken('Canvas Options', {
    providedIn: 'root',
    factory: () => DEFAULT_NGT_CANVAS_OPTIONS,
});
function provideCanvasOptions(options) {
    return {
        ...DEFAULT_NGT_CANVAS_OPTIONS,
        ...(options || {}),
    };
}

/**
 * Generate a random Id or an Event's uuid
 *
 * @param {NgtIntersection} event
 *
 * @internal
 * @private
 */
function makeId(event) {
    if (event) {
        return ((event.eventObject || event.object).uuid +
            '/' +
            event.index +
            event.instanceId);
    }
    return id();
}
const cache = {};
/**
 * Generates a UUID.
 */
function id() {
    const newId = MathUtils.generateUUID();
    // ensure not already used
    if (!cache[newId]) {
        cache[newId] = true;
        return newId;
    }
    return id();
}

function actionProxyHandler(subjects, transforms) {
    return {
        get(_, property) {
            const prop = property;
            // the user wants to get a observable
            if (prop.toString().split('').pop() === '$') {
                const propName = prop.toString().slice(0, -1);
                subjects[propName] = subjects[propName] || new Subject();
                return subjects[propName];
            }
            // the user wants to get a dispatcher function
            return (args) => {
                subjects[prop] = subjects[prop] || new Subject();
                const val = transforms && transforms[prop]
                    ? transforms[prop](args)
                    : args;
                subjects[prop].next(val);
            };
        },
        set() {
            throw new Error('No setters available. To emit call the property name.');
        },
    };
}
class EnhancedRxState extends RxState {
    constructor() {
        super(...arguments);
        this.subjects = {};
        this.effect$ = createSideEffectObservable();
        this.effectSubscription = this.effect$.subscribe();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.effectSubscription.unsubscribe();
        this.destroy();
    }
    create(transforms) {
        return new Proxy({}, actionProxyHandler(this.subjects, transforms));
    }
    destroy() {
        for (const subjectsKey in this.subjects) {
            this.subjects[subjectsKey].complete();
        }
    }
    holdEffect(obsOrObsWithSideEffect, sideEffectFn) {
        let cleanupFn = noop;
        let firstRun = false;
        let latestValue = undefined;
        const sideEffect = obsOrObsWithSideEffect.pipe(catchError((_) => EMPTY));
        this.effect$.nextEffectObservable(sideEffect.pipe(tap({
            next: (value) => {
                if (cleanupFn && firstRun) {
                    cleanupFn(latestValue, false);
                }
                const cleanUpOrVoid = sideEffectFn(value, firstRun);
                if (cleanUpOrVoid) {
                    cleanupFn = cleanUpOrVoid;
                }
                latestValue = value;
                if (!firstRun) {
                    firstRun = true;
                }
            },
            unsubscribe: () => {
                if (cleanupFn) {
                    cleanupFn(latestValue, true);
                }
            },
        })));
    }
}
EnhancedRxState.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: EnhancedRxState, deps: null, target: i0.ɵɵFactoryTarget.Directive });
EnhancedRxState.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: EnhancedRxState, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: EnhancedRxState, decorators: [{
            type: Directive
        }] });
function capitalize(str) {
    return (str.charAt(0).toUpperCase() + str.slice(1));
}

var _NgtAnimationFrameStore_instances, _NgtAnimationFrameStore_register, _NgtAnimationFrameStore_unregister;
class NgtAnimationFrameStore extends EnhancedRxState {
    constructor() {
        super();
        _NgtAnimationFrameStore_instances.add(this);
        this.actions = this.create();
        this.set({ animations: {}, subscribers: [], hasPriority: false });
        this.hold(this.select('animations'), (animations) => {
            const subscribers = Object.values(animations);
            subscribers.sort((a, b) => (a.priority || 0) - (b.priority || 0));
            const hasPriority = subscribers.some(({ priority }) => !!priority);
            this.set({ hasPriority, subscribers });
        });
        this.hold(this.actions.animationRecord$, __classPrivateFieldGet(this, _NgtAnimationFrameStore_instances, "m", _NgtAnimationFrameStore_register).bind(this));
        this.hold(this.actions.unsubscriberUuid$, __classPrivateFieldGet(this, _NgtAnimationFrameStore_instances, "m", _NgtAnimationFrameStore_unregister).bind(this));
    }
    register(animationRecord) {
        const uuid = animationRecord.obj?.uuid || makeId();
        this.actions.animationRecord({ ...animationRecord, uuid });
        return uuid;
    }
    ngOnDestroy() {
        this.set({ animations: {} });
        super.ngOnDestroy();
    }
}
_NgtAnimationFrameStore_instances = new WeakSet(), _NgtAnimationFrameStore_register = function _NgtAnimationFrameStore_register({ uuid, ...animationRecord } = {
    uuid: '',
    callback: noop,
}) {
    if (uuid) {
        this.set((state) => {
            return {
                animations: { ...state.animations, [uuid]: animationRecord },
            };
        });
    }
    return (prevRecord, isUnsub) => {
        if ((prevRecord && prevRecord.uuid !== uuid) || isUnsub) {
            __classPrivateFieldGet(this, _NgtAnimationFrameStore_instances, "m", _NgtAnimationFrameStore_unregister).call(this, uuid);
        }
    };
}, _NgtAnimationFrameStore_unregister = function _NgtAnimationFrameStore_unregister(uuid) {
    if (!uuid)
        return;
    this.set((state) => {
        const { [uuid]: _, ...animations } = state.animations;
        return { animations };
    });
};
NgtAnimationFrameStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAnimationFrameStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NgtAnimationFrameStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAnimationFrameStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAnimationFrameStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

const NGT_PERFORMANCE_OPTIONS = new InjectionToken('NgtPerformance options', {
    providedIn: 'root',
    factory: () => ({
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
    }),
});

const NGT_RESIZE_BOX_DEFAULT = 'content-box';
const NGT_RESIZE_DEBOUNCE_DEFAULT = 200;
const NGT_RESIZE_OPTIONS = new InjectionToken('ngtResizeObserver Options', {
    providedIn: 'root',
    factory: () => ({
        box: NGT_RESIZE_BOX_DEFAULT,
        scroll: false,
        offsetSize: false,
        debounce: NGT_RESIZE_DEBOUNCE_DEFAULT,
    }),
});
const NGT_RESIZE_OBSERVER_SUPPORT = new InjectionToken('Resize Observer API support', {
    providedIn: 'root',
    factory: () => {
        const document = inject(DOCUMENT);
        return (!!document.defaultView &&
            'ResizeObserver' in document.defaultView &&
            document.defaultView['ResizeObserver'] != null);
    },
});

class NgtResize extends Observable {
    constructor({ nativeElement }, ngZone, document, isSupport, { box, offsetSize, scroll, debounce }) {
        let observer;
        let lastBounds;
        let lastEntries = [];
        const torndown$ = new Subject();
        const scrollContainers = findScrollContainers(nativeElement);
        // set actual debounce values early, so effects know if they should react accordingly
        const scrollDebounce = debounce
            ? typeof debounce === 'number'
                ? debounce
                : debounce.scroll
            : null;
        const resizeDebounce = debounce
            ? typeof debounce === 'number'
                ? debounce
                : debounce.resize
            : null;
        const debounceAndDestroy = (debounce) => {
            return pipe(debounceTime(debounce ?? 0), takeUntil(torndown$));
        };
        super((subscriber) => {
            if (!isSupport) {
                subscriber.error('ResizeObserver is not supported in your browser. Please use a polyfill');
                return;
            }
            ngZone.runOutsideAngular(() => {
                const callback = (entries) => {
                    lastEntries = entries;
                    const { left, top, width, height, bottom, right, x, y } = nativeElement.getBoundingClientRect();
                    const size = {
                        left,
                        top,
                        width,
                        height,
                        bottom,
                        right,
                        x,
                        y,
                    };
                    if (nativeElement instanceof HTMLElement && offsetSize) {
                        size.height = nativeElement.offsetHeight;
                        size.width = nativeElement.offsetWidth;
                    }
                    Object.freeze(size);
                    subscriber.next({
                        entries,
                        dpr: document.defaultView.devicePixelRatio,
                        ...size,
                    });
                    if (!areBoundsEqual(lastBounds || {}, size)) {
                        lastBounds = size;
                    }
                };
                const boundEntriesCallback = () => {
                    callback(lastEntries);
                };
                observer = new ResizeObserver(callback);
                observer.observe(nativeElement, { box });
                if (scroll) {
                    if (scrollContainers) {
                        scrollContainers.forEach((scrollContainer) => {
                            fromEvent(scrollContainer, 'scroll', {
                                capture: true,
                                passive: true,
                            })
                                .pipe(debounceAndDestroy(scrollDebounce))
                                .subscribe(boundEntriesCallback);
                        });
                    }
                    fromEvent(document.defaultView, 'scroll', {
                        capture: true,
                        passive: true,
                    })
                        .pipe(debounceAndDestroy(scrollDebounce))
                        .subscribe(boundEntriesCallback);
                }
                fromEvent(document.defaultView, 'resize')
                    .pipe(debounceAndDestroy(resizeDebounce))
                    .subscribe(boundEntriesCallback);
            });
            return () => {
                if (observer) {
                    observer.unobserve(nativeElement);
                    observer.disconnect();
                }
                torndown$.next();
                torndown$.complete();
            };
        });
        return this.pipe(debounceTime(scrollDebounce || 0), share({
            connector: () => new ReplaySubject(1),
            resetOnRefCountZero: true,
            resetOnComplete: true,
        }));
    }
}
NgtResize.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtResize, deps: [{ token: ElementRef }, { token: NgZone }, { token: DOCUMENT }, { token: NGT_RESIZE_OBSERVER_SUPPORT }, { token: NGT_RESIZE_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });
NgtResize.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtResize });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtResize, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i0.NgZone, decorators: [{
                    type: Inject,
                    args: [NgZone]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NGT_RESIZE_OBSERVER_SUPPORT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NGT_RESIZE_OPTIONS]
                }] }]; } });
// Returns a list of scroll offsets
function findScrollContainers(element) {
    const result = [];
    if (!element || element === document.body)
        return result;
    const { overflow, overflowX, overflowY } = window.getComputedStyle(element);
    if ([overflow, overflowX, overflowY].some((prop) => prop === 'auto' || prop === 'scroll'))
        result.push(element);
    return [
        ...result,
        ...findScrollContainers(element.parentElement),
    ];
}
// Checks if element boundaries are equal
const keys = [
    'x',
    'y',
    'top',
    'bottom',
    'left',
    'right',
    'width',
    'height',
];
const areBoundsEqual = (a, b) => keys.every((key) => a[key] === b[key]);

function checkNeedsUpdate(value) {
    if (value !== null &&
        typeof value === 'object' &&
        'needsUpdate' in value) {
        value['needsUpdate'] = true;
    }
}
function applyProps(instance, props) {
    if (!Object.keys(props).length)
        return;
    if ('__ngt' in props) {
        instance['__ngt'] = props['__ngt'];
    }
    const unknownInstance = instance;
    if (unknownInstance['set'] != null &&
        typeof unknownInstance['set'] === 'function') {
        try {
            unknownInstance['set'](props);
        }
        catch (e) {
            console.info(`Swallowing erroneous "set" invoke on ${unknownInstance.constructor.name} as non fatal: ${e}`);
        }
    }
    for (const [key, prop] of Object.entries(props)) {
        const currentInstance = unknownInstance;
        const targetProp = currentInstance[key];
        if (targetProp &&
            targetProp['set'] &&
            (targetProp['copy'] || targetProp instanceof THREE.Layers)) {
            if (Array.isArray(prop)) {
                if (targetProp.fromArray)
                    targetProp.fromArray(prop);
                else
                    targetProp.set(...prop);
            }
            else if (targetProp.copy &&
                prop &&
                prop.constructor &&
                targetProp.constructor.name ===
                    prop.constructor.name) {
                targetProp.copy(prop);
            }
            else if (prop !== undefined) {
                const isColor = targetProp instanceof THREE.Color;
                // Allow setting array scalars
                if (!isColor && targetProp.setScalar)
                    targetProp.setScalar(prop);
                // Layers have no copy function, we must therefore copy the mask property
                else if (targetProp instanceof THREE.Layers &&
                    prop instanceof THREE.Layers)
                    targetProp.mask = prop.mask;
                // Otherwise just set ...
                else
                    targetProp.set(prop);
                // Auto-convert sRGB colors, for now ...
                // https://github.com/pmndrs/react-three-fiber/issues/344
                if (!currentInstance.linear && isColor)
                    targetProp.convertSRGBToLinear();
            }
        }
        else {
            currentInstance[key] = prop;
            // Auto-convert sRGB textures, for now ...
            // https://github.com/pmndrs/react-three-fiber/issues/344
            if (!currentInstance.linear &&
                currentInstance[key] instanceof THREE.Texture)
                currentInstance[key].encoding = THREE.sRGBEncoding;
        }
        checkNeedsUpdate(prop);
        checkNeedsUpdate(targetProp);
    }
}

function calculateDpr(dpr) {
    return Array.isArray(dpr)
        ? Math.min(Math.max(dpr[0], window.devicePixelRatio), dpr[1])
        : dpr;
}

const isOrthographicCamera = (def) => def && def.isOrthographicCamera;

var _NgtStore_instances, _NgtStore_allReady$, _NgtStore_dimensions$, _NgtStore_init, _NgtStore_updateDimensions;
const position = new THREE.Vector3();
const defaultTarget = new THREE.Vector3();
class NgtStore extends EnhancedRxState {
    constructor(performance, { nativeElement: canvasHost }, resizeResult$) {
        super();
        this.resizeResult$ = resizeResult$;
        _NgtStore_instances.add(this);
        _NgtStore_allReady$.set(this, this.select(selectSlice(['scene', 'camera', 'renderer', 'raycaster']), map(({ scene, camera, renderer, raycaster }) => !!scene && !!camera && !!renderer && !!raycaster)));
        _NgtStore_dimensions$.set(this, this.select(selectSlice(['size', 'viewport'])));
        this.actions = this.create();
        this.set({
            ready: false,
            vr: false,
            orthographic: false,
            flat: false,
            linear: false,
            size: {
                height: canvasHost.clientHeight,
                width: canvasHost.clientWidth,
            },
            mouse: new THREE.Vector2(),
            clock: new THREE.Clock(),
            frameloop: 'always',
            performance,
            controls: null,
            objects: {},
            dpr: 1,
            shadows: false,
            cameraOptions: {},
            glOptions: {},
            raycasterOptions: {},
            sceneOptions: {},
            viewport: {
                initialDpr: calculateDpr(this.get('dpr')),
                dpr: calculateDpr(this.get('dpr')),
                width: canvasHost.clientWidth,
                height: canvasHost.clientHeight,
                aspect: canvasHost.clientWidth / canvasHost.clientHeight,
                distance: 0,
                factor: 0,
                getCurrentViewport: (camera = this.get('camera'), target = defaultTarget, size = this.get('size')) => {
                    const { width, height } = size;
                    const aspect = width / height;
                    const distance = camera
                        .getWorldDirection(position)
                        .distanceTo(target);
                    if (isOrthographicCamera(camera)) {
                        return {
                            width: width / camera.zoom,
                            height: height / camera.zoom,
                            factor: 1,
                            distance,
                            aspect,
                        };
                    }
                    const fov = (camera.fov * Math.PI) / 180; // convert vertical fov to radians
                    const h = 2 * Math.tan(fov / 2) * distance; // height of viewport
                    const w = h * aspect; // width of viewport
                    return {
                        width: w,
                        height: h,
                        factor: width / w,
                        distance,
                        aspect,
                    };
                },
            },
        });
        this.connect('ready', __classPrivateFieldGet(this, _NgtStore_allReady$, "f"));
        this.connect('size', this.resizeResult$, (_, { width, height }) => ({
            width,
            height,
        }));
        this.connect('viewport', this.resizeResult$, ({ viewport }, { dpr }) => ({
            ...viewport,
            dpr,
        }));
        this.hold(__classPrivateFieldGet(this, _NgtStore_dimensions$, "f"), __classPrivateFieldGet(this, _NgtStore_instances, "m", _NgtStore_updateDimensions).bind(this));
        this.holdEffect(this.actions.canvasElement$, __classPrivateFieldGet(this, _NgtStore_instances, "m", _NgtStore_init).bind(this));
    }
}
_NgtStore_allReady$ = new WeakMap(), _NgtStore_dimensions$ = new WeakMap(), _NgtStore_instances = new WeakSet(), _NgtStore_init = function _NgtStore_init(canvasElement) {
    const { size, viewport, vr, linear, flat, orthographic } = this.get();
    const { shadows, glOptions, sceneOptions, cameraOptions, raycasterOptions, } = this.get();
    // Scene
    const scene = new THREE.Scene();
    applyProps(scene, sceneOptions);
    // Camera
    const isCamera = cameraOptions instanceof THREE.Camera;
    const camera = isCamera
        ? cameraOptions
        : orthographic
            ? new THREE.OrthographicCamera(0, 0, 0, 0, 0.1, 1000)
            : new THREE.PerspectiveCamera(75, size.width / size.height, 0.1, 1000);
    if (!isCamera) {
        camera.position.z = 5;
        if (cameraOptions) {
            applyProps(camera, cameraOptions);
            // Update projection matrix after applying props
            camera.updateProjectionMatrix();
        }
        // look at center if initial rotation isn't set
        if (!cameraOptions?.rotation)
            camera.lookAt(0, 0, 0);
    }
    // Raycaster
    const raycaster = new THREE.Raycaster();
    const { params, ...options } = raycasterOptions || {};
    applyProps(raycaster, {
        enabled: true,
        ...options,
        params: { ...raycaster.params, ...params },
    });
    // Renderer
    const customRenderer = (typeof glOptions === 'function' ? glOptions(canvasElement) : glOptions);
    // userland custom renderer, assign as-is
    if (!!customRenderer?.render) {
        this.set({
            renderer: customRenderer,
            scene,
            camera,
            raycaster: raycaster,
        });
        return;
    }
    const renderer = new THREE.WebGLRenderer({
        powerPreference: 'high-performance',
        canvas: canvasElement,
        antialias: true,
        alpha: true,
        ...(glOptions || {}),
    });
    if (glOptions) {
        applyProps(renderer, glOptions);
    }
    if (shadows) {
        renderer.shadowMap.enabled = true;
        if (typeof shadows === 'object') {
            Object.assign(renderer.shadowMap, shadows);
        }
        else {
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
    }
    if (!linear) {
        // auto color management
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
    }
    else {
        renderer.outputEncoding = THREE.LinearEncoding;
    }
    if (flat) {
        renderer.toneMapping = THREE.NoToneMapping;
    }
    renderer.setClearAlpha(0);
    renderer.setPixelRatio(calculateDpr(viewport.dpr));
    renderer.setSize(size.width, size.height);
    if (vr) {
        renderer.xr.enabled = true;
    }
    this.set({
        renderer,
        scene,
        camera,
        raycaster: raycaster,
    });
    return () => {
        const { renderer, vr } = this.get();
        if (renderer) {
            renderer.renderLists.dispose();
            renderer.forceContextLoss();
            if (vr) {
                renderer.setAnimationLoop(null);
            }
        }
    };
}, _NgtStore_updateDimensions = function _NgtStore_updateDimensions({ size, viewport, }) {
    const { camera, renderer, ready, cameraOptions } = this.get();
    if (ready) {
        // update renderer
        renderer.setPixelRatio(viewport.dpr);
        renderer.setSize(size.width, size.height);
        // leave the userland camera alone
        if (cameraOptions instanceof THREE.Camera)
            return;
        if (isOrthographicCamera(camera)) {
            camera.left = size.width / -2;
            camera.right = size.width / 2;
            camera.top = size.height / 2;
            camera.bottom = size.height / -2;
        }
        else {
            camera.aspect = size.width / size.height;
        }
        camera.updateProjectionMatrix();
        // https://github.com/pmndrs/react-three-fiber/issues/178
        // Update matrix world since the renderer is a frame late
        camera.updateMatrixWorld();
    }
};
NgtStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtStore, deps: [{ token: NGT_PERFORMANCE_OPTIONS }, { token: i0.ElementRef }, { token: NgtResize }], target: i0.ɵɵFactoryTarget.Injectable });
NgtStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [NGT_PERFORMANCE_OPTIONS]
                }] }, { type: i0.ElementRef }, { type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [NgtResize]
                }] }]; } });

var _NgtLoopService_running, _NgtLoopService_repeat, _NgtLoopService_frames;
class NgtLoopService {
    constructor(store, animationFrameStore, ngZone) {
        this.store = store;
        this.animationFrameStore = animationFrameStore;
        this.ngZone = ngZone;
        _NgtLoopService_running.set(this, false);
        _NgtLoopService_repeat.set(this, void 0);
        _NgtLoopService_frames.set(this, 1);
    }
    render(timestamp, state, animationFrameState) {
        return this.ngZone.runOutsideAngular(() => {
            const { clock, frameloop, camera, scene, renderer, mouse, size, viewport, } = state;
            const { subscribers, hasPriority } = animationFrameState;
            if (renderer) {
                let delta = clock.getDelta();
                // In frameloop='never' mode, clock times are updated using the provided timestamp
                if (frameloop === 'never' && typeof timestamp === 'number') {
                    delta = timestamp - clock.elapsedTime;
                    clock.oldTime = clock.elapsedTime;
                    clock.elapsedTime = timestamp;
                }
                const renderState = {
                    clock,
                    camera,
                    scene,
                    renderer,
                    mouse,
                    size,
                    viewport,
                    delta,
                };
                for (const subscriber of subscribers) {
                    subscriber.callback(renderState, subscriber.obj);
                }
                if (!hasPriority) {
                    renderer.render(scene, camera);
                }
            }
            __classPrivateFieldSet(this, _NgtLoopService_frames, Math.max(0, __classPrivateFieldGet(this, _NgtLoopService_frames, "f") - 1), "f");
            return state.frameloop === 'always' ? 1 : __classPrivateFieldGet(this, _NgtLoopService_frames, "f");
        });
    }
    loop(timestamp) {
        return this.ngZone.runOutsideAngular(() => {
            __classPrivateFieldSet(this, _NgtLoopService_running, true, "f");
            __classPrivateFieldSet(this, _NgtLoopService_repeat, 0, "f");
            const state = this.store.get();
            if (state.ready && (state.frameloop === 'always' || __classPrivateFieldGet(this, _NgtLoopService_frames, "f") > 0)) {
                __classPrivateFieldSet(this, _NgtLoopService_repeat, __classPrivateFieldGet(this, _NgtLoopService_repeat, "f") + this.render(timestamp, state, this.animationFrameStore.get()), "f");
            }
            if (__classPrivateFieldGet(this, _NgtLoopService_repeat, "f") > 0)
                return requestAnimationFrame(this.loop.bind(this));
            __classPrivateFieldSet(this, _NgtLoopService_running, false, "f");
            return;
        });
    }
    invalidate(state = this.store.get()) {
        if (state.vr) {
            state.renderer?.setAnimationLoop((timestamp) => {
                this.render(timestamp, this.store.get(), this.animationFrameStore.get());
            });
            return;
        }
        if (!state.ready || state.frameloop === 'never')
            return;
        // Increase frames, do not go higher than 60
        __classPrivateFieldSet(this, _NgtLoopService_frames, Math.min(60, __classPrivateFieldGet(this, _NgtLoopService_frames, "f") + 1), "f");
        // If the render-loop isn't active, start it
        if (!__classPrivateFieldGet(this, _NgtLoopService_running, "f")) {
            __classPrivateFieldSet(this, _NgtLoopService_running, true, "f");
            requestAnimationFrame(this.loop.bind(this));
        }
    }
}
_NgtLoopService_running = new WeakMap(), _NgtLoopService_repeat = new WeakMap(), _NgtLoopService_frames = new WeakMap();
NgtLoopService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtLoopService, deps: [{ token: NgtStore }, { token: NgtAnimationFrameStore }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
NgtLoopService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtLoopService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtLoopService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: NgtStore }, { type: NgtAnimationFrameStore }, { type: i0.NgZone }]; } });

/**
 * From r3f https://github.com/pmndrs/react-three-fiber/blob/master/packages/fiber/src/core/events.ts
 */
/** Release pointer captures.
 * This is called by releasePointerCapture in the API, and when an object is removed.
 */
function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {
    const captureData = captures.get(obj);
    if (captureData) {
        captures.delete(obj);
        // If this was the last capturing object for this pointer
        if (captures.size === 0) {
            capturedMap.delete(pointerId);
            captureData.target.releasePointerCapture(pointerId);
        }
    }
}
function removeInteractivity(eventsStateGetter, object) {
    const { internal } = eventsStateGetter();
    // Removes every trace of an object from the data store
    internal.interaction = internal.interaction.filter((o) => o !== object);
    internal.initialHits = internal.initialHits.filter((o) => o !== object);
    internal.hovered.forEach((value, key) => {
        if (value.eventObject === object || value.object === object) {
            internal.hovered.delete(key);
        }
    });
    internal.capturedMap.forEach((captures, pointerId) => {
        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);
    });
}
function getRenderState(state) {
    const { mouse, camera, clock, renderer, scene, size, viewport } = state;
    const delta = clock.getDelta();
    return {
        size,
        mouse,
        camera: camera,
        delta,
        clock,
        renderer: renderer,
        scene: scene,
        viewport,
    };
}
function createEvents(stateGetter, eventsStateGetter) {
    const temp = new THREE.Vector3();
    /** Sets up defaultRaycaster */
    function prepareRay(event) {
        const state = stateGetter();
        const { raycaster, mouse, camera, size } = state;
        // https://github.com/pmndrs/react-three-fiber/pull/782
        // Events trigger outside of canvas when moved
        if (raycaster && camera) {
            const { offsetX, offsetY } = raycaster?.computeOffsets?.(event, getRenderState(state)) ?? event;
            const { width, height } = size;
            mouse.set((offsetX / width) * 2 - 1, -(offsetY / height) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
        }
    }
    /** Calculates delta */
    function calculateDistance(event) {
        const { internal } = eventsStateGetter();
        const dx = event.offsetX - internal.initialClick[0];
        const dy = event.offsetY - internal.initialClick[1];
        return Math.round(Math.sqrt(dx * dx + dy * dy));
    }
    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */
    function filterPointerEvents(objects) {
        return objects.filter((obj) => ['move', 'over', 'enter', 'out', 'leave'].some((name) => obj.__ngt?.handlers?.[('pointer' + name)]));
    }
    function intersect(filter) {
        const canvasState = stateGetter();
        const { internal } = eventsStateGetter();
        const { raycaster } = canvasState;
        // Skip event handling when noEvents is set
        if (!raycaster?.enabled)
            return [];
        const seen = new Set();
        const intersections = [];
        // Allow callers to eliminate event objects
        const eventsObjects = filter
            ? filter(internal.interaction)
            : internal.interaction;
        // Intersect known handler objects and filter against duplicates
        let intersects = raycaster
            .intersectObjects(eventsObjects, true)
            .filter((item) => {
            const id = makeId(item);
            if (seen.has(id))
                return false;
            seen.add(id);
            return true;
        });
        // https://github.com/mrdoob/three.js/issues/16031
        // Allow custom userland intersect sort order
        if (raycaster.filter)
            intersects = raycaster.filter(intersects, getRenderState(canvasState));
        for (const intersect of intersects) {
            let eventObject = intersect.object;
            // Bubble event up
            while (eventObject) {
                if (eventObject.__ngt?.eventCount)
                    intersections.push({ ...intersect, eventObject });
                eventObject = eventObject.parent;
            }
        }
        return intersections;
    }
    /**  Creates filtered intersects and returns an array of positive hits */
    function patchIntersects(intersections, event) {
        const { internal } = eventsStateGetter();
        // If the interaction is captured, make all capturing targets  part of the
        // intersect.
        if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {
            for (let captureData of internal.capturedMap
                .get(event.pointerId)
                .values()) {
                intersections.push(captureData.intersection);
            }
        }
        return intersections;
    }
    function cancelPointer(hits) {
        const { internal } = eventsStateGetter();
        Array.from(internal.hovered.values()).forEach((hoveredObj) => {
            // When no objects were hit or the the hovered object wasn't found underneath the cursor
            // we call onPointerOut and delete the object from the hovered-elements map
            if (!hits.length ||
                !hits.find((hit) => hit.object === hoveredObj.object &&
                    hit.index === hoveredObj.index &&
                    hit.instanceId === hoveredObj.instanceId)) {
                const eventObject = hoveredObj.eventObject;
                const instance = eventObject.__ngt;
                const handlers = instance?.handlers;
                internal.hovered.delete(makeId(hoveredObj));
                if (instance?.eventCount) {
                    // Clear out intersects, they are outdated by now
                    const data = { ...hoveredObj, intersections: hits || [] };
                    handlers?.pointerout?.(data);
                    handlers?.pointerleave?.(data);
                }
            }
        });
    }
    /**  Handles intersections by forwarding them to handlers */
    function handleIntersects(intersections, event, delta, callback) {
        const { raycaster, mouse, camera } = stateGetter();
        const { internal } = eventsStateGetter();
        // If anything has been found, forward it to the event listeners
        if (intersections.length && camera) {
            const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);
            const localState = { stopped: false };
            for (const hit of intersections) {
                const hasPointerCapture = (id) => internal.capturedMap.get(id)?.has(hit.eventObject) ?? false;
                const setPointerCapture = (id) => {
                    const captureData = {
                        intersection: hit,
                        target: event.target,
                    };
                    if (internal.capturedMap.has(id)) {
                        // if the pointerId was previously captured, we add the hit to the
                        // event capturedMap.
                        internal.capturedMap.get(id).set(hit.eventObject, captureData);
                    }
                    else {
                        // if the pointerId was not previously captured, we create a map
                        // containing the hitObject, and the hit. hitObject is used for
                        // faster access.
                        internal.capturedMap.set(id, new Map([[hit.eventObject, captureData]]));
                    }
                    // Call the original event now
                    event.target.setPointerCapture(id);
                };
                const releasePointerCapture = (id) => {
                    const captures = internal.capturedMap.get(id);
                    if (captures) {
                        releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);
                    }
                };
                // Add native event props
                let extractEventProps = {};
                // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return "own" properties; nor Object.getPrototypeOf(event) as that *doesn't* return "own" properties, only inherited ones.
                for (let prop in event) {
                    let property = event[prop];
                    // Only copy over atomics, leave functions alone as these should be
                    // called as event.nativeEvent.fn()
                    if (typeof property !== 'function')
                        extractEventProps[prop] = property;
                }
                let raycastEvent = {
                    ...hit,
                    ...extractEventProps,
                    spaceX: mouse.x,
                    spaceY: mouse.y,
                    intersections,
                    stopped: localState.stopped,
                    delta,
                    unprojectedPoint,
                    ray: raycaster?.ray,
                    camera: camera,
                    // Hijack stopPropagation, which just sets a flag
                    stopPropagation: () => {
                        // https://github.com/pmndrs/react-three-fiber/issues/596
                        // Events are not allowed to stop propagation if the pointer has been captured
                        const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId);
                        // We only authorize stopPropagation...
                        if (
                        // ...if this pointer hasn't been captured
                        !capturesForPointer ||
                            // ... or if the hit object is capturing the pointer
                            capturesForPointer.has(hit.eventObject)) {
                            raycastEvent.stopped = localState.stopped = true;
                            // Propagation is stopped, remove all other hover records
                            // An event handler is only allowed to flush other handlers if it is hovered itself
                            if (internal.hovered.size &&
                                Array.from(internal.hovered.values()).find((i) => i.eventObject === hit.eventObject)) {
                                // Objects cannot flush out higher up objects that have already caught the event
                                const higher = intersections.slice(0, intersections.indexOf(hit));
                                cancelPointer([...higher, hit]);
                            }
                        }
                    },
                    // there should be a distinction between target and currentTarget
                    target: {
                        hasPointerCapture,
                        setPointerCapture,
                        releasePointerCapture,
                    },
                    currentTarget: {
                        hasPointerCapture,
                        setPointerCapture,
                        releasePointerCapture,
                    },
                    sourceEvent: event,
                    nativeEvent: event,
                };
                // Call subscribers
                callback(raycastEvent);
                // Event bubbling may be interrupted by stopPropagation
                if (localState.stopped)
                    break;
            }
        }
        return intersections;
    }
    const handlePointer = (name) => {
        // Deal with cancelation
        switch (name) {
            case 'pointerleave':
            case 'pointercancel':
                return () => cancelPointer([]);
            case 'lostpointercapture':
                return (event) => {
                    const { internal: { capturedMap }, } = eventsStateGetter();
                    if ('pointerId' in event && !capturedMap.has(event.pointerId)) {
                        // If the object event interface had onLostPointerCapture, we'd call it here on every
                        // object that's getting removed.
                        capturedMap.delete(event.pointerId);
                        cancelPointer([]);
                    }
                };
        }
        // Any other pointer goes here ...
        return (event) => {
            const { pointerMissed, internal } = eventsStateGetter();
            prepareRay(event);
            // Get fresh intersects
            const isPointerMove = name === 'pointermove';
            const isClickEvent = name === 'click' || name === 'contextmenu' || name === 'dblclick';
            const filter = isPointerMove ? filterPointerEvents : undefined;
            const hits = patchIntersects(intersect(filter), event);
            const delta = isClickEvent ? calculateDistance(event) : 0;
            // Save initial coordinates on pointer-down
            if (name === 'pointerdown') {
                internal.initialClick = [event.offsetX, event.offsetY];
                internal.initialHits = hits.map((hit) => hit.eventObject);
            }
            // If a click yields no results, pass it back to the user as a miss
            // Missed events have to come first in order to establish user-land side-effect clean up
            if (isClickEvent && !hits.length) {
                if (delta <= 2) {
                    objectPointerMissed(event, internal.interaction);
                    if (pointerMissed)
                        pointerMissed(event);
                }
            }
            // Take care of unhover
            if (isPointerMove)
                cancelPointer(hits);
            handleIntersects(hits, event, delta, (data) => {
                const eventObject = data.eventObject;
                const instance = eventObject.__ngt;
                const handlers = instance?.handlers;
                // Check presence of handlers
                if (!instance?.eventCount)
                    return;
                if (isPointerMove) {
                    // Move event ...
                    if (handlers?.pointerover ||
                        handlers?.pointerenter ||
                        handlers?.pointerout ||
                        handlers?.pointerleave) {
                        // When enter or out is present take care of hover-state
                        const id = makeId(data);
                        const hoveredItem = internal.hovered.get(id);
                        if (!hoveredItem) {
                            // If the object wasn't previously hovered, book it and call its handler
                            internal.hovered.set(id, data);
                            handlers.pointerover?.(data);
                            handlers.pointerenter?.(data);
                        }
                        else if (hoveredItem.stopped) {
                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed
                            data.stopPropagation();
                        }
                    }
                    // Call mouse move
                    handlers?.pointermove?.(data);
                }
                else {
                    // All other events ...
                    const handler = handlers?.[name];
                    if (handler) {
                        // Forward all events back to their respective handlers with the exception of click events,
                        // which must use the initial target
                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {
                            // Missed events have to come first
                            objectPointerMissed(event, internal.interaction.filter((object) => !internal.initialHits.includes(object)));
                            // Now call the handler
                            handler(data);
                        }
                    }
                }
            });
        };
    };
    function objectPointerMissed(event, objects) {
        objects.forEach((object) => object.__ngt?.handlers?.pointermissed?.(event));
    }
    return { handlePointer };
}

var _NgtEventsStore_instances, _NgtEventsStore_connect;
const names = {
    click: false,
    contextmenu: false,
    dblclick: false,
    wheel: false,
    pointerdown: true,
    pointerup: true,
    pointerleave: true,
    pointermove: true,
    pointercancel: true,
    lostpointercapture: true,
};
class NgtEventsStore extends EnhancedRxState {
    constructor(store, ngZone) {
        super();
        this.store = store;
        this.ngZone = ngZone;
        _NgtEventsStore_instances.add(this);
        this.actions = this.create();
        this.set({
            pointerMissed: noop,
            connected: false,
            handlers: {},
            internal: {
                interaction: [],
                hovered: new Map(),
                capturedMap: new Map(),
                initialClick: [0, 0],
                initialHits: [],
            },
        });
        ngZone.runOutsideAngular(() => {
            const { handlePointer } = createEvents(this.store.get.bind(this.store), this.get.bind(this));
            this.set({
                handlers: Object.keys(names).reduce((handlers, supportedEventName) => {
                    handlers[supportedEventName] = handlePointer(supportedEventName);
                    return handlers;
                }, {}),
            });
            this.holdEffect(this.actions.element$, __classPrivateFieldGet(this, _NgtEventsStore_instances, "m", _NgtEventsStore_connect).bind(this));
        });
    }
    addInteraction(interaction) {
        this.set((state) => ({
            ...state,
            internal: {
                ...state.internal,
                interaction: [...state.internal.interaction, interaction],
            },
        }));
    }
    removeInteraction(uuid) {
        this.set((state) => ({
            ...state,
            internal: {
                ...state.internal,
                interaction: state.internal.interaction.filter((interaction) => interaction.uuid !== uuid),
            },
        }));
    }
}
_NgtEventsStore_instances = new WeakSet(), _NgtEventsStore_connect = function _NgtEventsStore_connect(element) {
    return this.ngZone.runOutsideAngular(() => {
        this.set({ connected: element });
        const handlers = this.get('handlers');
        Object.entries(handlers ?? {}).forEach(([eventName, handler]) => {
            const passive = names[eventName];
            element.addEventListener(eventName, handler, { passive });
        });
        return () => {
            const { handlers, connected } = this.get();
            if (connected) {
                Object.entries(handlers ?? {}).forEach(([eventName, handler]) => {
                    if (connected instanceof HTMLElement) {
                        connected.removeEventListener(eventName, handler);
                    }
                });
            }
        };
    });
};
NgtEventsStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtEventsStore, deps: [{ token: NgtStore }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
NgtEventsStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtEventsStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtEventsStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: NgtStore }, { type: i0.NgZone }]; } });

let performanceTimeout = undefined;
class NgtPerformanceStore extends EnhancedRxState {
    constructor(store) {
        super();
        this.connect(store.select('performance'));
    }
    regress() {
        const { current, min, debounce } = this.get();
        // Clear timeout
        if (performanceTimeout)
            clearTimeout(performanceTimeout);
        // Set lower bound performance
        if (current !== min)
            this.set({ min });
        // Go back to upper bound performance after a while unless something regresses meanwhile
        performanceTimeout = setTimeout(() => {
            this.set({ current: this.get('max') });
        }, debounce);
    }
}
NgtPerformanceStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtPerformanceStore, deps: [{ token: NgtStore }], target: i0.ɵɵFactoryTarget.Injectable });
NgtPerformanceStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtPerformanceStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtPerformanceStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: NgtStore }]; } });

class NgtCanvas extends EnhancedRxState {
    constructor(store, performanceStore, eventsStore, animationFrameStore, loopService, ngZone, canvasOptions) {
        super();
        this.store = store;
        this.performanceStore = performanceStore;
        this.eventsStore = eventsStore;
        this.animationFrameStore = animationFrameStore;
        this.loopService = loopService;
        this.ngZone = ngZone;
        this.canvasOptions = canvasOptions;
        this.hostClass = true;
        this.created = new EventEmitter();
        this.pointermissed = new EventEmitter();
    }
    set vr(vr) {
        this.store.set({ vr: vr === '' ? true : vr });
    }
    set linear(linear) {
        this.store.set({ linear: linear === '' ? true : linear });
    }
    set flat(flat) {
        this.store.set({ flat: flat === '' ? true : flat });
    }
    set frameloop(frameloop) {
        this.store.set({ frameloop });
    }
    set orthographic(orthographic) {
        this.store.set({ orthographic: orthographic === '' ? true : orthographic });
    }
    set performance(performance) {
        this.store.set({ performance });
    }
    set size(size) {
        this.store.set({ size });
    }
    set dpr(dpr) {
        this.store.set({ dpr });
    }
    set clock(clock) {
        this.store.set({ clock });
    }
    set raycaster(raycaster) {
        this.store.set({ raycasterOptions: raycaster });
    }
    set shadows(shadows) {
        this.store.set({ shadows });
    }
    set camera(cameraOptions) {
        this.store.set({ cameraOptions });
    }
    set scene(sceneOptions) {
        this.store.set({ sceneOptions });
    }
    set gl(glOptions) {
        this.store.set({ glOptions });
    }
    set rendererCanvas(v) {
        this.store.actions.canvasElement(v.nativeElement);
    }
    ngOnInit() {
        // if there is handler to pointermissed on the canvas
        // update pointermissed in events store so that
        // events util will handle it
        if (this.pointermissed.observed) {
            this.eventsStore.set({
                pointerMissed: (event) => {
                    this.pointermissed.emit(event);
                },
            });
        }
        this.hold(this.store.select('ready'), (ready) => {
            if (ready) {
                this.ngZone.runOutsideAngular(() => {
                    const state = this.store.get();
                    this.eventsStore.actions.element(state.renderer.domElement);
                    this.loopService.invalidate(state);
                    this.created.emit(state);
                });
            }
        });
    }
}
NgtCanvas.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCanvas, deps: [{ token: NgtStore, self: true }, { token: NgtPerformanceStore, self: true }, { token: NgtEventsStore, self: true }, { token: NgtAnimationFrameStore, self: true }, { token: NgtLoopService, self: true }, { token: i0.NgZone }, { token: NGT_CANVAS_OPTIONS }], target: i0.ɵɵFactoryTarget.Component });
NgtCanvas.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtCanvas, selector: "ngt-canvas", inputs: { vr: "vr", linear: "linear", flat: "flat", frameloop: "frameloop", orthographic: "orthographic", performance: "performance", size: "size", dpr: "dpr", clock: "clock", raycaster: "raycaster", shadows: "shadows", camera: "camera", scene: "scene", gl: "gl" }, outputs: { created: "created", pointermissed: "pointermissed" }, host: { properties: { "class.ngt-canvas": "this.hostClass" } }, providers: [
        NgtResize,
        NgtStore,
        NgtPerformanceStore,
        NgtEventsStore,
        NgtAnimationFrameStore,
        NgtLoopService,
    ], viewQueries: [{ propertyName: "rendererCanvas", first: true, predicate: ["rendererCanvas"], descendants: true }], usesInheritance: true, ngImport: i0, template: `
    <canvas #rendererCanvas></canvas>
    <ng-container *ngIf="canvasOptions.projectContent">
      <ng-content></ng-content>
    </ng-container>
  `, isInline: true, styles: [":host{display:block;position:relative;width:100%;height:100%;overflow:hidden}:host canvas{display:block}\n"], directives: [{ type: i6.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCanvas, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-canvas',
                    template: `
    <canvas #rendererCanvas></canvas>
    <ng-container *ngIf="canvasOptions.projectContent">
      <ng-content></ng-content>
    </ng-container>
  `,
                    styles: [
                        `
      :host {
        display: block;
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      :host canvas {
        display: block;
      }
    `,
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NgtResize,
                        NgtStore,
                        NgtPerformanceStore,
                        NgtEventsStore,
                        NgtAnimationFrameStore,
                        NgtLoopService,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: NgtStore, decorators: [{
                    type: Self
                }] }, { type: NgtPerformanceStore, decorators: [{
                    type: Self
                }] }, { type: NgtEventsStore, decorators: [{
                    type: Self
                }] }, { type: NgtAnimationFrameStore, decorators: [{
                    type: Self
                }] }, { type: NgtLoopService, decorators: [{
                    type: Self
                }] }, { type: i0.NgZone }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NGT_CANVAS_OPTIONS]
                }] }]; }, propDecorators: { hostClass: [{
                type: HostBinding,
                args: ['class.ngt-canvas']
            }], vr: [{
                type: Input
            }], linear: [{
                type: Input
            }], flat: [{
                type: Input
            }], frameloop: [{
                type: Input
            }], orthographic: [{
                type: Input
            }], performance: [{
                type: Input
            }], size: [{
                type: Input
            }], dpr: [{
                type: Input
            }], clock: [{
                type: Input
            }], raycaster: [{
                type: Input
            }], shadows: [{
                type: Input
            }], camera: [{
                type: Input
            }], scene: [{
                type: Input
            }], gl: [{
                type: Input
            }], created: [{
                type: Output
            }], pointermissed: [{
                type: Output
            }], rendererCanvas: [{
                type: ViewChild,
                args: ['rendererCanvas']
            }] } });

class NgtCoreModule {
}
NgtCoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtCoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCoreModule, declarations: [NgtCanvas], imports: [CommonModule], exports: [NgtCanvas] });
NgtCoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCoreModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCoreModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtCanvas],
                    imports: [CommonModule],
                    exports: [NgtCanvas],
                }]
        }] });

class NgtDestroyedService extends Subject {
    ngOnDestroy() {
        this.next();
        this.complete();
    }
}
NgtDestroyedService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtDestroyedService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
NgtDestroyedService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtDestroyedService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtDestroyedService, decorators: [{
            type: Injectable
        }] });

var _Controller_instances, _Controller_readyFn, _Controller_assignProps;
class Controller {
    constructor(ngZone) {
        this.ngZone = ngZone;
        _Controller_instances.add(this);
        this.disabled = false;
        this.change$ = new ReplaySubject(1);
        _Controller_readyFn.set(this, void 0);
    }
    set readyFn(v) {
        __classPrivateFieldSet(this, _Controller_readyFn, v, "f");
    }
    get readyFn() {
        return __classPrivateFieldGet(this, _Controller_readyFn, "f");
    }
    ngOnChanges(changes) {
        if (this.controller) {
            __classPrivateFieldGet(this, _Controller_instances, "m", _Controller_assignProps).call(this);
            this.controller.ngOnChanges(changes);
            this.change$.next(changes);
        }
        else {
            this.change$.next(changes);
        }
    }
    ngOnInit() {
        if (this.controller) {
            __classPrivateFieldGet(this, _Controller_instances, "m", _Controller_assignProps).call(this);
        }
    }
}
_Controller_readyFn = new WeakMap(), _Controller_instances = new WeakSet(), _Controller_assignProps = function _Controller_assignProps() {
    this.ngZone.runOutsideAngular(() => {
        this.props.forEach((prop) => {
            const selfController = this;
            const inputController = this.controller;
            selfController[prop] = selfController[prop] ?? inputController[prop];
        });
    });
};
Controller.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: Controller, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
Controller.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: Controller, inputs: { disabled: "disabled" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: Controller, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; }, propDecorators: { disabled: [{
                type: Input
            }] } });
function controllerFactory(newInstanceOnNull = false, controllerType) {
    return (controller, changeDetectorRef, destroyed) => {
        if (!controller) {
            return newInstanceOnNull ? new controllerType() : null;
        }
        controller.change$.pipe(takeUntil(destroyed)).subscribe(() => {
            changeDetectorRef.markForCheck();
        });
        return controller;
    };
}
function createControllerProviderFactory({ watchedControllerTokenName, controller, newInstanceOnNull = false, }) {
    const watchedControllerToken = new InjectionToken(watchedControllerTokenName);
    const controllerProvider = [
        NgtDestroyedService,
        {
            provide: watchedControllerToken,
            deps: [
                [new Optional(), controller],
                ChangeDetectorRef,
                NgtDestroyedService,
            ],
            useFactory: controllerFactory(newInstanceOnNull, controller),
        },
    ];
    return [watchedControllerToken, controllerProvider];
}

var _NgtAnimationSubscriberController_subscriber;
class NgtAnimationSubscriberController extends Controller {
    constructor(animationFrameStore, ngZone) {
        super(ngZone);
        this.animationFrameStore = animationFrameStore;
        this.priority = 0;
        this.animateReady = new EventEmitter();
        _NgtAnimationSubscriberController_subscriber.set(this, void 0);
    }
    prepare(obj) {
        // only subscribe to animation frame if there's an output handler
        if (this.animateReady.observed) {
            __classPrivateFieldSet(this, _NgtAnimationSubscriberController_subscriber, obj, "f");
            this.animationFrameStore.register({
                obj,
                callback: this.animateReady.emit.bind(this.animateReady),
                priority: this.priority,
            });
        }
    }
    ngOnDestroy() {
        if (__classPrivateFieldGet(this, _NgtAnimationSubscriberController_subscriber, "f")) {
            this.animationFrameStore.actions.unsubscriberUuid(__classPrivateFieldGet(this, _NgtAnimationSubscriberController_subscriber, "f").uuid);
        }
    }
    get controller() {
        return undefined;
    }
    get props() {
        return [];
    }
}
_NgtAnimationSubscriberController_subscriber = new WeakMap();
NgtAnimationSubscriberController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAnimationSubscriberController, deps: [{ token: NgtAnimationFrameStore }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgtAnimationSubscriberController.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtAnimationSubscriberController, selector: "[animateReady]", inputs: { priority: "priority" }, outputs: { animateReady: "animateReady" }, exportAs: ["ngtAnimationSubscriberController"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAnimationSubscriberController, decorators: [{
            type: Directive,
            args: [{
                    selector: '[animateReady]',
                    exportAs: 'ngtAnimationSubscriberController',
                }]
        }], ctorParameters: function () { return [{ type: NgtAnimationFrameStore }, { type: i0.NgZone }]; }, propDecorators: { priority: [{
                type: Input
            }], animateReady: [{
                type: Output
            }] } });
class NgtAnimationSubscriberControllerModule {
}
NgtAnimationSubscriberControllerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAnimationSubscriberControllerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtAnimationSubscriberControllerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAnimationSubscriberControllerModule, declarations: [NgtAnimationSubscriberController], exports: [NgtAnimationSubscriberController] });
NgtAnimationSubscriberControllerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAnimationSubscriberControllerModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAnimationSubscriberControllerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtAnimationSubscriberController],
                    exports: [NgtAnimationSubscriberController],
                }]
        }] });
const [NGT_ANIMATION_SUBSCRIBER_WATCHED_CONTROLLER, NGT_ANIMATION_SUBSCRIBER_CONTROLLER_PROVIDER,] = createControllerProviderFactory({
    watchedControllerTokenName: 'Watched AnimationSubscriberController',
    controller: NgtAnimationSubscriberController,
});

function makeVector2(input) {
    if (!input)
        return undefined;
    if (input instanceof THREE.Vector2) {
        return input;
    }
    if (Array.isArray(input)) {
        return new THREE.Vector2(...input);
    }
    return new THREE.Vector2(input, input);
}
function makeVector3(input) {
    if (!input)
        return undefined;
    if (input instanceof THREE.Vector3) {
        return input;
    }
    if (Array.isArray(input)) {
        return new THREE.Vector3(...input);
    }
    return new THREE.Vector3(input, input, input);
}
function makeVector4(input) {
    if (!input)
        return undefined;
    if (input instanceof THREE.Vector4) {
        return input;
    }
    if (Array.isArray(input)) {
        return new THREE.Vector4(...input);
    }
    return new THREE.Vector4(input, input, input, input);
}
function makeForSet(type, input) {
    if (!input)
        return undefined;
    if (input instanceof type) {
        return input;
    }
    return new type(...input);
}
function makeColor(color) {
    if (!color)
        return undefined;
    if (color instanceof THREE.Color) {
        return color;
    }
    if (Array.isArray(color)) {
        return new THREE.Color(...color);
    }
    return new THREE.Color(color);
}

var _NgtObject3dInputsController_position, _NgtObject3dInputsController_rotation, _NgtObject3dInputsController_quaternion, _NgtObject3dInputsController_scale, _NgtObject3dInputsController_color;
class NgtObject3dInputsController extends Controller {
    constructor() {
        super(...arguments);
        _NgtObject3dInputsController_position.set(this, void 0);
        _NgtObject3dInputsController_rotation.set(this, void 0);
        _NgtObject3dInputsController_quaternion.set(this, void 0);
        _NgtObject3dInputsController_scale.set(this, void 0);
        _NgtObject3dInputsController_color.set(this, void 0);
        this.castShadow = false;
        this.receiveShadow = false;
        this.visible = true;
        this.matrixAutoUpdate = true;
        this.appendMode = 'immediate';
        // events
        this.click = new EventEmitter();
        this.contextmenu = new EventEmitter();
        this.dblclick = new EventEmitter();
        this.pointerup = new EventEmitter();
        this.pointerdown = new EventEmitter();
        this.pointerover = new EventEmitter();
        this.pointerout = new EventEmitter();
        this.pointerenter = new EventEmitter();
        this.pointerleave = new EventEmitter();
        this.pointermove = new EventEmitter();
        this.pointermissed = new EventEmitter();
        this.pointercancel = new EventEmitter();
        this.wheel = new EventEmitter();
    }
    set position(position) {
        __classPrivateFieldSet(this, _NgtObject3dInputsController_position, makeVector3(position), "f");
    }
    get position() {
        return __classPrivateFieldGet(this, _NgtObject3dInputsController_position, "f");
    }
    set rotation(rotation) {
        __classPrivateFieldSet(this, _NgtObject3dInputsController_rotation, makeForSet(THREE.Euler, rotation), "f");
    }
    get rotation() {
        return __classPrivateFieldGet(this, _NgtObject3dInputsController_rotation, "f");
    }
    set quaternion(quaternion) {
        __classPrivateFieldSet(this, _NgtObject3dInputsController_quaternion, makeForSet(THREE.Quaternion, quaternion), "f");
    }
    get quaternion() {
        return __classPrivateFieldGet(this, _NgtObject3dInputsController_quaternion, "f");
    }
    set scale(scale) {
        __classPrivateFieldSet(this, _NgtObject3dInputsController_scale, makeVector3(scale), "f");
    }
    get scale() {
        return __classPrivateFieldGet(this, _NgtObject3dInputsController_scale, "f");
    }
    set color(color) {
        __classPrivateFieldSet(this, _NgtObject3dInputsController_color, makeColor(color), "f");
    }
    get color() {
        return __classPrivateFieldGet(this, _NgtObject3dInputsController_color, "f");
    }
    get props() {
        return [
            'name',
            'position',
            'rotation',
            'quaternion',
            'scale',
            'color',
            'userData',
            'dispose',
            'raycast',
            'castShadow',
            'receiveShadow',
            'visible',
            'matrixAutoUpdate',
            'appendMode',
            'appendTo',
            'click',
            'contextmenu',
            'dblclick',
            'pointerup',
            'pointerdown',
            'pointerover',
            'pointerout',
            'pointerenter',
            'pointerleave',
            'pointermove',
            'pointermissed',
            'pointercancel',
            'wheel',
        ];
    }
    get controller() {
        return this.object3dInputsController;
    }
    get object3dProps() {
        return {
            name: this.name,
            position: __classPrivateFieldGet(this, _NgtObject3dInputsController_position, "f")?.toArray(),
            rotation: __classPrivateFieldGet(this, _NgtObject3dInputsController_rotation, "f")?.toArray(),
            quaternion: __classPrivateFieldGet(this, _NgtObject3dInputsController_quaternion, "f")?.toArray(),
            scale: __classPrivateFieldGet(this, _NgtObject3dInputsController_scale, "f")?.toArray(),
            color: this.color,
            userData: this.userData,
            dispose: this.dispose,
            raycast: this.raycast,
            castShadow: this.castShadow,
            receiveShadow: this.receiveShadow,
            visible: this.visible,
            matrixAutoUpdate: this.matrixAutoUpdate,
        };
    }
}
_NgtObject3dInputsController_position = new WeakMap(), _NgtObject3dInputsController_rotation = new WeakMap(), _NgtObject3dInputsController_quaternion = new WeakMap(), _NgtObject3dInputsController_scale = new WeakMap(), _NgtObject3dInputsController_color = new WeakMap();
NgtObject3dInputsController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObject3dInputsController, deps: null, target: i0.ɵɵFactoryTarget.Directive });
NgtObject3dInputsController.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtObject3dInputsController, selector: "\n    ngt-primitive,\n    ngt-bone,\n    ngt-group,\n    ngt-lod,\n    ngt-points,\n    ngt-mesh,\n    ngt-instanced-mesh,\n    ngt-skinned-mesh,\n    ngt-audio,\n    ngt-positional-audio,\n    ngt-line,\n    ngt-line-loop,\n    ngt-line-segments,\n    ngt-light-probe,\n    ngt-ambient-light,\n    ngt-ambient-light-probe,\n    ngt-hemisphere-light,\n    ngt-hemisphere-light-probe,\n    ngt-directional-light,\n    ngt-point-light,\n    ngt-spot-light,\n    ngt-rect-area-light,\n    ngt-arrow-helper,\n    ngt-axes-helper,\n    ngt-box3-helper,\n    ngt-grid-helper,\n    ngt-plane-helper,\n    ngt-polar-grid-helper,\n    ngt-sprite,\n    ngt-camera,\n    ngt-perspective-camera,\n    ngt-orthographic-camera,\n    ngt-array-camera,\n    ngt-stereo-camera,\n    ngt-cube-camera,\n    ngt-soba-plane,\n    ngt-soba-box,\n    ngt-soba-cylinder,\n    ngt-soba-cone,\n    ngt-soba-circle,\n    ngt-soba-sphere,\n    ngt-soba-tube,\n    ngt-soba-torus,\n    ngt-soba-tetrahedron,\n    ngt-soba-ring,\n    ngt-soba-polyhedron,\n    ngt-soba-octahedron,\n    ngt-soba-dodecahedron,\n    ngt-soba-icosahedron,\n    ngt-soba-extrude,\n    ngt-soba-lathe,\n    ngt-soba-torus-knot,\n    ngt-soba-billboard,\n    ngt-soba-detailed,\n    ngt-soba-line,\n    ngt-soba-quadratic-bezier-line,\n    ngt-soba-cubic-bezier-line,\n    ngt-soba-orthographic-camera,\n    ngt-soba-gizmo-helper,\n    ngt-soba-gizmo-viewport,\n    ngt-soba-gizmo-axis-head,\n    ngt-soba-text\n  ", inputs: { name: "name", position: "position", rotation: "rotation", quaternion: "quaternion", scale: "scale", color: "color", userData: "userData", castShadow: "castShadow", receiveShadow: "receiveShadow", visible: "visible", matrixAutoUpdate: "matrixAutoUpdate", dispose: "dispose", raycast: "raycast", appendMode: "appendMode", appendTo: "appendTo", object3dInputsController: "object3dInputsController" }, outputs: { click: "click", contextmenu: "contextmenu", dblclick: "dblclick", pointerup: "pointerup", pointerdown: "pointerdown", pointerover: "pointerover", pointerout: "pointerout", pointerenter: "pointerenter", pointerleave: "pointerleave", pointermove: "pointermove", pointermissed: "pointermissed", pointercancel: "pointercancel", wheel: "wheel" }, exportAs: ["ngtObject3dInputsController"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObject3dInputsController, decorators: [{
            type: Directive,
            args: [{
                    selector: `
    ngt-primitive,
    ngt-bone,
    ngt-group,
    ngt-lod,
    ngt-points,
    ngt-mesh,
    ngt-instanced-mesh,
    ngt-skinned-mesh,
    ngt-audio,
    ngt-positional-audio,
    ngt-line,
    ngt-line-loop,
    ngt-line-segments,
    ngt-light-probe,
    ngt-ambient-light,
    ngt-ambient-light-probe,
    ngt-hemisphere-light,
    ngt-hemisphere-light-probe,
    ngt-directional-light,
    ngt-point-light,
    ngt-spot-light,
    ngt-rect-area-light,
    ngt-arrow-helper,
    ngt-axes-helper,
    ngt-box3-helper,
    ngt-grid-helper,
    ngt-plane-helper,
    ngt-polar-grid-helper,
    ngt-sprite,
    ngt-camera,
    ngt-perspective-camera,
    ngt-orthographic-camera,
    ngt-array-camera,
    ngt-stereo-camera,
    ngt-cube-camera,
    ngt-soba-plane,
    ngt-soba-box,
    ngt-soba-cylinder,
    ngt-soba-cone,
    ngt-soba-circle,
    ngt-soba-sphere,
    ngt-soba-tube,
    ngt-soba-torus,
    ngt-soba-tetrahedron,
    ngt-soba-ring,
    ngt-soba-polyhedron,
    ngt-soba-octahedron,
    ngt-soba-dodecahedron,
    ngt-soba-icosahedron,
    ngt-soba-extrude,
    ngt-soba-lathe,
    ngt-soba-torus-knot,
    ngt-soba-billboard,
    ngt-soba-detailed,
    ngt-soba-line,
    ngt-soba-quadratic-bezier-line,
    ngt-soba-cubic-bezier-line,
    ngt-soba-orthographic-camera,
    ngt-soba-gizmo-helper,
    ngt-soba-gizmo-viewport,
    ngt-soba-gizmo-axis-head,
    ngt-soba-text
  `,
                    exportAs: 'ngtObject3dInputsController',
                }]
        }], propDecorators: { name: [{
                type: Input
            }], position: [{
                type: Input
            }], rotation: [{
                type: Input
            }], quaternion: [{
                type: Input
            }], scale: [{
                type: Input
            }], color: [{
                type: Input
            }], userData: [{
                type: Input
            }], castShadow: [{
                type: Input
            }], receiveShadow: [{
                type: Input
            }], visible: [{
                type: Input
            }], matrixAutoUpdate: [{
                type: Input
            }], dispose: [{
                type: Input
            }], raycast: [{
                type: Input
            }], appendMode: [{
                type: Input
            }], appendTo: [{
                type: Input
            }], object3dInputsController: [{
                type: Input
            }], click: [{
                type: Output
            }], contextmenu: [{
                type: Output
            }], dblclick: [{
                type: Output
            }], pointerup: [{
                type: Output
            }], pointerdown: [{
                type: Output
            }], pointerover: [{
                type: Output
            }], pointerout: [{
                type: Output
            }], pointerenter: [{
                type: Output
            }], pointerleave: [{
                type: Output
            }], pointermove: [{
                type: Output
            }], pointermissed: [{
                type: Output
            }], pointercancel: [{
                type: Output
            }], wheel: [{
                type: Output
            }] } });
class NgtObject3dInputsControllerModule {
}
NgtObject3dInputsControllerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObject3dInputsControllerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtObject3dInputsControllerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObject3dInputsControllerModule, declarations: [NgtObject3dInputsController], exports: [NgtObject3dInputsController] });
NgtObject3dInputsControllerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObject3dInputsControllerModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObject3dInputsControllerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtObject3dInputsController],
                    exports: [NgtObject3dInputsController],
                }]
        }] });
const [NGT_OBJECT_INPUTS_WATCHED_CONTROLLER, NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,] = createControllerProviderFactory({
    watchedControllerTokenName: 'Watched Object3dInputsController',
    controller: NgtObject3dInputsController,
});

var _NgtObject3dController_instances, _NgtObject3dController_object3d, _NgtObject3dController_inputChangesSubscription, _NgtObject3dController_initFn, _NgtObject3dController_change$, _NgtObject3dController_objectReady, _NgtObject3dController_appendToParent, _NgtObject3dController_addToScene, _NgtObject3dController_addToParent, _NgtObject3dController_remove, _NgtObject3dController_eventNameToHandler, _NgtObject3dController_applyCustomProps;
const supportedEvents = [
    'click',
    'contextmenu',
    'dblclick',
    'pointerup',
    'pointerdown',
    'pointerover',
    'pointerout',
    'pointerenter',
    'pointerleave',
    'pointermove',
    'pointermissed',
    'pointercancel',
    'wheel',
];
class NgtObject3dController extends Controller {
    constructor(ngZone, store, eventsStore, objectInputsController, animationSubscriberController, parentObject3d) {
        super(ngZone);
        this.store = store;
        this.eventsStore = eventsStore;
        this.objectInputsController = objectInputsController;
        this.animationSubscriberController = animationSubscriberController;
        this.parentObject3d = parentObject3d;
        _NgtObject3dController_instances.add(this);
        _NgtObject3dController_object3d.set(this, void 0);
        _NgtObject3dController_inputChangesSubscription.set(this, void 0);
        _NgtObject3dController_initFn.set(this, void 0);
        _NgtObject3dController_change$.set(this, defer(() => {
            if (this.objectInputsController.object3dInputsController) {
                return merge(this.objectInputsController.change$.pipe(map((changes) => ({
                    changes,
                    controller: this.objectInputsController,
                }))), this.objectInputsController.object3dInputsController.change$.pipe(map((changes) => ({
                    changes,
                    controller: this.objectInputsController.object3dInputsController,
                }))));
            }
            return this.objectInputsController.change$.pipe(map((changes) => ({
                changes,
                controller: this.objectInputsController,
            })));
        }).pipe(map(({ changes, controller }) => {
            return Object.keys(changes).reduce((trueChanges, key) => {
                trueChanges[key] = controller[key];
                return trueChanges;
            }, {});
        })));
    }
    set initFn(v) {
        __classPrivateFieldSet(this, _NgtObject3dController_initFn, v, "f");
    }
    get initFn() {
        if (!__classPrivateFieldGet(this, _NgtObject3dController_initFn, "f")) {
            this.initFn = () => this.object3d;
        }
        return __classPrivateFieldGet(this, _NgtObject3dController_initFn, "f");
    }
    ngOnInit() {
        super.ngOnInit();
        __classPrivateFieldSet(this, _NgtObject3dController_inputChangesSubscription, __classPrivateFieldGet(this, _NgtObject3dController_change$, "f").subscribe((changes) => {
            if (this.object3d) {
                __classPrivateFieldGet(this, _NgtObject3dController_instances, "m", _NgtObject3dController_applyCustomProps).call(this, changes);
            }
        }), "f");
    }
    init() {
        this.ngZone.runOutsideAngular(() => {
            __classPrivateFieldSet(this, _NgtObject3dController_object3d, this.initFn(), "f");
            if (this.object3d) {
                __classPrivateFieldGet(this, _NgtObject3dController_instances, "m", _NgtObject3dController_applyCustomProps).call(this);
                if (!this.disabled) {
                    const observedEvents = supportedEvents.reduce((result, event) => {
                        const controllerEvent = this.objectInputsController[event]
                            .observed
                            ? this.objectInputsController[event]
                            : this.objectInputsController.object3dInputsController?.[event]
                                .observed
                                ? this.objectInputsController.object3dInputsController[event]
                                : null;
                        if (controllerEvent) {
                            result.handlers[event] = __classPrivateFieldGet(this, _NgtObject3dController_instances, "m", _NgtObject3dController_eventNameToHandler).call(this, controllerEvent);
                            result.eventCount += 1;
                        }
                        return result;
                    }, { handlers: {}, eventCount: 0 });
                    // setup __ngt instance
                    applyProps(this.object3d, {
                        __ngt: {
                            stateGetter: () => this.store.get(),
                            eventsStateGetter: () => this.eventsStore.get(),
                            handlers: observedEvents.handlers,
                            eventCount: observedEvents.eventCount,
                            linear: this.store.get('linear'),
                        },
                    });
                    // add as an interaction if there are events observed
                    if (observedEvents.eventCount > 0) {
                        this.eventsStore.addInteraction(this.object3d);
                    }
                    this.store.set((state) => ({
                        ...state,
                        objects: { ...state.objects, [this.object3d.uuid]: this.object3d },
                    }));
                    if (this.objectInputsController.appendMode !== 'none') {
                        __classPrivateFieldGet(this, _NgtObject3dController_instances, "m", _NgtObject3dController_appendToParent).call(this);
                    }
                }
                __classPrivateFieldGet(this, _NgtObject3dController_instances, "m", _NgtObject3dController_objectReady).call(this);
            }
        });
    }
    ngOnDestroy() {
        if (__classPrivateFieldGet(this, _NgtObject3dController_inputChangesSubscription, "f")) {
            __classPrivateFieldGet(this, _NgtObject3dController_inputChangesSubscription, "f").unsubscribe();
        }
        if (this.object3d) {
            __classPrivateFieldGet(this, _NgtObject3dController_instances, "m", _NgtObject3dController_remove).call(this);
            this.store.set((state) => {
                const { [this.object3d.uuid]: _, ...objects } = state.objects;
                return { ...state, objects };
            });
            this.eventsStore.removeInteraction(this.object3d.uuid);
        }
    }
    get object3d() {
        return __classPrivateFieldGet(this, _NgtObject3dController_object3d, "f");
    }
    get controller() {
        return undefined;
    }
    get props() {
        return [];
    }
}
_NgtObject3dController_object3d = new WeakMap(), _NgtObject3dController_inputChangesSubscription = new WeakMap(), _NgtObject3dController_initFn = new WeakMap(), _NgtObject3dController_change$ = new WeakMap(), _NgtObject3dController_instances = new WeakSet(), _NgtObject3dController_objectReady = function _NgtObject3dController_objectReady() {
    if (this.readyFn) {
        this.readyFn();
    }
    if (this.animationSubscriberController) {
        this.animationSubscriberController.prepare(this.object3d);
    }
}, _NgtObject3dController_appendToParent = function _NgtObject3dController_appendToParent() {
    // Schedule this in the next loop to allow for all appendTo's to settle
    // TODO: find better way
    requestAnimationFrame(() => {
        if (this.objectInputsController.appendTo) {
            this.objectInputsController.appendTo.add(this.object3d);
            return;
        }
        if (this.objectInputsController.appendMode === 'root') {
            __classPrivateFieldGet(this, _NgtObject3dController_instances, "m", _NgtObject3dController_addToScene).call(this);
            return;
        }
        if (this.objectInputsController.appendMode === 'immediate') {
            __classPrivateFieldGet(this, _NgtObject3dController_instances, "m", _NgtObject3dController_addToParent).call(this);
        }
    });
}, _NgtObject3dController_addToScene = function _NgtObject3dController_addToScene() {
    const scene = this.store.get('scene');
    if (scene) {
        scene.add(this.object3d);
    }
}, _NgtObject3dController_addToParent = function _NgtObject3dController_addToParent() {
    if (this.parentObject3d) {
        this.parentObject3d.object3d.add(this.object3d);
    }
    else {
        __classPrivateFieldGet(this, _NgtObject3dController_instances, "m", _NgtObject3dController_addToScene).call(this);
    }
}, _NgtObject3dController_remove = function _NgtObject3dController_remove() {
    if (this.objectInputsController.appendTo) {
        this.objectInputsController.appendTo.remove(this.object3d);
    }
    else if (this.parentObject3d &&
        this.objectInputsController.appendMode === 'immediate') {
        this.parentObject3d.object3d.remove(this.object3d);
    }
    else {
        const scene = this.store.get('scene');
        if (scene) {
            scene.remove(this.object3d);
        }
    }
    if (this.object3d.clear) {
        this.object3d.clear();
    }
}, _NgtObject3dController_eventNameToHandler = function _NgtObject3dController_eventNameToHandler(controllerEvent) {
    return (event) => {
        this.ngZone.run(() => {
            controllerEvent.emit(event);
        });
    };
}, _NgtObject3dController_applyCustomProps = function _NgtObject3dController_applyCustomProps(changes) {
    this.ngZone.runOutsideAngular(() => {
        const customProps = {
            castShadow: this.objectInputsController.castShadow,
            receiveShadow: this.objectInputsController.receiveShadow,
            visible: this.objectInputsController.visible,
            matrixAutoUpdate: this.objectInputsController.matrixAutoUpdate,
        };
        if (this.objectInputsController.name) {
            customProps['name'] = this.objectInputsController.name;
        }
        if (this.objectInputsController.position) {
            customProps['position'] = this.objectInputsController.position;
        }
        if (this.objectInputsController.rotation) {
            customProps['rotation'] = this.objectInputsController.rotation;
        }
        else if (this.objectInputsController.quaternion) {
            customProps['quaternion'] = this.objectInputsController.quaternion;
        }
        if (this.objectInputsController.scale) {
            customProps['scale'] = this.objectInputsController.scale;
        }
        if (this.objectInputsController.userData) {
            customProps['userData'] = this.objectInputsController.userData;
        }
        if (this.objectInputsController.color) {
            customProps['color'] = this.objectInputsController.color;
            if (!this.store.get('linear')) {
                customProps['color'].convertSRGBToLinear();
            }
        }
        if (this.objectInputsController.dispose) {
            customProps['dispose'] = this.objectInputsController.dispose;
        }
        if (this.objectInputsController.raycast) {
            customProps['raycast'] = this.objectInputsController.raycast;
        }
        if (changes) {
            Object.assign(customProps, changes);
        }
        __classPrivateFieldGet(this, _NgtObject3dController_change$, "f").pipe(take(1)).subscribe((changes) => {
            if (changes) {
                for (const [inputName, inputChange] of Object.entries(changes)) {
                    if ([
                        'name',
                        'position',
                        'rotation',
                        'quaternion',
                        'scale',
                        'userData',
                        'color',
                        'dispose',
                        'raycast',
                        'castShadow',
                        'receiveShadow',
                        'visible',
                        'matrixAutoUpdate',
                        'object3dController',
                    ].includes(inputName) // skip 14 common inputs
                    ) {
                        continue;
                    }
                    customProps[inputName] = inputChange;
                }
            }
        });
        applyProps(this.object3d, customProps);
        this.object3d.updateMatrix?.();
    });
};
NgtObject3dController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObject3dController, deps: [{ token: i0.NgZone }, { token: NgtStore }, { token: NgtEventsStore }, { token: NGT_OBJECT_INPUTS_WATCHED_CONTROLLER }, { token: NGT_ANIMATION_SUBSCRIBER_WATCHED_CONTROLLER }, { token: NgtObject3dController, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive });
NgtObject3dController.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtObject3dController, selector: "\n    ngt-primitive,\n    ngt-bone,\n    ngt-group,\n    ngt-lod,\n    ngt-points,\n    ngt-mesh,\n    ngt-instanced-mesh,\n    ngt-skinned-mesh,\n    ngt-audio,\n    ngt-positional-audio,\n    ngt-line,\n    ngt-line-loop,\n    ngt-line-segments,\n    ngt-light-probe,\n    ngt-ambient-light,\n    ngt-ambient-light-probe,\n    ngt-hemisphere-light,\n    ngt-hemisphere-light-probe,\n    ngt-directional-light,\n    ngt-point-light,\n    ngt-spot-light,\n    ngt-rect-area-light,\n    ngt-arrow-helper,\n    ngt-axes-helper,\n    ngt-box3-helper,\n    ngt-grid-helper,\n    ngt-plane-helper,\n    ngt-polar-grid-helper,\n    ngt-sprite,\n    ngt-camera,\n    ngt-perspective-camera,\n    ngt-orthographic-camera,\n    ngt-array-camera,\n    ngt-stereo-camera,\n    ngt-cube-camera\n  ", providers: [
        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
        NGT_ANIMATION_SUBSCRIBER_CONTROLLER_PROVIDER,
    ], exportAs: ["ngtObject3dController"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObject3dController, decorators: [{
            type: Directive,
            args: [{
                    selector: `
    ngt-primitive,
    ngt-bone,
    ngt-group,
    ngt-lod,
    ngt-points,
    ngt-mesh,
    ngt-instanced-mesh,
    ngt-skinned-mesh,
    ngt-audio,
    ngt-positional-audio,
    ngt-line,
    ngt-line-loop,
    ngt-line-segments,
    ngt-light-probe,
    ngt-ambient-light,
    ngt-ambient-light-probe,
    ngt-hemisphere-light,
    ngt-hemisphere-light-probe,
    ngt-directional-light,
    ngt-point-light,
    ngt-spot-light,
    ngt-rect-area-light,
    ngt-arrow-helper,
    ngt-axes-helper,
    ngt-box3-helper,
    ngt-grid-helper,
    ngt-plane-helper,
    ngt-polar-grid-helper,
    ngt-sprite,
    ngt-camera,
    ngt-perspective-camera,
    ngt-orthographic-camera,
    ngt-array-camera,
    ngt-stereo-camera,
    ngt-cube-camera
  `,
                    exportAs: 'ngtObject3dController',
                    providers: [
                        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
                        NGT_ANIMATION_SUBSCRIBER_CONTROLLER_PROVIDER,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: NgtStore }, { type: NgtEventsStore }, { type: NgtObject3dInputsController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_INPUTS_WATCHED_CONTROLLER]
                }] }, { type: NgtAnimationSubscriberController, decorators: [{
                    type: Inject,
                    args: [NGT_ANIMATION_SUBSCRIBER_WATCHED_CONTROLLER]
                }] }, { type: NgtObject3dController, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }]; } });
class NgtObject3dControllerModule {
}
NgtObject3dControllerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObject3dControllerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtObject3dControllerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObject3dControllerModule, declarations: [NgtObject3dController], exports: [NgtObject3dController, NgtObject3dInputsControllerModule,
        NgtAnimationSubscriberControllerModule] });
NgtObject3dControllerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObject3dControllerModule, imports: [NgtObject3dInputsControllerModule,
        NgtAnimationSubscriberControllerModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObject3dControllerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtObject3dController],
                    exports: [
                        NgtObject3dController,
                        NgtObject3dInputsControllerModule,
                        NgtAnimationSubscriberControllerModule,
                    ],
                }]
        }] });
const [NGT_OBJECT_WATCHED_CONTROLLER, NGT_OBJECT_CONTROLLER_PROVIDER] = createControllerProviderFactory({
    watchedControllerTokenName: 'Watched Object3dController',
    controller: NgtObject3dController,
});

var _NgtSobaExtender_object;
class NgtSobaExtender {
    constructor() {
        this.ready = new EventEmitter();
        this.animateReady = new EventEmitter();
        _NgtSobaExtender_object.set(this, void 0);
    }
    set object(value) {
        __classPrivateFieldSet(this, _NgtSobaExtender_object, value, "f");
        this.ready.emit(value);
    }
    get object() {
        return __classPrivateFieldGet(this, _NgtSobaExtender_object, "f");
    }
}
_NgtSobaExtender_object = new WeakMap();
NgtSobaExtender.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaExtender, deps: [], target: i0.ɵɵFactoryTarget.Directive });
NgtSobaExtender.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaExtender, outputs: { ready: "ready", animateReady: "animateReady" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaExtender, decorators: [{
            type: Directive
        }], propDecorators: { ready: [{
                type: Output
            }], animateReady: [{
                type: Output
            }] } });

const NGT_OBJECT_3D = new InjectionToken('THREE_OBJECT_3D');
const NGT_OBJECT_3D_PROVIDER = {
    provide: NGT_OBJECT_3D,
    useFactory: (sobaExtender, objectController) => {
        return () => {
            if (sobaExtender)
                return sobaExtender.object;
            if (objectController)
                return objectController.object3d;
            return null;
        };
    },
    deps: [
        [new Optional(), NgtSobaExtender],
        [new Optional(), NGT_OBJECT_WATCHED_CONTROLLER],
    ],
};

class NgtVector2Pipe {
    transform(value) {
        return makeVector2(value);
    }
}
NgtVector2Pipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVector2Pipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
NgtVector2Pipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVector2Pipe, name: "vector2" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVector2Pipe, decorators: [{
            type: Pipe,
            args: [{ name: 'vector2' }]
        }] });
class NgtVector3Pipe {
    transform(value) {
        return makeVector3(value);
    }
}
NgtVector3Pipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVector3Pipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
NgtVector3Pipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVector3Pipe, name: "vector3" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVector3Pipe, decorators: [{
            type: Pipe,
            args: [{ name: 'vector3' }]
        }] });
class NgtVector4Pipe {
    transform(value) {
        return makeVector4(value);
    }
}
NgtVector4Pipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVector4Pipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
NgtVector4Pipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVector4Pipe, name: "vector4" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVector4Pipe, decorators: [{
            type: Pipe,
            args: [{ name: 'vector4' }]
        }] });
class NgtVectorPipeModule {
}
NgtVectorPipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVectorPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtVectorPipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVectorPipeModule, declarations: [NgtVector2Pipe, NgtVector3Pipe, NgtVector4Pipe], exports: [NgtVector2Pipe, NgtVector3Pipe, NgtVector4Pipe] });
NgtVectorPipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVectorPipeModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtVectorPipeModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtVector2Pipe, NgtVector3Pipe, NgtVector4Pipe],
                    exports: [NgtVector2Pipe, NgtVector3Pipe, NgtVector4Pipe],
                }]
        }] });

class NgtColorPipe {
    /**
     * ConstructorParameters<typeof THREE.Color> has a limitation on THREE.Color constructor overloads
     */
    transform(args) {
        return makeColor(args);
    }
}
NgtColorPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtColorPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
NgtColorPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtColorPipe, name: "color" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtColorPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'color',
                }]
        }] });
class NgtColorPipeModule {
}
NgtColorPipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtColorPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtColorPipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtColorPipeModule, declarations: [NgtColorPipe], exports: [NgtColorPipe] });
NgtColorPipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtColorPipeModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtColorPipeModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtColorPipe],
                    exports: [NgtColorPipe],
                }]
        }] });

class NgtMathPipe {
    transform(value, keyOfMath) {
        const params = Array.isArray(value) ? value : [value];
        return Math[keyOfMath](...params);
    }
}
NgtMathPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMathPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
NgtMathPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMathPipe, name: "math" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMathPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'math',
                }]
        }] });
class NgtMathConstantPipe {
    transform(value, keyOfMathConst) {
        if (keyOfMathConst === 'random') {
            return Math.random();
        }
        return value * Math[keyOfMathConst];
    }
}
NgtMathConstantPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMathConstantPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
NgtMathConstantPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMathConstantPipe, name: "mathConst" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMathConstantPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'mathConst',
                }]
        }] });
class NgtMathPipeModule {
}
NgtMathPipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMathPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtMathPipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMathPipeModule, declarations: [NgtMathPipe, NgtMathConstantPipe], exports: [NgtMathPipe, NgtMathConstantPipe] });
NgtMathPipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMathPipeModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMathPipeModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtMathPipe, NgtMathConstantPipe],
                    exports: [NgtMathPipe, NgtMathConstantPipe],
                }]
        }] });

class NgtFogPipe {
    transform(value) {
        return new THREE.Fog(...value);
    }
}
NgtFogPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtFogPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
NgtFogPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtFogPipe, name: "fog" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtFogPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'fog',
                }]
        }] });
class NgtFogExp2Pipe {
    transform(value) {
        return new THREE.FogExp2(...value);
    }
}
NgtFogExp2Pipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtFogExp2Pipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
NgtFogExp2Pipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtFogExp2Pipe, name: "fogExp2" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtFogExp2Pipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'fogExp2',
                }]
        }] });
class NgtFogPipeModule {
}
NgtFogPipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtFogPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtFogPipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtFogPipeModule, declarations: [NgtFogPipe, NgtFogExp2Pipe], exports: [NgtFogPipe, NgtFogExp2Pipe] });
NgtFogPipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtFogPipeModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtFogPipeModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtFogPipe, NgtFogExp2Pipe],
                    exports: [NgtFogPipe, NgtFogExp2Pipe],
                }]
        }] });

class NgtSidePipe {
    transform(value, side) {
        switch (side) {
            case 'front':
                return THREE.FrontSide;
            case 'back':
                return THREE.BackSide;
            case 'double':
                return THREE.DoubleSide;
        }
    }
}
NgtSidePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSidePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
NgtSidePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSidePipe, name: "side" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSidePipe, decorators: [{
            type: Pipe,
            args: [{ name: 'side' }]
        }] });
class NgtSidePipeModule {
}
NgtSidePipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSidePipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSidePipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSidePipeModule, declarations: [NgtSidePipe], exports: [NgtSidePipe] });
NgtSidePipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSidePipeModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSidePipeModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtSidePipe],
                    exports: [NgtSidePipe],
                }]
        }] });

const MAX_VALUE = 0x10000;
class NgtRepeat {
    constructor(viewContainer, templateRef) {
        this.viewContainer = viewContainer;
        this.templateRef = templateRef;
    }
    set repeatOf(count) {
        const safeCount = Math.floor(Math.max(0, Math.min(count, MAX_VALUE)));
        const { length } = this.viewContainer;
        if (safeCount < length) {
            this.removeContainers(length - safeCount);
        }
        else {
            this.addContainers(length, safeCount);
        }
    }
    addContainers(length, count) {
        for (let index = length; index < count; index++) {
            this.viewContainer.createEmbeddedView(this.templateRef, {
                $implicit: index,
                isFirst: index === length,
                isLast: index === count - 1,
                isOdd: !(index % 2),
                isEven: !!(index % 2),
            });
        }
    }
    removeContainers(amount) {
        for (let index = 0; index < amount; index++) {
            this.viewContainer.remove();
        }
    }
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
}
NgtRepeat.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtRepeat, deps: [{ token: ViewContainerRef }, { token: TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
NgtRepeat.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtRepeat, selector: "[repeat][repeatOf]", inputs: { repeatOf: "repeatOf" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtRepeat, decorators: [{
            type: Directive,
            args: [{
                    selector: '[repeat][repeatOf]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef, decorators: [{
                    type: Inject,
                    args: [ViewContainerRef]
                }] }, { type: i0.TemplateRef, decorators: [{
                    type: Inject,
                    args: [TemplateRef]
                }] }]; }, propDecorators: { repeatOf: [{
                type: Input
            }] } });
class NgtRepeatModule {
}
NgtRepeatModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtRepeatModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtRepeatModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtRepeatModule, declarations: [NgtRepeat], exports: [NgtRepeat] });
NgtRepeatModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtRepeatModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtRepeatModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtRepeat],
                    exports: [NgtRepeat],
                }]
        }] });

class NgtCursor {
    constructor(objectInputsController, document, destroyed) {
        if (!objectInputsController)
            return;
        merge(objectInputsController.pointerover.pipe(mapTo(true)), objectInputsController.pointerout.pipe(mapTo(false)))
            .pipe(takeUntil(destroyed))
            .subscribe((hovered) => {
            document.body.style.cursor = hovered ? 'pointer' : 'auto';
        });
    }
}
NgtCursor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCursor, deps: [{ token: NgtObject3dInputsController, optional: true, self: true }, { token: DOCUMENT }, { token: NgtDestroyedService }], target: i0.ɵɵFactoryTarget.Directive });
NgtCursor.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtCursor, selector: "[ngtCursor]", providers: [NgtDestroyedService], exportAs: ["ngtCursor"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCursor, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngtCursor]',
                    exportAs: 'ngtCursor',
                    providers: [NgtDestroyedService],
                }]
        }], ctorParameters: function () { return [{ type: NgtObject3dInputsController, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: NgtDestroyedService }]; } });
class NgtCursorModule {
}
NgtCursorModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCursorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtCursorModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCursorModule, declarations: [NgtCursor], exports: [NgtCursor] });
NgtCursorModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCursorModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCursorModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtCursor],
                    exports: [NgtCursor],
                }]
        }] });

var _NgtContentGeometryController_instances, _NgtContentGeometryController_geometryInput, _NgtContentGeometryController_geometry, _NgtContentGeometryController_getGeometry;
class NgtContentGeometryController extends Controller {
    constructor(ngZone) {
        super(ngZone);
        _NgtContentGeometryController_instances.add(this);
        _NgtContentGeometryController_geometryInput.set(this, void 0);
        _NgtContentGeometryController_geometry.set(this, undefined);
    }
    set geometry(v) {
        if (v) {
            __classPrivateFieldSet(this, _NgtContentGeometryController_geometryInput, v, "f");
            this.construct();
        }
    }
    get geometry() {
        return __classPrivateFieldGet(this, _NgtContentGeometryController_geometry, "f");
    }
    construct() {
        __classPrivateFieldSet(this, _NgtContentGeometryController_geometry, __classPrivateFieldGet(this, _NgtContentGeometryController_instances, "m", _NgtContentGeometryController_getGeometry).call(this, __classPrivateFieldGet(this, _NgtContentGeometryController_geometryInput, "f")), "f");
    }
    get controller() {
        return this.contentGeometryController;
    }
    get props() {
        return ['geometry'];
    }
}
_NgtContentGeometryController_geometryInput = new WeakMap(), _NgtContentGeometryController_geometry = new WeakMap(), _NgtContentGeometryController_instances = new WeakSet(), _NgtContentGeometryController_getGeometry = function _NgtContentGeometryController_getGeometry(input) {
    if (input instanceof THREE.BufferGeometry) {
        return input;
    }
    return undefined;
};
NgtContentGeometryController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtContentGeometryController, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgtContentGeometryController.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtContentGeometryController, selector: "\n    ngt-mesh,\n    ngt-instanced-mesh,\n    ngt-skinned-mesh,\n    ngt-line,\n    ngt-line-loop,\n    ngt-line-segments,\n    ngt-points\n  ", inputs: { geometry: "geometry", contentGeometryController: "contentGeometryController" }, exportAs: ["ngtContentGeometryController"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtContentGeometryController, decorators: [{
            type: Directive,
            args: [{
                    selector: `
    ngt-mesh,
    ngt-instanced-mesh,
    ngt-skinned-mesh,
    ngt-line,
    ngt-line-loop,
    ngt-line-segments,
    ngt-points
  `,
                    exportAs: 'ngtContentGeometryController',
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; }, propDecorators: { geometry: [{
                type: Input
            }], contentGeometryController: [{
                type: Input
            }] } });
class NgtContentGeometryControllerModule {
}
NgtContentGeometryControllerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtContentGeometryControllerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtContentGeometryControllerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtContentGeometryControllerModule, declarations: [NgtContentGeometryController], exports: [NgtContentGeometryController] });
NgtContentGeometryControllerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtContentGeometryControllerModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtContentGeometryControllerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtContentGeometryController],
                    exports: [NgtContentGeometryController],
                }]
        }] });
const [NGT_CONTENT_GEOMETRY_WATCHED_CONTROLLER, NGT_CONTENT_GEOMETRY_CONTROLLER_PROVIDER,] = createControllerProviderFactory({
    controller: NgtContentGeometryController,
    watchedControllerTokenName: 'Watched ContentGeometryController',
});

var _NgtContentMaterialController_instances, _NgtContentMaterialController_materialInput, _NgtContentMaterialController_material, _NgtContentMaterialController_getMaterial;
class NgtContentMaterialController extends Controller {
    constructor(ngZone) {
        super(ngZone);
        _NgtContentMaterialController_instances.add(this);
        _NgtContentMaterialController_materialInput.set(this, void 0);
        this.isMaterialArray = false;
        _NgtContentMaterialController_material.set(this, undefined);
    }
    set material(v) {
        if (v) {
            if (!(Array.isArray(v) && !v.length)) {
                __classPrivateFieldSet(this, _NgtContentMaterialController_materialInput, v, "f");
            }
            this.construct();
        }
    }
    get material() {
        return __classPrivateFieldGet(this, _NgtContentMaterialController_material, "f");
    }
    construct() {
        __classPrivateFieldSet(this, _NgtContentMaterialController_material, __classPrivateFieldGet(this, _NgtContentMaterialController_instances, "m", _NgtContentMaterialController_getMaterial).call(this, __classPrivateFieldGet(this, _NgtContentMaterialController_materialInput, "f")), "f");
    }
    get controller() {
        return this.contentMaterialController;
    }
    get props() {
        return ['material', 'isArrayMaterial'];
    }
}
_NgtContentMaterialController_materialInput = new WeakMap(), _NgtContentMaterialController_material = new WeakMap(), _NgtContentMaterialController_instances = new WeakSet(), _NgtContentMaterialController_getMaterial = function _NgtContentMaterialController_getMaterial(input) {
    if (Array.isArray(input)) {
        if (!input.length)
            return undefined;
        if (input[0] instanceof THREE.Material) {
            return input;
        }
    }
    if (input instanceof THREE.Material) {
        return input;
    }
    return undefined;
};
NgtContentMaterialController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtContentMaterialController, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgtContentMaterialController.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtContentMaterialController, selector: "\n    ngt-mesh,\n    ngt-instanced-mesh,\n    ngt-skinned-mesh,\n    ngt-line,\n    ngt-line-loop,\n    ngt-line-segments,\n    ngt-soba-plane,\n    ngt-soba-box,\n    ngt-soba-cylinder,\n    ngt-soba-cone,\n    ngt-soba-circle,\n    ngt-soba-sphere,\n    ngt-soba-tube,\n    ngt-soba-torus,\n    ngt-soba-tetrahedron,\n    ngt-soba-ring,\n    ngt-soba-polyhedron,\n    ngt-soba-octahedron,\n    ngt-soba-dodecahedron,\n    ngt-soba-icosahedron,\n    ngt-soba-extrude,\n    ngt-soba-lathe,\n    ngt-soba-torus-knot,\n    ngt-soba-text,,\n    ngt-points\n  ", inputs: { material: "material", isMaterialArray: "isMaterialArray", contentMaterialController: "contentMaterialController" }, exportAs: ["ngtContentMaterialController"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtContentMaterialController, decorators: [{
            type: Directive,
            args: [{
                    selector: `
    ngt-mesh,
    ngt-instanced-mesh,
    ngt-skinned-mesh,
    ngt-line,
    ngt-line-loop,
    ngt-line-segments,
    ngt-soba-plane,
    ngt-soba-box,
    ngt-soba-cylinder,
    ngt-soba-cone,
    ngt-soba-circle,
    ngt-soba-sphere,
    ngt-soba-tube,
    ngt-soba-torus,
    ngt-soba-tetrahedron,
    ngt-soba-ring,
    ngt-soba-polyhedron,
    ngt-soba-octahedron,
    ngt-soba-dodecahedron,
    ngt-soba-icosahedron,
    ngt-soba-extrude,
    ngt-soba-lathe,
    ngt-soba-torus-knot,
    ngt-soba-text,,
    ngt-points
  `,
                    exportAs: 'ngtContentMaterialController',
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; }, propDecorators: { material: [{
                type: Input
            }], isMaterialArray: [{
                type: Input
            }], contentMaterialController: [{
                type: Input
            }] } });
class NgtContentMaterialControllerModule {
}
NgtContentMaterialControllerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtContentMaterialControllerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtContentMaterialControllerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtContentMaterialControllerModule, declarations: [NgtContentMaterialController], exports: [NgtContentMaterialController] });
NgtContentMaterialControllerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtContentMaterialControllerModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtContentMaterialControllerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtContentMaterialController],
                    exports: [NgtContentMaterialController],
                }]
        }] });
const [NGT_CONTENT_MATERIAL_WATCHED_CONTROLLER, NGT_CONTENT_MATERIAL_CONTROLLER_PROVIDER,] = createControllerProviderFactory({
    controller: NgtContentMaterialController,
    watchedControllerTokenName: 'Watched ContentMaterialController',
});

var _NgtMaterialGeometryController_meshArgs;
const NGT_OBJECT_TYPE = new InjectionToken('Object3d Type', {
    providedIn: 'root',
    factory: () => THREE.Object3D,
});
const NGT_OBJECT_POST_INIT = new InjectionToken('Object3d PostInit', {
    providedIn: 'root',
    factory: () => undefined,
});
class NgtMaterialGeometryController extends Controller {
    constructor(ngZone, objectController, objectType, objectPostInit, contentMaterialController, contentGeometryController) {
        super(ngZone);
        this.objectController = objectController;
        this.objectType = objectType;
        this.objectPostInit = objectPostInit;
        _NgtMaterialGeometryController_meshArgs.set(this, []);
        objectController.initFn = () => {
            if (!contentGeometryController.geometry) {
                contentGeometryController.construct();
            }
            if (!contentMaterialController.material) {
                contentMaterialController.construct();
            }
            const object = new this.objectType(contentGeometryController.geometry || undefined, contentMaterialController.material || undefined, ...__classPrivateFieldGet(this, _NgtMaterialGeometryController_meshArgs, "f"));
            if (this.morphTargetDictionary && 'morphTargetDictionary' in object) {
                object.morphTargetDictionary =
                    this.morphTargetDictionary;
            }
            if (this.morphTargetInfluences && 'morphTargetInfluences' in object) {
                object.morphTargetInfluences =
                    this.morphTargetInfluences;
            }
            if (this.objectPostInit) {
                this.objectPostInit(object);
            }
            return object;
        };
        objectController.readyFn = () => {
            if (this.readyFn) {
                this.readyFn();
            }
        };
    }
    set meshArgs(v) {
        __classPrivateFieldSet(this, _NgtMaterialGeometryController_meshArgs, Array.isArray(v) ? v : [v], "f");
    }
    ngOnInit() {
        super.ngOnInit();
        this.ngZone.runOutsideAngular(() => {
            this.objectController.init();
        });
    }
    get controller() {
        return undefined;
    }
    get props() {
        return [];
    }
}
_NgtMaterialGeometryController_meshArgs = new WeakMap();
NgtMaterialGeometryController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMaterialGeometryController, deps: [{ token: i0.NgZone }, { token: NGT_OBJECT_WATCHED_CONTROLLER }, { token: NGT_OBJECT_TYPE }, { token: NGT_OBJECT_POST_INIT }, { token: NGT_CONTENT_MATERIAL_WATCHED_CONTROLLER }, { token: NGT_CONTENT_GEOMETRY_WATCHED_CONTROLLER }], target: i0.ɵɵFactoryTarget.Directive });
NgtMaterialGeometryController.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtMaterialGeometryController, selector: "\n    ngt-mesh,\n    ngt-instanced-mesh,\n    ngt-skinned-mesh,\n    ngt-line,\n    ngt-line-loop,\n    ngt-line-segments,\n    ngt-points\n  ", inputs: { morphTargetInfluences: "morphTargetInfluences", morphTargetDictionary: "morphTargetDictionary" }, providers: [
        NGT_OBJECT_CONTROLLER_PROVIDER,
        NGT_CONTENT_MATERIAL_CONTROLLER_PROVIDER,
        NGT_CONTENT_GEOMETRY_CONTROLLER_PROVIDER,
    ], exportAs: ["ngtMaterialGeometryController"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMaterialGeometryController, decorators: [{
            type: Directive,
            args: [{
                    selector: `
    ngt-mesh,
    ngt-instanced-mesh,
    ngt-skinned-mesh,
    ngt-line,
    ngt-line-loop,
    ngt-line-segments,
    ngt-points
  `,
                    exportAs: 'ngtMaterialGeometryController',
                    providers: [
                        NGT_OBJECT_CONTROLLER_PROVIDER,
                        NGT_CONTENT_MATERIAL_CONTROLLER_PROVIDER,
                        NGT_CONTENT_GEOMETRY_CONTROLLER_PROVIDER,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: NgtObject3dController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_WATCHED_CONTROLLER]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_TYPE]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_POST_INIT]
                }] }, { type: NgtContentMaterialController, decorators: [{
                    type: Inject,
                    args: [NGT_CONTENT_MATERIAL_WATCHED_CONTROLLER]
                }] }, { type: NgtContentGeometryController, decorators: [{
                    type: Inject,
                    args: [NGT_CONTENT_GEOMETRY_WATCHED_CONTROLLER]
                }] }]; }, propDecorators: { morphTargetInfluences: [{
                type: Input
            }], morphTargetDictionary: [{
                type: Input
            }] } });
class NgtMaterialGeometryControllerModule {
}
NgtMaterialGeometryControllerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMaterialGeometryControllerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtMaterialGeometryControllerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMaterialGeometryControllerModule, declarations: [NgtMaterialGeometryController], exports: [NgtMaterialGeometryController, NgtObject3dControllerModule,
        NgtContentMaterialControllerModule,
        NgtContentGeometryControllerModule] });
NgtMaterialGeometryControllerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMaterialGeometryControllerModule, imports: [NgtObject3dControllerModule,
        NgtContentMaterialControllerModule,
        NgtContentGeometryControllerModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMaterialGeometryControllerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtMaterialGeometryController],
                    exports: [
                        NgtMaterialGeometryController,
                        NgtObject3dControllerModule,
                        NgtContentMaterialControllerModule,
                        NgtContentGeometryControllerModule,
                    ],
                }]
        }] });
const [NGT_MATERIAL_GEOMETRY_WATCHED_CONTROLLER, NGT_MATERIAL_GEOMETRY_CONTROLLER_PROVIDER,] = createControllerProviderFactory({
    watchedControllerTokenName: 'Watched MaterialGeometryController',
    controller: NgtMaterialGeometryController,
});

// GENERATED
class NgtAudioController extends Controller {
    constructor() {
        super(...arguments);
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = undefined;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.sourceType = 'empty';
        this.source = null;
        this.filters = [];
    }
    get props() {
        return [
            'autoplay',
            'buffer',
            'detune',
            'loop',
            'loopStart',
            'loopEnd',
            'offset',
            'duration',
            'playbackRate',
            'isPlaying',
            'hasPlaybackControl',
            'sourceType',
            'source',
            'filters',
        ];
    }
    get controller() {
        return this.audioController;
    }
}
NgtAudioController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAudioController, deps: null, target: i0.ɵɵFactoryTarget.Directive });
NgtAudioController.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtAudioController, selector: "\n    ngt-audio,\n    ngt-positional-audio,\n    ngt-soba-positional-audio,\n  ", inputs: { autoplay: "autoplay", buffer: "buffer", detune: "detune", loop: "loop", loopStart: "loopStart", loopEnd: "loopEnd", offset: "offset", duration: "duration", playbackRate: "playbackRate", isPlaying: "isPlaying", hasPlaybackControl: "hasPlaybackControl", sourceType: "sourceType", source: "source", filters: "filters", audioController: "audioController" }, exportAs: ["ngtAudioController"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAudioController, decorators: [{
            type: Directive,
            args: [{
                    selector: `
    ngt-audio,
    ngt-positional-audio,
    ngt-soba-positional-audio,
  `,
                    exportAs: 'ngtAudioController',
                }]
        }], propDecorators: { autoplay: [{
                type: Input
            }], buffer: [{
                type: Input
            }], detune: [{
                type: Input
            }], loop: [{
                type: Input
            }], loopStart: [{
                type: Input
            }], loopEnd: [{
                type: Input
            }], offset: [{
                type: Input
            }], duration: [{
                type: Input
            }], playbackRate: [{
                type: Input
            }], isPlaying: [{
                type: Input
            }], hasPlaybackControl: [{
                type: Input
            }], sourceType: [{
                type: Input
            }], source: [{
                type: Input
            }], filters: [{
                type: Input
            }], audioController: [{
                type: Input
            }] } });
class NgtAudioControllerModule {
}
NgtAudioControllerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAudioControllerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtAudioControllerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAudioControllerModule, declarations: [NgtAudioController], exports: [NgtAudioController] });
NgtAudioControllerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAudioControllerModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAudioControllerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtAudioController],
                    exports: [NgtAudioController],
                }]
        }] });
const [NGT_AUDIO_WATCHED_CONTROLLER, NGT_AUDIO_CONTROLLER_PROVIDER] = createControllerProviderFactory({
    watchedControllerTokenName: 'Watched AudioController',
    controller: NgtAudioController,
});

var _NgtCommonAudio_audioArgs, _NgtCommonAudio_audio;
class NgtCommonAudio {
    constructor(objectController, ngZone) {
        this.objectController = objectController;
        this.ngZone = ngZone;
        this.ready = new EventEmitter();
        _NgtCommonAudio_audioArgs.set(this, []);
        _NgtCommonAudio_audio.set(this, void 0);
        objectController.initFn = () => {
            if (!this.listener) {
                throw new Error('Cannot initialize Audio without an AudioListener');
            }
            __classPrivateFieldSet(this, _NgtCommonAudio_audio, new this.audioType(this.listener, ...__classPrivateFieldGet(this, _NgtCommonAudio_audioArgs, "f")), "f");
            return __classPrivateFieldGet(this, _NgtCommonAudio_audio, "f");
        };
        objectController.readyFn = () => {
            this.ready.emit(this.audio);
        };
    }
    set audioArgs(v) {
        __classPrivateFieldSet(this, _NgtCommonAudio_audioArgs, Array.isArray(v) ? v : [v], "f");
        this.ngZone.runOutsideAngular(() => {
            this.objectController.init();
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!__classPrivateFieldGet(this, _NgtCommonAudio_audio, "f")) {
                this.objectController.init();
            }
        });
    }
    get audio() {
        return __classPrivateFieldGet(this, _NgtCommonAudio_audio, "f");
    }
}
_NgtCommonAudio_audioArgs = new WeakMap(), _NgtCommonAudio_audio = new WeakMap();
NgtCommonAudio.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCommonAudio, deps: [{ token: NGT_OBJECT_WATCHED_CONTROLLER }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgtCommonAudio.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtCommonAudio, inputs: { listener: "listener" }, outputs: { ready: "ready" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCommonAudio, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: NgtObject3dController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_WATCHED_CONTROLLER]
                }] }, { type: i0.NgZone }]; }, propDecorators: { listener: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });

class NgtCommonLine {
    constructor(materialGeometryController) {
        this.materialGeometryController = materialGeometryController;
        this.ready = new EventEmitter();
        if (materialGeometryController) {
            materialGeometryController.readyFn = () => {
                this.ready.emit(this.line);
            };
        }
    }
    get line() {
        return this.materialGeometryController?.objectController.object3d;
    }
}
NgtCommonLine.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCommonLine, deps: [{ token: NGT_MATERIAL_GEOMETRY_WATCHED_CONTROLLER, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
NgtCommonLine.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtCommonLine, outputs: { ready: "ready" }, providers: [{ provide: NGT_OBJECT_TYPE, useValue: THREE.Line }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCommonLine, decorators: [{
            type: Directive,
            args: [{
                    providers: [{ provide: NGT_OBJECT_TYPE, useValue: THREE.Line }],
                }]
        }], ctorParameters: function () { return [{ type: NgtMaterialGeometryController, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [NGT_MATERIAL_GEOMETRY_WATCHED_CONTROLLER]
                }] }]; }, propDecorators: { ready: [{
                type: Output
            }] } });

var _NgtTexture_textureArgs, _NgtTexture_texture;
class NgtTexture {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.ready = new EventEmitter();
        _NgtTexture_textureArgs.set(this, []);
        _NgtTexture_texture.set(this, void 0);
    }
    set textureArgs(v) {
        __classPrivateFieldSet(this, _NgtTexture_textureArgs, Array.isArray(v) ? v : [v], "f");
        this.ngZone.runOutsideAngular(() => {
            __classPrivateFieldSet(this, _NgtTexture_texture, new this.textureType(...__classPrivateFieldGet(this, _NgtTexture_textureArgs, "f")), "f");
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!this.texture) {
                __classPrivateFieldSet(this, _NgtTexture_texture, new this.textureType(...__classPrivateFieldGet(this, _NgtTexture_textureArgs, "f")), "f");
                this.ready.emit(this.texture);
            }
        });
    }
    get texture() {
        return __classPrivateFieldGet(this, _NgtTexture_texture, "f");
    }
    ngOnDestroy() {
        this.ngZone.runOutsideAngular(() => {
            if (this.texture) {
                this.texture.dispose();
            }
        });
    }
}
_NgtTexture_textureArgs = new WeakMap(), _NgtTexture_texture = new WeakMap();
NgtTexture.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtTexture, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgtTexture.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtTexture, outputs: { ready: "ready" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtTexture, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; }, propDecorators: { ready: [{
                type: Output
            }] } });

var _NgtGeometry_instances, _NgtGeometry_geometryArgs, _NgtGeometry_init, _NgtGeometry_assign, _NgtGeometry_construct, _NgtGeometry_geometry;
class NgtGeometry {
    constructor(ngZone, parentObject) {
        this.ngZone = ngZone;
        this.parentObject = parentObject;
        _NgtGeometry_instances.add(this);
        this.ready = new EventEmitter();
        _NgtGeometry_geometryArgs.set(this, []);
        _NgtGeometry_geometry.set(this, void 0);
    }
    set geometryArgs(v) {
        __classPrivateFieldSet(this, _NgtGeometry_geometryArgs, Array.isArray(v) ? v : [v], "f");
        this.ngZone.runOutsideAngular(() => {
            __classPrivateFieldGet(this, _NgtGeometry_instances, "m", _NgtGeometry_init).call(this);
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!this.geometry) {
                __classPrivateFieldGet(this, _NgtGeometry_instances, "m", _NgtGeometry_init).call(this);
            }
        });
    }
    get geometry() {
        return __classPrivateFieldGet(this, _NgtGeometry_geometry, "f");
    }
    ngOnDestroy() {
        this.ngZone.runOutsideAngular(() => {
            if (this.geometry) {
                this.geometry.dispose();
            }
        });
    }
}
_NgtGeometry_geometryArgs = new WeakMap(), _NgtGeometry_geometry = new WeakMap(), _NgtGeometry_instances = new WeakSet(), _NgtGeometry_init = function _NgtGeometry_init() {
    // geometry has changed. reconstruct
    if (this.geometry) {
        // cleanup
        if (this.parentObject) {
            const object3d = this.parentObject;
            if (object3d.geometry) {
                object3d.geometry.dispose();
            }
        }
        // reconstruct
        __classPrivateFieldGet(this, _NgtGeometry_instances, "m", _NgtGeometry_construct).call(this);
        __classPrivateFieldGet(this, _NgtGeometry_instances, "m", _NgtGeometry_assign).call(this);
    }
    else {
        __classPrivateFieldGet(this, _NgtGeometry_instances, "m", _NgtGeometry_construct).call(this);
        __classPrivateFieldGet(this, _NgtGeometry_instances, "m", _NgtGeometry_assign).call(this);
    }
}, _NgtGeometry_assign = function _NgtGeometry_assign() {
    requestAnimationFrame(() => {
        const parentObject = this.parentObject();
        if (parentObject) {
            parentObject.geometry = this.geometry;
        }
    });
}, _NgtGeometry_construct = function _NgtGeometry_construct() {
    __classPrivateFieldSet(this, _NgtGeometry_geometry, new this.geometryType(...__classPrivateFieldGet(this, _NgtGeometry_geometryArgs, "f")), "f");
    this.ready.emit(this.geometry);
};
NgtGeometry.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtGeometry, deps: [{ token: i0.NgZone }, { token: NGT_OBJECT_3D }], target: i0.ɵɵFactoryTarget.Directive });
NgtGeometry.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtGeometry, outputs: { ready: "ready" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtGeometry, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_3D]
                }] }]; }, propDecorators: { ready: [{
                type: Output
            }] } });

var _NgtLight_lightArgs, _NgtLight_light;
class NgtLight {
    constructor(objectController, ngZone) {
        this.objectController = objectController;
        this.ngZone = ngZone;
        this.ready = new EventEmitter();
        _NgtLight_lightArgs.set(this, []);
        _NgtLight_light.set(this, void 0);
        objectController.initFn = () => {
            __classPrivateFieldSet(this, _NgtLight_light, new this.lightType(...__classPrivateFieldGet(this, _NgtLight_lightArgs, "f")), "f");
            if (this.intensity) {
                applyProps(this.light, { intensity: this.intensity });
            }
            if (this.shadow) {
                applyProps(this.light, this.shadow);
            }
            return __classPrivateFieldGet(this, _NgtLight_light, "f");
        };
        objectController.readyFn = () => {
            this.ready.emit(this.light);
        };
    }
    set lightArgs(v) {
        __classPrivateFieldSet(this, _NgtLight_lightArgs, Array.isArray(v) ? v : [v], "f");
        this.ngZone.runOutsideAngular(() => {
            this.objectController.init();
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!__classPrivateFieldGet(this, _NgtLight_light, "f")) {
                this.objectController.init();
            }
        });
    }
    get light() {
        return __classPrivateFieldGet(this, _NgtLight_light, "f");
    }
}
_NgtLight_lightArgs = new WeakMap(), _NgtLight_light = new WeakMap();
NgtLight.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtLight, deps: [{ token: NGT_OBJECT_WATCHED_CONTROLLER }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgtLight.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtLight, inputs: { intensity: "intensity", shadow: "shadow" }, outputs: { ready: "ready" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtLight, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: NgtObject3dController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_WATCHED_CONTROLLER]
                }] }, { type: i0.NgZone }]; }, propDecorators: { ready: [{
                type: Output
            }], intensity: [{
                type: Input
            }], shadow: [{
                type: Input
            }] } });

var _NgtAttribute_attributeArgs, _NgtAttribute_attribute, _NgtAttribute_defaultValue;
class NgtAttribute {
    constructor(ngZone, geometryDirective) {
        this.ngZone = ngZone;
        this.geometryDirective = geometryDirective;
        _NgtAttribute_attributeArgs.set(this, []);
        _NgtAttribute_attribute.set(this, void 0);
        _NgtAttribute_defaultValue.set(this, void 0);
    }
    set attributeArgs(v) {
        __classPrivateFieldSet(this, _NgtAttribute_attributeArgs, Array.isArray(v) ? v : [v], "f");
        this.ngZone.runOutsideAngular(() => {
            this.init();
        });
    }
    ngOnChanges() {
        this.ngZone.runOutsideAngular(() => {
            if (this.attribute) {
                this.attribute.needsUpdate = true;
            }
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!this.attribute) {
                this.init();
            }
        });
    }
    init() {
        if (this.geometryDirective && this.attach) {
            __classPrivateFieldSet(this, _NgtAttribute_attribute, new this.attributeType(...__classPrivateFieldGet(this, _NgtAttribute_attributeArgs, "f")), "f");
            if (this.attribute) {
                __classPrivateFieldSet(this, _NgtAttribute_defaultValue, this.geometryDirective.geometry.attributes[this.attach], "f");
                this.geometryDirective.geometry.setAttribute(this.attach, this.attribute);
            }
        }
    }
    ngOnDestroy() {
        this.ngZone.runOutsideAngular(() => {
            if (this.geometryDirective && this.attach) {
                if (__classPrivateFieldGet(this, _NgtAttribute_defaultValue, "f") !== undefined) {
                    this.geometryDirective.geometry.setAttribute(this.attach, __classPrivateFieldGet(this, _NgtAttribute_defaultValue, "f"));
                }
                else {
                    this.geometryDirective.geometry.deleteAttribute(this.attach);
                }
            }
        });
    }
    get attribute() {
        return __classPrivateFieldGet(this, _NgtAttribute_attribute, "f");
    }
}
_NgtAttribute_attributeArgs = new WeakMap(), _NgtAttribute_attribute = new WeakMap(), _NgtAttribute_defaultValue = new WeakMap();
NgtAttribute.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAttribute, deps: [{ token: i0.NgZone }, { token: NgtGeometry, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
NgtAttribute.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtAttribute, inputs: { attach: "attach" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtAttribute, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: NgtGeometry, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { attach: [{
                type: Input
            }] } });

var _NgtCurve_instances, _NgtCurve_curveArgs, _NgtCurve_curve, _NgtCurve_init;
class NgtCurve {
    constructor(ngZone, geometryDirective) {
        this.ngZone = ngZone;
        this.geometryDirective = geometryDirective;
        _NgtCurve_instances.add(this);
        _NgtCurve_curveArgs.set(this, []);
        _NgtCurve_curve.set(this, void 0);
    }
    set curveArgs(v) {
        __classPrivateFieldSet(this, _NgtCurve_curveArgs, Array.isArray(v) ? v : [v], "f");
        this.ngZone.runOutsideAngular(() => {
            __classPrivateFieldGet(this, _NgtCurve_instances, "m", _NgtCurve_init).call(this);
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!this.curve) {
                __classPrivateFieldGet(this, _NgtCurve_instances, "m", _NgtCurve_init).call(this);
            }
        });
    }
    get curve() {
        return __classPrivateFieldGet(this, _NgtCurve_curve, "f");
    }
}
_NgtCurve_curveArgs = new WeakMap(), _NgtCurve_curve = new WeakMap(), _NgtCurve_instances = new WeakSet(), _NgtCurve_init = function _NgtCurve_init() {
    __classPrivateFieldSet(this, _NgtCurve_curve, new this.curveType(...__classPrivateFieldGet(this, _NgtCurve_curveArgs, "f")), "f");
    if (this.curve && this.geometryDirective) {
        const points = this.curve.getPoints(this.divisions);
        this.geometryDirective.geometry.setFromPoints(points);
    }
};
NgtCurve.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCurve, deps: [{ token: i0.NgZone }, { token: NgtGeometry, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
NgtCurve.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtCurve, inputs: { divisions: "divisions" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCurve, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: NgtGeometry, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { divisions: [{
                type: Input
            }] } });

var _NgtHelper_helper, _NgtHelper_helperArgs;
class NgtHelper {
    constructor(objectController, ngZone) {
        this.objectController = objectController;
        this.ngZone = ngZone;
        this.ready = new EventEmitter();
        _NgtHelper_helper.set(this, void 0);
        _NgtHelper_helperArgs.set(this, []);
        objectController.initFn = () => {
            __classPrivateFieldSet(this, _NgtHelper_helper, new this.helperType(...__classPrivateFieldGet(this, _NgtHelper_helperArgs, "f")), "f");
            return __classPrivateFieldGet(this, _NgtHelper_helper, "f");
        };
        objectController.readyFn = () => {
            this.ready.emit(this.helper);
        };
    }
    set helperArgs(v) {
        __classPrivateFieldSet(this, _NgtHelper_helperArgs, Array.isArray(v) ? v : [v], "f");
        this.ngZone.runOutsideAngular(() => {
            this.objectController.init();
        });
    }
    ngOnChanges() {
        this.ngZone.runOutsideAngular(() => {
            this.objectController.init();
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!__classPrivateFieldGet(this, _NgtHelper_helper, "f")) {
                this.objectController.init();
            }
        });
    }
    get helper() {
        return __classPrivateFieldGet(this, _NgtHelper_helper, "f");
    }
}
_NgtHelper_helper = new WeakMap(), _NgtHelper_helperArgs = new WeakMap();
NgtHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtHelper, deps: [{ token: NGT_OBJECT_WATCHED_CONTROLLER }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgtHelper.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtHelper, outputs: { ready: "ready" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtHelper, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: NgtObject3dController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_WATCHED_CONTROLLER]
                }] }, { type: i0.NgZone }]; }, propDecorators: { ready: [{
                type: Output
            }] } });

var _NgtMaterial_instances, _NgtMaterial_parameters, _NgtMaterial_material, _NgtMaterial_convertColorToLinear;
class NgtMaterial {
    constructor(ngZone, store, parentObject, contentMaterialController) {
        this.ngZone = ngZone;
        this.store = store;
        this.parentObject = parentObject;
        this.contentMaterialController = contentMaterialController;
        _NgtMaterial_instances.add(this);
        this.ready = new EventEmitter();
        _NgtMaterial_parameters.set(this, void 0);
        _NgtMaterial_material.set(this, void 0);
    }
    set parameters(v) {
        requestAnimationFrame(() => {
            __classPrivateFieldSet(this, _NgtMaterial_parameters, v, "f");
            if (v && this.material) {
                __classPrivateFieldGet(this, _NgtMaterial_instances, "m", _NgtMaterial_convertColorToLinear).call(this, v);
                this.material.setValues(v);
                this.material.needsUpdate = true;
            }
        });
    }
    get parameters() {
        return __classPrivateFieldGet(this, _NgtMaterial_parameters, "f");
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (this.parameters) {
                __classPrivateFieldGet(this, _NgtMaterial_instances, "m", _NgtMaterial_convertColorToLinear).call(this, this.parameters);
            }
            __classPrivateFieldSet(this, _NgtMaterial_material, new this.materialType(this.parameters), "f");
            requestAnimationFrame(() => {
                const parentObject = this.parentObject();
                if (parentObject) {
                    if (this.contentMaterialController &&
                        this.contentMaterialController.isMaterialArray) {
                        if (!Array.isArray(parentObject.material)) {
                            parentObject.material = [];
                        }
                        parentObject.material.push(this.material);
                    }
                    else {
                        parentObject.material = this.material;
                    }
                }
                this.ready.emit(this.material);
            });
        });
    }
    get material() {
        return __classPrivateFieldGet(this, _NgtMaterial_material, "f");
    }
    ngOnDestroy() {
        this.ngZone.runOutsideAngular(() => {
            if (this.material) {
                this.material.dispose();
            }
        });
    }
}
_NgtMaterial_parameters = new WeakMap(), _NgtMaterial_material = new WeakMap(), _NgtMaterial_instances = new WeakSet(), _NgtMaterial_convertColorToLinear = function _NgtMaterial_convertColorToLinear(parameters) {
    if ('color' in parameters) {
        const colorParams = parameters['color'];
        parameters['color'] = makeColor(colorParams);
        if (!this.store.get('linear')) {
            parameters['color'].convertSRGBToLinear();
        }
    }
};
NgtMaterial.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMaterial, deps: [{ token: i0.NgZone }, { token: NgtStore }, { token: NGT_OBJECT_3D }, { token: NgtContentMaterialController, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
NgtMaterial.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtMaterial, inputs: { parameters: "parameters" }, outputs: { ready: "ready" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtMaterial, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: NgtStore }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_3D]
                }] }, { type: NgtContentMaterialController, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { ready: [{
                type: Output
            }], parameters: [{
                type: Input
            }] } });

class NgtCommonMesh {
    constructor(materialGeometryController, ngZone) {
        this.materialGeometryController = materialGeometryController;
        this.ngZone = ngZone;
        this.ready = new EventEmitter();
        if (materialGeometryController) {
            materialGeometryController.readyFn = () => {
                this.ready.emit(this.mesh);
            };
        }
    }
    get mesh() {
        return this.materialGeometryController.objectController.object3d;
    }
}
NgtCommonMesh.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCommonMesh, deps: [{ token: NGT_MATERIAL_GEOMETRY_WATCHED_CONTROLLER, optional: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgtCommonMesh.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtCommonMesh, outputs: { ready: "ready" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCommonMesh, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: NgtMaterialGeometryController, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [NGT_MATERIAL_GEOMETRY_WATCHED_CONTROLLER]
                }] }, { type: i0.NgZone }]; }, propDecorators: { ready: [{
                type: Output
            }] } });

var _NgtCommonSprite_sprite;
class NgtCommonSprite {
    constructor(objectController, ngZone) {
        this.objectController = objectController;
        this.ngZone = ngZone;
        this.ready = new EventEmitter();
        _NgtCommonSprite_sprite.set(this, void 0);
        objectController.initFn = () => {
            if (this.material) {
                __classPrivateFieldSet(this, _NgtCommonSprite_sprite, new this.spriteType(this.material), "f");
            }
            else if (this.materialDirective) {
                if (this.materialDirective.material instanceof THREE.SpriteMaterial) {
                    __classPrivateFieldSet(this, _NgtCommonSprite_sprite, new this.spriteType(this.materialDirective.material), "f");
                }
            }
            return __classPrivateFieldGet(this, _NgtCommonSprite_sprite, "f");
        };
        objectController.readyFn = () => {
            this.ready.emit(this.sprite);
        };
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            this.objectController.init();
        });
    }
    get sprite() {
        return __classPrivateFieldGet(this, _NgtCommonSprite_sprite, "f");
    }
}
_NgtCommonSprite_sprite = new WeakMap();
NgtCommonSprite.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCommonSprite, deps: [{ token: NGT_OBJECT_WATCHED_CONTROLLER }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgtCommonSprite.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtCommonSprite, inputs: { material: "material" }, outputs: { ready: "ready" }, queries: [{ propertyName: "materialDirective", first: true, predicate: NgtMaterial, descendants: true }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCommonSprite, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: NgtObject3dController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_WATCHED_CONTROLLER]
                }] }, { type: i0.NgZone }]; }, propDecorators: { material: [{
                type: Input
            }], ready: [{
                type: Output
            }], materialDirective: [{
                type: ContentChild,
                args: [NgtMaterial]
            }] } });

var _NgtCommonCamera_cameraArgs, _NgtCommonCamera_camera;
class NgtCommonCamera {
    constructor(objectController, ngZone) {
        this.objectController = objectController;
        this.ngZone = ngZone;
        this.ready = new EventEmitter();
        _NgtCommonCamera_cameraArgs.set(this, []);
        _NgtCommonCamera_camera.set(this, void 0);
        objectController.initFn = () => {
            __classPrivateFieldSet(this, _NgtCommonCamera_camera, new this.cameraType(...__classPrivateFieldGet(this, _NgtCommonCamera_cameraArgs, "f")), "f");
            return __classPrivateFieldGet(this, _NgtCommonCamera_camera, "f");
        };
        objectController.readyFn = () => {
            this.ready.emit(this.camera);
        };
    }
    set cameraArgs(v) {
        __classPrivateFieldSet(this, _NgtCommonCamera_cameraArgs, Array.isArray(v) ? v : [v], "f");
        this.ngZone.runOutsideAngular(() => {
            this.objectController.init();
        });
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            if (!__classPrivateFieldGet(this, _NgtCommonCamera_camera, "f")) {
                this.objectController.init();
            }
        });
    }
    get camera() {
        return __classPrivateFieldGet(this, _NgtCommonCamera_camera, "f");
    }
}
_NgtCommonCamera_cameraArgs = new WeakMap(), _NgtCommonCamera_camera = new WeakMap();
NgtCommonCamera.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCommonCamera, deps: [{ token: NGT_OBJECT_WATCHED_CONTROLLER }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgtCommonCamera.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtCommonCamera, outputs: { ready: "ready" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtCommonCamera, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: NgtObject3dController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_WATCHED_CONTROLLER]
                }] }, { type: i0.NgZone }]; }, propDecorators: { ready: [{
                type: Output
            }] } });

var _NgtObjectHelper_object3d, _NgtObjectHelper_objectHelper;
class NgtObjectHelper extends EnhancedRxState {
    constructor(object3dFn, store, animationFrameStore, ngZone) {
        super();
        this.object3dFn = object3dFn;
        this.store = store;
        this.animationFrameStore = animationFrameStore;
        this.ngZone = ngZone;
        _NgtObjectHelper_object3d.set(this, void 0);
        _NgtObjectHelper_objectHelper.set(this, void 0);
        this.set({ args: [] });
    }
    set objectHelperArgs(v) {
        this.set({ args: Array.isArray(v) ? v : [v] });
    }
    ngOnInit() {
        requestAnimationFrame(() => {
            __classPrivateFieldSet(this, _NgtObjectHelper_object3d, this.object3dFn(), "f");
            if (!__classPrivateFieldGet(this, _NgtObjectHelper_object3d, "f")) {
                console.info('Parent is not an object3d');
                return;
            }
            this.holdEffect(this.select('args'), (args) => {
                __classPrivateFieldSet(this, _NgtObjectHelper_objectHelper, new this.objectHelperType(__classPrivateFieldGet(this, _NgtObjectHelper_object3d, "f"), ...args), "f");
                this.store.get('scene').add(this.objectHelper);
                const animationUuid = this.animationFrameStore.register({
                    callback: () => {
                        if (this.objectHelper) {
                            this.objectHelper.update();
                        }
                    },
                });
                return () => {
                    if (this.objectHelper) {
                        this.store.get('scene').remove(this.objectHelper);
                        this.animationFrameStore.actions.unsubscriberUuid(animationUuid);
                    }
                };
            });
        });
    }
    get objectHelper() {
        return __classPrivateFieldGet(this, _NgtObjectHelper_objectHelper, "f");
    }
}
_NgtObjectHelper_object3d = new WeakMap(), _NgtObjectHelper_objectHelper = new WeakMap();
NgtObjectHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObjectHelper, deps: [{ token: NGT_OBJECT_3D }, { token: NgtStore }, { token: NgtAnimationFrameStore }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgtObjectHelper.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtObjectHelper, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtObjectHelper, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_3D]
                }] }, { type: NgtStore }, { type: NgtAnimationFrameStore }, { type: i0.NgZone }]; } });

function buildGraph(object) {
    const data = { nodes: {}, materials: {} };
    if (object) {
        object.traverse((obj) => {
            if (obj.name) {
                data.nodes[obj.name] = obj;
            }
            if (obj.material &&
                !data.materials[obj
                    .material.name]) {
                data.materials[obj
                    .material.name] = obj.material;
            }
        });
    }
    return data;
}

class NgtLoaderService {
    constructor() {
        this.cached = new Map();
    }
    use(loaderConstructor, input, extensions, onProgress) {
        const keys = (Array.isArray(input) ? input : [input]);
        const loader = new loaderConstructor();
        if (extensions) {
            extensions(loader);
        }
        const results$ = forkJoin(keys.map((key) => {
            if (this.cached.has(key)) {
                return of(this.cached.get(key));
            }
            return defer(() => loader.loadAsync(key, onProgress)).pipe(tap((data) => {
                if (data.scene) {
                    Object.assign(data, buildGraph(data.scene));
                }
                this.cached.set(key, data);
            }), catchError((err) => {
                console.error(`Error loading ${key}: ${err.message}`);
                return throwError(err);
            }));
        }));
        return defer(() => Array.isArray(input)
            ? results$
            : results$.pipe(map((results) => results[0]))).pipe(share({
            connector: () => new ReplaySubject(),
            resetOnRefCountZero: true,
            resetOnError: true,
        }));
    }
    ngOnDestroy() {
        this.cached.clear();
    }
}
NgtLoaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtLoaderService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NgtLoaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtLoaderService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtLoaderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

const NGT_IS_WEBGL_AVAILABLE = new InjectionToken('isWebGLAvailable', {
    providedIn: 'root',
    factory: () => {
        const document = inject(DOCUMENT);
        try {
            const canvas = document.createElement('canvas');
            return !!(document.defaultView?.WebGL2RenderingContext &&
                canvas.getContext('webgl2'));
        }
        catch (e) {
            return false;
        }
    },
});

/**
 * Generated bundle index. Do not edit.
 */

export { Controller, EnhancedRxState, NGT_ANIMATION_SUBSCRIBER_CONTROLLER_PROVIDER, NGT_ANIMATION_SUBSCRIBER_WATCHED_CONTROLLER, NGT_AUDIO_CONTROLLER_PROVIDER, NGT_AUDIO_WATCHED_CONTROLLER, NGT_CANVAS_OPTIONS, NGT_CONTENT_GEOMETRY_CONTROLLER_PROVIDER, NGT_CONTENT_GEOMETRY_WATCHED_CONTROLLER, NGT_CONTENT_MATERIAL_CONTROLLER_PROVIDER, NGT_CONTENT_MATERIAL_WATCHED_CONTROLLER, NGT_IS_WEBGL_AVAILABLE, NGT_MATERIAL_GEOMETRY_CONTROLLER_PROVIDER, NGT_MATERIAL_GEOMETRY_WATCHED_CONTROLLER, NGT_OBJECT_3D, NGT_OBJECT_3D_PROVIDER, NGT_OBJECT_CONTROLLER_PROVIDER, NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER, NGT_OBJECT_INPUTS_WATCHED_CONTROLLER, NGT_OBJECT_POST_INIT, NGT_OBJECT_TYPE, NGT_OBJECT_WATCHED_CONTROLLER, NGT_PERFORMANCE_OPTIONS, NGT_RESIZE_BOX_DEFAULT, NGT_RESIZE_DEBOUNCE_DEFAULT, NGT_RESIZE_OBSERVER_SUPPORT, NGT_RESIZE_OPTIONS, NgtAnimationFrameStore, NgtAnimationSubscriberController, NgtAnimationSubscriberControllerModule, NgtAttribute, NgtAudioController, NgtAudioControllerModule, NgtCanvas, NgtColorPipe, NgtColorPipeModule, NgtCommonAudio, NgtCommonCamera, NgtCommonLine, NgtCommonMesh, NgtCommonSprite, NgtContentGeometryController, NgtContentGeometryControllerModule, NgtContentMaterialController, NgtContentMaterialControllerModule, NgtCoreModule, NgtCursor, NgtCursorModule, NgtCurve, NgtDestroyedService, NgtEventsStore, NgtFogExp2Pipe, NgtFogPipe, NgtFogPipeModule, NgtGeometry, NgtHelper, NgtLight, NgtLoaderService, NgtLoopService, NgtMaterial, NgtMaterialGeometryController, NgtMaterialGeometryControllerModule, NgtMathConstantPipe, NgtMathPipe, NgtMathPipeModule, NgtObject3dController, NgtObject3dControllerModule, NgtObject3dInputsController, NgtObject3dInputsControllerModule, NgtObjectHelper, NgtPerformanceStore, NgtRepeat, NgtRepeatModule, NgtResize, NgtSidePipe, NgtSidePipeModule, NgtSobaExtender, NgtStore, NgtTexture, NgtVector2Pipe, NgtVector3Pipe, NgtVector4Pipe, NgtVectorPipeModule, applyProps, buildGraph, capitalize, controllerFactory, createControllerProviderFactory, id, makeColor, makeForSet, makeId, makeVector2, makeVector3, makeVector4, provideCanvasOptions };
//# sourceMappingURL=angular-three-core.mjs.map
