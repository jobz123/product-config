import { __classPrivateFieldGet } from 'tslib';
import * as i2 from '@angular-three/core';
import { EnhancedRxState, NgtMaterial, NGT_OBJECT_3D_PROVIDER, NgtSobaExtender } from '@angular-three/core';
import { presetsObj } from '@angular-three/soba';
import * as i0 from '@angular/core';
import { Directive, Input, NgModule, Injectable, Component, ChangeDetectionStrategy } from '@angular/core';
import { selectSlice } from '@rx-angular/state';
import { combineLatest, startWith, map, switchMap } from 'rxjs';
import * as THREE from 'three';
import { RGBELoader } from 'three-stdlib';
import * as i5 from '@angular-three/core/attributes';
import { NgtBufferAttributeModule } from '@angular-three/core/attributes';
import * as i4 from '@angular-three/core/geometries';
import { NgtBufferGeometryModule } from '@angular-three/core/geometries';
import * as i1 from '@angular-three/core/points';
import { NgtPointsModule } from '@angular-three/core/points';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';

var _NgtSobaEnvironment_instances, _NgtSobaEnvironment_textureParams$, _NgtSobaEnvironment_environmentParams$, _NgtSobaEnvironment_isCubeMap_get;
const CUBEMAP_ROOT = 'https://rawcdn.githack.com/pmndrs/drei-assets/aa3600359ba664d546d05821bcbca42013587df2';
class NgtSobaEnvironment extends EnhancedRxState {
    constructor(loaderService, ngZone, store) {
        super();
        this.loaderService = loaderService;
        this.ngZone = ngZone;
        this.store = store;
        _NgtSobaEnvironment_instances.add(this);
        _NgtSobaEnvironment_textureParams$.set(this, combineLatest([
            this.select(selectSlice(['files', 'path'])),
            this.select('extensions').pipe(startWith(undefined)),
        ]).pipe(map(([{ path, files }, extensions]) => {
            const loader = __classPrivateFieldGet(this, _NgtSobaEnvironment_instances, "a", _NgtSobaEnvironment_isCubeMap_get) ? THREE.CubeTextureLoader : RGBELoader;
            const urls = __classPrivateFieldGet(this, _NgtSobaEnvironment_instances, "a", _NgtSobaEnvironment_isCubeMap_get) ? [files] : files;
            return { loader, urls, path, extensions };
        })));
        _NgtSobaEnvironment_environmentParams$.set(this, combineLatest([
            this.select(selectSlice(['texture', 'background'])),
            this.select('scene').pipe(startWith(undefined)),
        ]).pipe(map(([{ texture, background }, scene]) => ({ texture, background, scene }))));
        this.set({
            background: false,
            files: ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'],
            path: '',
            scene: undefined,
            extensions: undefined,
        });
    }
    set background(v) {
        this.set({ background: v });
    }
    set files(v) {
        this.set({ files: v });
    }
    set path(v) {
        this.set({ path: v });
    }
    set preset(v) {
        if (!(v in presetsObj)) {
            throw new Error('Preset must be one of: ' + Object.keys(presetsObj).join(', '));
        }
        this.set({ files: presetsObj[v], path: CUBEMAP_ROOT + '/hdri/' });
    }
    set scene(v) {
        this.set({ scene: v });
    }
    set extensions(v) {
        this.set({ extensions: v });
    }
    ngOnInit() {
        this.hold(__classPrivateFieldGet(this, _NgtSobaEnvironment_textureParams$, "f").pipe(switchMap(({ path, extensions, loader, urls }) => 
        // @ts-ignore
        this.loaderService.use(loader, urls, (innerLoader) => {
            innerLoader.setPath(path);
            if (extensions) {
                extensions(innerLoader);
            }
        }))), (textureResult) => {
            const renderer = this.store.get('renderer');
            const gen = new THREE.PMREMGenerator(renderer);
            const texture = NgtSobaEnvironment.getTexture(textureResult, gen, __classPrivateFieldGet(this, _NgtSobaEnvironment_instances, "a", _NgtSobaEnvironment_isCubeMap_get));
            gen.dispose();
            this.set({ texture });
        });
        this.holdEffect(__classPrivateFieldGet(this, _NgtSobaEnvironment_environmentParams$, "f"), ({ texture, scene, background }) => {
            const defaultScene = this.store.get('scene');
            const oldBg = scene ? scene.background : defaultScene.background;
            const oldEnv = scene ? scene.environment : defaultScene.environment;
            if (scene) {
                scene.environment = texture;
                if (background)
                    scene.background = texture;
            }
            else {
                defaultScene.environment = texture;
                if (background)
                    defaultScene.background = texture;
            }
            return () => {
                if (scene) {
                    scene.environment = oldEnv;
                    scene.background = oldBg;
                }
                else {
                    defaultScene.environment = oldEnv;
                    defaultScene.background = oldBg;
                }
                texture.dispose();
            };
        });
    }
    static getTexture(texture, gen, isCubeMap) {
        if (isCubeMap) {
            gen.compileEquirectangularShader();
            return gen.fromCubemap(texture).texture;
        }
        return gen.fromEquirectangular(texture).texture;
    }
}
_NgtSobaEnvironment_textureParams$ = new WeakMap(), _NgtSobaEnvironment_environmentParams$ = new WeakMap(), _NgtSobaEnvironment_instances = new WeakSet(), _NgtSobaEnvironment_isCubeMap_get = function _NgtSobaEnvironment_isCubeMap_get() {
    return Array.isArray(this.get('files'));
};
NgtSobaEnvironment.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaEnvironment, deps: [{ token: i2.NgtLoaderService }, { token: i0.NgZone }, { token: i2.NgtStore }], target: i0.ɵɵFactoryTarget.Directive });
NgtSobaEnvironment.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaEnvironment, selector: "ngt-soba-environment", inputs: { background: "background", files: "files", path: "path", preset: "preset", scene: "scene", extensions: "extensions" }, exportAs: ["ngtSobaEnvironment"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaEnvironment, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ngt-soba-environment',
                    exportAs: 'ngtSobaEnvironment',
                }]
        }], ctorParameters: function () { return [{ type: i2.NgtLoaderService }, { type: i0.NgZone }, { type: i2.NgtStore }]; }, propDecorators: { background: [{
                type: Input
            }], files: [{
                type: Input
            }], path: [{
                type: Input
            }], preset: [{
                type: Input
            }], scene: [{
                type: Input
            }], extensions: [{
                type: Input
            }] } });
class NgtSobaEnvironmentModule {
}
NgtSobaEnvironmentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaEnvironmentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSobaEnvironmentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaEnvironmentModule, declarations: [NgtSobaEnvironment], exports: [NgtSobaEnvironment] });
NgtSobaEnvironmentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaEnvironmentModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaEnvironmentModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtSobaEnvironment],
                    exports: [NgtSobaEnvironment],
                }]
        }] });

class StarFieldMaterial extends THREE.ShaderMaterial {
    constructor() {
        super({
            uniforms: { time: { value: 0.0 }, fade: { value: 1.0 } },
            vertexShader: /* glsl */ `
      uniform float time;
      attribute float size;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(mvPosition.x + 2.0 * time + 100.0));
        gl_Position = projectionMatrix * mvPosition;
      }`,
            fragmentShader: /* glsl */ `
      uniform sampler2D pointTexture;
      uniform float fade;
      varying vec3 vColor;
      void main() {
        float opacity = 1.0;
        if (fade == 1.0) {
          float d = distance(gl_PointCoord, vec2(0.5, 0.5));
          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
        }
        gl_FragColor = vec4(vColor, opacity);
      }`,
        });
    }
}
class NgtSobaStarFieldMaterial extends NgtMaterial {
    constructor() {
        super(...arguments);
        this.materialType = StarFieldMaterial;
    }
}
NgtSobaStarFieldMaterial.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarFieldMaterial, deps: null, target: i0.ɵɵFactoryTarget.Directive });
NgtSobaStarFieldMaterial.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaStarFieldMaterial, selector: "ngt-soba-star-field-material", providers: [
        { provide: NgtMaterial, useExisting: NgtSobaStarFieldMaterial },
        NGT_OBJECT_3D_PROVIDER,
    ], exportAs: ["ngtSobaStarFieldMaterial"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarFieldMaterial, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ngt-soba-star-field-material',
                    exportAs: 'ngtSobaStarFieldMaterial',
                    providers: [
                        { provide: NgtMaterial, useExisting: NgtSobaStarFieldMaterial },
                        NGT_OBJECT_3D_PROVIDER,
                    ],
                }]
        }] });
class NgtSobaStarFieldMaterialModule {
}
NgtSobaStarFieldMaterialModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarFieldMaterialModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSobaStarFieldMaterialModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarFieldMaterialModule, declarations: [NgtSobaStarFieldMaterial], exports: [NgtSobaStarFieldMaterial] });
NgtSobaStarFieldMaterialModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarFieldMaterialModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarFieldMaterialModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtSobaStarFieldMaterial],
                    exports: [NgtSobaStarFieldMaterial],
                }]
        }] });

const genStar = (r) => {
    return new THREE.Vector3().setFromSpherical(new THREE.Spherical(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
};
class NgtSobaStarsStore extends EnhancedRxState {
    constructor() {
        super();
        this.attributes$ = this.select(selectSlice(['radius', 'depth', 'count', 'factor', 'saturation']), map(({ depth, count, factor, radius, saturation }) => {
            const positions = [];
            const colors = [];
            const sizes = Array.from({ length: count }, () => (0.5 + 0.5 * Math.random()) * factor);
            const color = new THREE.Color();
            let r = radius + depth;
            const increment = depth / count;
            for (let i = 0; i < count; i++) {
                r -= increment * Math.random();
                positions.push(...genStar(r).toArray());
                color.setHSL(i / count, saturation, 0.9);
                colors.push(color.r, color.g, color.b);
            }
            return {
                positions: new Float32Array(positions),
                colors: new Float32Array(colors),
                sizes: new Float32Array(sizes),
                fade: this.get('fade'),
            };
        }));
        this.set({
            radius: 100,
            depth: 50,
            count: 5000,
            saturation: 0,
            factor: 4,
            fade: false,
        });
    }
}
NgtSobaStarsStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarsStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NgtSobaStarsStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarsStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarsStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });
class NgtSobaStars extends NgtSobaExtender {
    constructor(sobaStarsStore) {
        super();
        this.sobaStarsStore = sobaStarsStore;
        this.blending = THREE.AdditiveBlending;
        this.attributes$ = this.sobaStarsStore.attributes$;
    }
    set radius(radius) {
        this.sobaStarsStore.set({ radius });
    }
    set depth(depth) {
        this.sobaStarsStore.set({ depth });
    }
    set count(count) {
        this.sobaStarsStore.set({ count });
    }
    set factor(factor) {
        this.sobaStarsStore.set({ factor });
    }
    set saturation(saturation) {
        this.sobaStarsStore.set({ saturation });
    }
    set fade(fade) {
        this.sobaStarsStore.set({ fade });
    }
    onAnimate({ clock }) {
        if (this.starMaterial) {
            this.starMaterial.uniforms.time.value = clock.getElapsedTime();
        }
    }
}
NgtSobaStars.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStars, deps: [{ token: NgtSobaStarsStore }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaStars.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaStars, selector: "ngt-soba-stars", inputs: { radius: "radius", depth: "depth", count: "count", factor: "factor", saturation: "saturation", fade: "fade" }, providers: [
        {
            provide: NgtSobaExtender,
            useExisting: NgtSobaStars,
        },
        NgtSobaStarsStore,
    ], usesInheritance: true, ngImport: i0, template: `
    <ngt-points (ready)="object = $event" (animateReady)="onAnimate($event)">
      <ng-container *ngIf="attributes$ | async as attributes">
        <ngt-buffer-geometry>
          <ngt-buffer-attribute
            attach="position"
            [args]="[attributes.positions, 3]"
          ></ngt-buffer-attribute>
          <ngt-buffer-attribute
            attach="color"
            [args]="[attributes.colors, 3]"
          ></ngt-buffer-attribute>
          <ngt-buffer-attribute
            attach="size"
            [args]="[attributes.sizes, 1]"
          ></ngt-buffer-attribute>
        </ngt-buffer-geometry>
        <ngt-soba-star-field-material
          #sobaStarFieldMaterial="ngtSobaStarFieldMaterial"
          (ready)="starMaterial = $event"
          [parameters]="{
            vertexColors: true,
            transparent: true,
            blending: this.blending,
            uniforms: {
              fade: { value: attributes.fade },
              time: sobaStarFieldMaterial.material?.uniforms?.time || {
                value: 0
              }
            }
          }"
        ></ngt-soba-star-field-material>
      </ng-container>
    </ngt-points>
  `, isInline: true, directives: [{ type: i1.NgtPoints, selector: "ngt-points", outputs: ["ready"], exportAs: ["ngtPoints"] }, { type: i2.NgtMaterialGeometryController, selector: "    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-points  ", inputs: ["morphTargetInfluences", "morphTargetDictionary"], exportAs: ["ngtMaterialGeometryController"] }, { type: i2.NgtObject3dController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera  ", exportAs: ["ngtObject3dController"] }, { type: i2.NgtObject3dInputsController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }, { type: i2.NgtContentMaterialController, selector: "    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-text,,    ngt-points  ", inputs: ["material", "isMaterialArray", "contentMaterialController"], exportAs: ["ngtContentMaterialController"] }, { type: i2.NgtContentGeometryController, selector: "    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-points  ", inputs: ["geometry", "contentGeometryController"], exportAs: ["ngtContentGeometryController"] }, { type: i2.NgtAnimationSubscriberController, selector: "[animateReady]", inputs: ["priority"], outputs: ["animateReady"], exportAs: ["ngtAnimationSubscriberController"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4.NgtBufferGeometry, selector: "ngt-buffer-geometry", inputs: ["args"], exportAs: ["ngtBufferGeometry"] }, { type: i5.NgtBufferAttribute, selector: "ngt-buffer-attribute", inputs: ["args"], exportAs: ["ngtBufferAttribute"] }, { type: NgtSobaStarFieldMaterial, selector: "ngt-soba-star-field-material", exportAs: ["ngtSobaStarFieldMaterial"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStars, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-stars',
                    template: `
    <ngt-points (ready)="object = $event" (animateReady)="onAnimate($event)">
      <ng-container *ngIf="attributes$ | async as attributes">
        <ngt-buffer-geometry>
          <ngt-buffer-attribute
            attach="position"
            [args]="[attributes.positions, 3]"
          ></ngt-buffer-attribute>
          <ngt-buffer-attribute
            attach="color"
            [args]="[attributes.colors, 3]"
          ></ngt-buffer-attribute>
          <ngt-buffer-attribute
            attach="size"
            [args]="[attributes.sizes, 1]"
          ></ngt-buffer-attribute>
        </ngt-buffer-geometry>
        <ngt-soba-star-field-material
          #sobaStarFieldMaterial="ngtSobaStarFieldMaterial"
          (ready)="starMaterial = $event"
          [parameters]="{
            vertexColors: true,
            transparent: true,
            blending: this.blending,
            uniforms: {
              fade: { value: attributes.fade },
              time: sobaStarFieldMaterial.material?.uniforms?.time || {
                value: 0
              }
            }
          }"
        ></ngt-soba-star-field-material>
      </ng-container>
    </ngt-points>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        {
                            provide: NgtSobaExtender,
                            useExisting: NgtSobaStars,
                        },
                        NgtSobaStarsStore,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: NgtSobaStarsStore }]; }, propDecorators: { radius: [{
                type: Input
            }], depth: [{
                type: Input
            }], count: [{
                type: Input
            }], factor: [{
                type: Input
            }], saturation: [{
                type: Input
            }], fade: [{
                type: Input
            }] } });
class NgtSobaStarsModule {
}
NgtSobaStarsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSobaStarsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarsModule, declarations: [NgtSobaStars], imports: [NgtPointsModule,
        NgtBufferGeometryModule,
        NgtBufferAttributeModule,
        NgtSobaStarFieldMaterialModule,
        CommonModule], exports: [NgtSobaStars] });
NgtSobaStarsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarsModule, imports: [[
            NgtPointsModule,
            NgtBufferGeometryModule,
            NgtBufferAttributeModule,
            NgtSobaStarFieldMaterialModule,
            CommonModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaStarsModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtSobaStars],
                    exports: [NgtSobaStars],
                    imports: [
                        NgtPointsModule,
                        NgtBufferGeometryModule,
                        NgtBufferAttributeModule,
                        NgtSobaStarFieldMaterialModule,
                        CommonModule,
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgtSobaEnvironment, NgtSobaEnvironmentModule, NgtSobaStarFieldMaterial, NgtSobaStarFieldMaterialModule, NgtSobaStars, NgtSobaStarsModule, NgtSobaStarsStore, StarFieldMaterial };
//# sourceMappingURL=angular-three-soba-staging.mjs.map
