import { NgtColor, NgtMaterial, NgtObject3dInputsController, NgtSobaExtender } from '@angular-three/core';
import { NgtTextureLoaderService } from '@angular-three/soba/loaders';
import { OnChanges } from '@angular/core';
import { Observable } from 'rxjs';
import * as THREE from 'three';
import * as i0 from "@angular/core";
import * as i1 from "@angular-three/core/meshes";
import * as i2 from "@angular-three/core/geometries";
import * as i3 from "@angular/common";
import * as i4 from "@angular-three/core";
export declare type NgtSobaImageShaderMaterialParameters = THREE.ShaderMaterialParameters & {
    scale?: number[];
    imageBounds?: number[];
    color?: NgtColor;
    map: THREE.Texture;
    zoom?: number;
    grayscale?: number;
};
export declare const ImageShaderMaterial: new () => {
    type: string;
    defines: {
        [key: string]: any;
    };
    uniforms: {
        [uniform: string]: THREE.IUniform<any>;
    };
    vertexShader: string;
    fragmentShader: string;
    linewidth: number;
    wireframe: boolean;
    wireframeLinewidth: number;
    fog: boolean;
    lights: boolean;
    clipping: boolean;
    derivatives: any;
    extensions: {
        derivatives: boolean;
        fragDepth: boolean;
        drawBuffers: boolean;
        shaderTextureLOD: boolean;
    };
    defaultAttributeValues: any;
    index0AttributeName: string | undefined;
    uniformsNeedUpdate: boolean;
    glslVersion: THREE.GLSLVersion | null;
    isShaderMaterial: boolean;
    setValues(parameters: THREE.ShaderMaterialParameters): void;
    toJSON(meta: any): any;
    alphaTest: number;
    alphaToCoverage: boolean;
    blendDst: THREE.BlendingDstFactor;
    blendDstAlpha: number | null;
    blendEquation: THREE.BlendingEquation;
    blendEquationAlpha: number | null;
    blending: THREE.Blending;
    blendSrc: THREE.BlendingDstFactor | THREE.BlendingSrcFactor;
    blendSrcAlpha: number | null;
    clipIntersection: boolean;
    clippingPlanes: any;
    clipShadows: boolean;
    colorWrite: boolean;
    depthFunc: THREE.DepthModes;
    depthTest: boolean;
    depthWrite: boolean;
    format: THREE.PixelFormat;
    id: number;
    stencilWrite: boolean;
    stencilFunc: THREE.StencilFunc;
    stencilRef: number;
    stencilWriteMask: number;
    stencilFuncMask: number;
    stencilFail: THREE.StencilOp;
    stencilZFail: THREE.StencilOp;
    stencilZPass: THREE.StencilOp;
    readonly isMaterial: true;
    name: string;
    needsUpdate: boolean;
    opacity: number;
    polygonOffset: boolean;
    polygonOffsetFactor: number;
    polygonOffsetUnits: number;
    precision: "highp" | "mediump" | "lowp" | null;
    premultipliedAlpha: boolean;
    dithering: boolean;
    side: THREE.Side;
    shadowSide: THREE.Side | null;
    toneMapped: boolean;
    transparent: boolean;
    uuid: string;
    vertexColors: boolean;
    visible: boolean;
    userData: any;
    version: number;
    clone(): any;
    copy(material: THREE.Material): any;
    dispose(): void;
    onBeforeCompile(shader: THREE.Shader, renderer: THREE.WebGLRenderer): void;
    customProgramCacheKey(): string;
    addEventListener<T extends string>(type: T, listener: THREE.EventListener<THREE.Event, T, any>): void;
    hasEventListener<T_1 extends string>(type: T_1, listener: THREE.EventListener<THREE.Event, T_1, any>): boolean;
    removeEventListener<T_2 extends string>(type: T_2, listener: THREE.EventListener<THREE.Event, T_2, any>): void;
    dispatchEvent(event: THREE.Event): void;
};
export declare class NgtSobaImageShaderMaterial extends NgtMaterial<NgtSobaImageShaderMaterialParameters, typeof ImageShaderMaterial.prototype> {
    static ngAcceptInputType_parameters: NgtSobaImageShaderMaterialParameters | undefined;
    materialType: new () => {
        type: string;
        defines: {
            [key: string]: any;
        };
        uniforms: {
            [uniform: string]: THREE.IUniform<any>;
        };
        vertexShader: string;
        fragmentShader: string;
        linewidth: number;
        wireframe: boolean;
        wireframeLinewidth: number;
        fog: boolean;
        lights: boolean;
        clipping: boolean;
        derivatives: any;
        extensions: {
            derivatives: boolean;
            fragDepth: boolean;
            drawBuffers: boolean;
            shaderTextureLOD: boolean;
        };
        defaultAttributeValues: any;
        index0AttributeName: string | undefined;
        uniformsNeedUpdate: boolean;
        glslVersion: THREE.GLSLVersion | null;
        isShaderMaterial: boolean;
        setValues(parameters: THREE.ShaderMaterialParameters): void;
        toJSON(meta: any): any;
        alphaTest: number;
        alphaToCoverage: boolean;
        blendDst: THREE.BlendingDstFactor;
        blendDstAlpha: number | null;
        blendEquation: THREE.BlendingEquation;
        blendEquationAlpha: number | null;
        blending: THREE.Blending;
        blendSrc: THREE.BlendingDstFactor | THREE.BlendingSrcFactor;
        blendSrcAlpha: number | null;
        clipIntersection: boolean;
        clippingPlanes: any;
        clipShadows: boolean;
        colorWrite: boolean;
        depthFunc: THREE.DepthModes;
        depthTest: boolean;
        depthWrite: boolean;
        format: THREE.PixelFormat;
        id: number;
        stencilWrite: boolean;
        stencilFunc: THREE.StencilFunc;
        stencilRef: number;
        stencilWriteMask: number;
        stencilFuncMask: number;
        stencilFail: THREE.StencilOp;
        stencilZFail: THREE.StencilOp;
        stencilZPass: THREE.StencilOp;
        readonly isMaterial: true;
        name: string;
        needsUpdate: boolean;
        opacity: number;
        polygonOffset: boolean;
        polygonOffsetFactor: number;
        polygonOffsetUnits: number;
        precision: "highp" | "mediump" | "lowp" | null;
        premultipliedAlpha: boolean;
        dithering: boolean;
        side: THREE.Side;
        shadowSide: THREE.Side | null;
        toneMapped: boolean;
        transparent: boolean;
        uuid: string;
        vertexColors: boolean;
        visible: boolean;
        userData: any;
        version: number;
        clone(): any;
        copy(material: THREE.Material): any;
        dispose(): void;
        onBeforeCompile(shader: THREE.Shader, renderer: THREE.WebGLRenderer): void;
        customProgramCacheKey(): string;
        addEventListener<T extends string>(type: T, listener: THREE.EventListener<THREE.Event, T, any>): void;
        hasEventListener<T_1 extends string>(type: T_1, listener: THREE.EventListener<THREE.Event, T_1, any>): boolean;
        removeEventListener<T_2 extends string>(type: T_2, listener: THREE.EventListener<THREE.Event, T_2, any>): void;
        dispatchEvent(event: THREE.Event): void;
    };
    static ɵfac: i0.ɵɵFactoryDeclaration<NgtSobaImageShaderMaterial, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgtSobaImageShaderMaterial, "ngt-soba-image-shader-material", ["ngtSobaImageShaderMaterial"], {}, {}, never>;
}
export declare class NgtSobaImage extends NgtSobaExtender<THREE.Mesh> implements OnChanges {
    private textureLoaderService;
    objectInputsController: NgtObject3dInputsController;
    segments?: number;
    scale?: number;
    color?: NgtColor;
    zoom?: number;
    grayscale?: number;
    set url(v: string);
    planeBounds?: [number, number];
    imageBounds?: [number, number];
    texture$?: Observable<THREE.Texture>;
    constructor(textureLoaderService: NgtTextureLoaderService, objectInputsController: NgtObject3dInputsController);
    ngOnChanges(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgtSobaImage, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NgtSobaImage, "ngt-soba-image[url]", never, { "segments": "segments"; "scale": "scale"; "color": "color"; "zoom": "zoom"; "grayscale": "grayscale"; "url": "url"; }, {}, never, ["*"]>;
}
export declare class NgtSobaImageModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<NgtSobaImageModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NgtSobaImageModule, [typeof NgtSobaImage, typeof NgtSobaImageShaderMaterial], [typeof i1.NgtMeshModule, typeof i2.NgtPlaneGeometryModule, typeof i3.CommonModule], [typeof NgtSobaImage, typeof NgtSobaImageShaderMaterial, typeof i4.NgtObject3dInputsControllerModule]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NgtSobaImageModule>;
}
