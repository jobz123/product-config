import * as i1 from '@angular-three/core';
import { NgtSobaExtender, NGT_OBJECT_INPUTS_WATCHED_CONTROLLER, NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER, NgtObject3dInputsController, NgtObject3dInputsControllerModule, applyProps, NGT_CONTENT_MATERIAL_WATCHED_CONTROLLER, NGT_CONTENT_MATERIAL_CONTROLLER_PROVIDER, NgtContentMaterialControllerModule, NgtMaterial, Controller, createControllerProviderFactory, EnhancedRxState, NGT_AUDIO_WATCHED_CONTROLLER, NGT_AUDIO_CONTROLLER_PROVIDER, NgtAudioControllerModule, NgtCoreModule, NgtRepeatModule, NgtMathPipeModule } from '@angular-three/core';
import * as i4 from '@angular-three/core/group';
import { NgtGroupModule } from '@angular-three/core/group';
import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, Inject, Input, ContentChild, NgModule, EventEmitter, Output, Directive, Injectable } from '@angular/core';
import { __classPrivateFieldGet, __classPrivateFieldSet } from 'tslib';
import * as i3$1 from '@angular-three/core/primitive';
import { NgtPrimitiveModule } from '@angular-three/core/primitive';
import * as i3 from '@angular/common';
import { CommonModule, DOCUMENT } from '@angular/common';
import { requestAnimationFrame } from '@rx-angular/cdk/zone-less';
import { Text as Text$1 } from 'troika-three-text';
import * as i5 from '@angular-three/core/geometries';
import { NgtPlaneGeometryModule } from '@angular-three/core/geometries';
import * as i3$2 from '@angular-three/core/meshes';
import { NgtMeshModule } from '@angular-three/core/meshes';
import { shaderMaterial } from '@angular-three/soba';
import * as i1$1 from '@angular-three/soba/loaders';
import { tap, combineLatest, map, distinctUntilChanged, startWith, switchMap, filter } from 'rxjs';
import * as THREE from 'three';
import { selectSlice } from '@rx-angular/state';
import { LineMaterial, LineGeometry, Line2 } from 'three-stdlib';
import * as i3$3 from '@angular-three/core/audios';
import { NgtPositionalAudioModule } from '@angular-three/core/audios';
import * as i2 from '@angular-three/soba/cameras';
import { NgtSobaOrthographicCameraModule } from '@angular-three/soba/cameras';
import * as i5$1 from '@angular-three/core/lights';
import { NgtAmbientLightModule, NgtPointLightModule } from '@angular-three/core/lights';
import * as i7 from '@angular-three/core/materials';
import { NgtMeshLambertMaterialModule, NgtMeshBasicMaterialModule, NgtSpriteMaterialModule } from '@angular-three/core/materials';
import * as i6 from '@angular-three/soba/shapes';
import { NgtSobaBoxModule } from '@angular-three/soba/shapes';
import * as i8 from '@angular-three/core/sprites';
import { NgtSpriteModule } from '@angular-three/core/sprites';

class NgtSobaBillboard extends NgtSobaExtender {
    constructor(objectInputsController) {
        super();
        this.objectInputsController = objectInputsController;
        this.follow = true;
        this.lockX = false;
        this.lockY = false;
        this.lockZ = false;
    }
    onGroupAnimate(group, $event) {
        if (!this.follow)
            return;
        this.animateReady.emit($event);
        // save previous rotation in case we're locking an axis
        const prevRotation = group.rotation.clone();
        // always face the camera
        group.quaternion.copy($event.camera.quaternion);
        // readjust any axis that is locked
        if (this.lockX)
            group.rotation.x = prevRotation.x;
        if (this.lockY)
            group.rotation.y = prevRotation.y;
        if (this.lockZ)
            group.rotation.z = prevRotation.z;
    }
    onGroupReady(group) {
        this.object = group;
        if (this.childInputsController) {
            this.childInputsController.appendTo = group;
        }
    }
}
NgtSobaBillboard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaBillboard, deps: [{ token: NGT_OBJECT_INPUTS_WATCHED_CONTROLLER }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaBillboard.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaBillboard, selector: "ngt-soba-billboard", inputs: { follow: "follow", lockX: "lockX", lockY: "lockY", lockZ: "lockZ" }, providers: [
        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
        { provide: NgtSobaExtender, useExisting: NgtSobaBillboard },
    ], queries: [{ propertyName: "childInputsController", first: true, predicate: NgtObject3dInputsController, descendants: true }], usesInheritance: true, ngImport: i0, template: `
    <ngt-group
      #ngtGroup="ngtGroup"
      (ready)="onGroupReady($event)"
      (animateReady)="onGroupAnimate(ngtGroup.group!, $event)"
      [object3dInputsController]="objectInputsController"
    >
      <ng-content></ng-content>
    </ngt-group>
  `, isInline: true, directives: [{ type: i4.NgtGroup, selector: "ngt-group", outputs: ["ready"], exportAs: ["ngtGroup"] }, { type: i1.NgtObject3dController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera  ", exportAs: ["ngtObject3dController"] }, { type: i1.NgtObject3dInputsController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }, { type: i1.NgtAnimationSubscriberController, selector: "[animateReady]", inputs: ["priority"], outputs: ["animateReady"], exportAs: ["ngtAnimationSubscriberController"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaBillboard, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-billboard',
                    template: `
    <ngt-group
      #ngtGroup="ngtGroup"
      (ready)="onGroupReady($event)"
      (animateReady)="onGroupAnimate(ngtGroup.group!, $event)"
      [object3dInputsController]="objectInputsController"
    >
      <ng-content></ng-content>
    </ngt-group>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
                        { provide: NgtSobaExtender, useExisting: NgtSobaBillboard },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i1.NgtObject3dInputsController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_INPUTS_WATCHED_CONTROLLER]
                }] }]; }, propDecorators: { follow: [{
                type: Input
            }], lockX: [{
                type: Input
            }], lockY: [{
                type: Input
            }], lockZ: [{
                type: Input
            }], childInputsController: [{
                type: ContentChild,
                args: [NgtObject3dInputsController]
            }] } });
class NgtSobaBillboardModule {
}
NgtSobaBillboardModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaBillboardModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSobaBillboardModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaBillboardModule, declarations: [NgtSobaBillboard], imports: [NgtGroupModule], exports: [NgtSobaBillboard, NgtObject3dInputsControllerModule] });
NgtSobaBillboardModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaBillboardModule, imports: [[NgtGroupModule], NgtObject3dInputsControllerModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaBillboardModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtSobaBillboard],
                    exports: [NgtSobaBillboard, NgtObject3dInputsControllerModule],
                    imports: [NgtGroupModule],
                }]
        }] });

var _NgtSobaText_text;
class NgtSobaText extends NgtSobaExtender {
    constructor(objectInputsController, contentMaterialController, elRef, ngZone, loopService) {
        super();
        this.objectInputsController = objectInputsController;
        this.contentMaterialController = contentMaterialController;
        this.elRef = elRef;
        this.ngZone = ngZone;
        this.loopService = loopService;
        this.anchorX = 'center';
        this.anchorY = 'middle';
        this.sync = new EventEmitter();
        _NgtSobaText_text.set(this, '');
        ngZone.runOutsideAngular(() => {
            this.object = new Text$1();
        });
    }
    get text() {
        return __classPrivateFieldGet(this, _NgtSobaText_text, "f");
    }
    set text(value) {
        __classPrivateFieldSet(this, _NgtSobaText_text, value.trim(), "f");
    }
    ngOnChanges() {
        this.ngZone.runOutsideAngular(() => {
            if (this.object) {
                this.object.sync(() => {
                    this.loopService.invalidate();
                    if (this.sync.observed) {
                        this.sync.emit(this.object);
                    }
                });
            }
        });
    }
    ngOnInit() {
        requestAnimationFrame(() => {
            this.elRef.nativeElement.childNodes.forEach((childNode) => {
                if (childNode instanceof Text) {
                    this.text += childNode.textContent;
                }
            });
        });
    }
    ngOnDestroy() {
        if (this.object) {
            this.object.dispose();
        }
    }
    onTroikaTextReady(troikaText) {
        requestAnimationFrame(() => {
            troikaText.text = this.text;
            if (this.contentMaterialController.material) {
                troikaText.material = this.contentMaterialController.material;
            }
            applyProps(troikaText, {
                color: this.color,
                fontSize: this.fontSize,
                maxWidth: this.maxWidth,
                lineHeight: this.lineHeight,
                letterSpacing: this.letterSpacing,
                textAlign: this.textAlign,
                font: this.font,
                anchorX: this.anchorX,
                anchorY: this.anchorY,
                clipRect: this.clipRect,
                depthOffset: this.depthOffset,
                direction: this.direction,
                overflowWrap: this.overflowWrap,
                whiteSpace: this.whiteSpace,
                outlineWidth: this.outlineWidth,
                outlineOffsetX: this.outlineOffsetX,
                outlineOffsetY: this.outlineOffsetY,
                outlineBlur: this.outlineBlur,
                outlineColor: this.outlineColor,
                outlineOpacity: this.outlineOpacity,
                strokeWidth: this.strokeWidth,
                strokeColor: this.strokeColor,
                strokeOpacity: this.strokeOpacity,
                fillOpacity: this.fillOpacity,
                debugSDF: this.debugSDF,
            });
        });
    }
}
_NgtSobaText_text = new WeakMap();
NgtSobaText.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaText, deps: [{ token: NGT_OBJECT_INPUTS_WATCHED_CONTROLLER }, { token: NGT_CONTENT_MATERIAL_WATCHED_CONTROLLER }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i1.NgtLoopService }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaText.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaText, selector: "ngt-soba-text", inputs: { color: "color", fontSize: "fontSize", maxWidth: "maxWidth", lineHeight: "lineHeight", letterSpacing: "letterSpacing", textAlign: "textAlign", font: "font", anchorX: "anchorX", anchorY: "anchorY", clipRect: "clipRect", depthOffset: "depthOffset", direction: "direction", overflowWrap: "overflowWrap", whiteSpace: "whiteSpace", outlineWidth: "outlineWidth", outlineOffsetX: "outlineOffsetX", outlineOffsetY: "outlineOffsetY", outlineBlur: "outlineBlur", outlineColor: "outlineColor", outlineOpacity: "outlineOpacity", strokeWidth: "strokeWidth", strokeColor: "strokeColor", strokeOpacity: "strokeOpacity", fillOpacity: "fillOpacity", debugSDF: "debugSDF" }, outputs: { sync: "sync" }, providers: [
        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
        NGT_CONTENT_MATERIAL_CONTROLLER_PROVIDER,
        { provide: NgtSobaExtender, useExisting: NgtSobaText },
    ], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `
    <ng-container *ngIf="object">
      <ngt-primitive
        [object]="$any(object)"
        [object3dInputsController]="objectInputsController"
        (ready)="onTroikaTextReady(object)"
      >
      </ngt-primitive>
    </ng-container>
    <ng-content></ng-content>
  `, isInline: true, directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgtObject3dController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera  ", exportAs: ["ngtObject3dController"] }, { type: i1.NgtObject3dInputsController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }, { type: i3$1.NgtPrimitive, selector: "ngt-primitive[object]", inputs: ["object"], outputs: ["ready"], exportAs: ["ngtPrimitive"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaText, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-text',
                    template: `
    <ng-container *ngIf="object">
      <ngt-primitive
        [object]="$any(object)"
        [object3dInputsController]="objectInputsController"
        (ready)="onTroikaTextReady(object)"
      >
      </ngt-primitive>
    </ng-container>
    <ng-content></ng-content>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
                        NGT_CONTENT_MATERIAL_CONTROLLER_PROVIDER,
                        { provide: NgtSobaExtender, useExisting: NgtSobaText },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i1.NgtObject3dInputsController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_INPUTS_WATCHED_CONTROLLER]
                }] }, { type: i1.NgtContentMaterialController, decorators: [{
                    type: Inject,
                    args: [NGT_CONTENT_MATERIAL_WATCHED_CONTROLLER]
                }] }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i1.NgtLoopService }]; }, propDecorators: { color: [{
                type: Input
            }], fontSize: [{
                type: Input
            }], maxWidth: [{
                type: Input
            }], lineHeight: [{
                type: Input
            }], letterSpacing: [{
                type: Input
            }], textAlign: [{
                type: Input
            }], font: [{
                type: Input
            }], anchorX: [{
                type: Input
            }], anchorY: [{
                type: Input
            }], clipRect: [{
                type: Input
            }], depthOffset: [{
                type: Input
            }], direction: [{
                type: Input
            }], overflowWrap: [{
                type: Input
            }], whiteSpace: [{
                type: Input
            }], outlineWidth: [{
                type: Input
            }], outlineOffsetX: [{
                type: Input
            }], outlineOffsetY: [{
                type: Input
            }], outlineBlur: [{
                type: Input
            }], outlineColor: [{
                type: Input
            }], outlineOpacity: [{
                type: Input
            }], strokeWidth: [{
                type: Input
            }], strokeColor: [{
                type: Input
            }], strokeOpacity: [{
                type: Input
            }], fillOpacity: [{
                type: Input
            }], debugSDF: [{
                type: Input
            }], sync: [{
                type: Output
            }] } });
class NgtSobaTextModule {
}
NgtSobaTextModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaTextModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSobaTextModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaTextModule, declarations: [NgtSobaText], imports: [CommonModule, NgtPrimitiveModule], exports: [NgtSobaText, NgtObject3dInputsControllerModule,
        NgtContentMaterialControllerModule] });
NgtSobaTextModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaTextModule, imports: [[CommonModule, NgtPrimitiveModule], NgtObject3dInputsControllerModule,
        NgtContentMaterialControllerModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaTextModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtSobaText],
                    exports: [
                        NgtSobaText,
                        NgtObject3dInputsControllerModule,
                        NgtContentMaterialControllerModule,
                    ],
                    imports: [CommonModule, NgtPrimitiveModule],
                }]
        }] });

const ImageShaderMaterial = shaderMaterial({
    color: new THREE.Color('white'),
    scale: [1, 1],
    imageBounds: [1, 1],
    map: null,
    zoom: 1,
    grayscale: 0,
}, 
// language=glsl
`
  varying vec2 vUv;
  void main() {
    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
    vUv = uv;
  }
`, 
// language=glsl
`
  // mostly from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
  varying vec2 vUv;
  uniform vec2 scale;
  uniform vec2 imageBounds;
  uniform vec3 color;
  uniform sampler2D map;
  uniform float zoom;
  uniform float grayscale;
  const vec3 luma = vec3(.299, 0.587, 0.114);
  vec4 toGrayscale(vec4 color, float intensity) {
    return vec4(mix(color.rgb, vec3(dot(color.rgb, luma)), intensity), color.a);
  }
  vec2 aspect(vec2 size) {
    return size / min(size.x, size.y);
  }
  void main() {
    vec2 s = aspect(scale);
    vec2 i = aspect(imageBounds);
    float rs = s.x / s.y;
    float ri = i.x / i.y;
    vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
    vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
    vec2 uv = vUv * s / new + offset;
    vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);
    gl_FragColor = toGrayscale(texture2D(map, zUv) * vec4(color, 1.0), grayscale);
  }
`);
class NgtSobaImageShaderMaterial extends NgtMaterial {
    constructor() {
        super(...arguments);
        this.materialType = ImageShaderMaterial;
    }
}
NgtSobaImageShaderMaterial.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaImageShaderMaterial, deps: null, target: i0.ɵɵFactoryTarget.Directive });
NgtSobaImageShaderMaterial.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaImageShaderMaterial, selector: "ngt-soba-image-shader-material", providers: [
        { provide: NgtMaterial, useExisting: NgtSobaImageShaderMaterial },
    ], exportAs: ["ngtSobaImageShaderMaterial"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaImageShaderMaterial, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ngt-soba-image-shader-material',
                    exportAs: 'ngtSobaImageShaderMaterial',
                    providers: [
                        { provide: NgtMaterial, useExisting: NgtSobaImageShaderMaterial },
                    ],
                }]
        }] });
class NgtSobaImage extends NgtSobaExtender {
    constructor(textureLoaderService, objectInputsController) {
        super();
        this.textureLoaderService = textureLoaderService;
        this.objectInputsController = objectInputsController;
    }
    set url(v) {
        this.texture$ = this.textureLoaderService.load(v).pipe(tap((texture) => {
            this.imageBounds = [texture.image.width, texture.image.height];
        }));
    }
    ngOnChanges() {
        this.planeBounds = Array.isArray(this.scale)
            ? [this.scale[0], this.scale[1]]
            : [this.scale, this.scale];
    }
}
NgtSobaImage.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaImage, deps: [{ token: i1$1.NgtTextureLoaderService }, { token: NGT_OBJECT_INPUTS_WATCHED_CONTROLLER }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaImage.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaImage, selector: "ngt-soba-image[url]", inputs: { segments: "segments", scale: "scale", color: "color", zoom: "zoom", grayscale: "grayscale", url: "url" }, providers: [
        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
        { provide: NgtSobaExtender, useExisting: NgtSobaImage },
    ], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `
    <ng-container *ngIf="texture$ | async as texture">
      <ngt-mesh
        [scale]="scale"
        [object3dInputsController]="objectInputsController"
        (ready)="object = $event"
      >
        <ngt-plane-geometry
          [args]="[1, 1, segments, segments]"
        ></ngt-plane-geometry>
        <ngt-soba-image-shader-material
          [parameters]="{color, map: texture, zoom, grayscale, scale: planeBounds, imageBounds}"
        ></ngt-soba-image-shader-material>
        <ng-content></ng-content>
      </ngt-mesh>
    </ng-container>
  `, isInline: true, directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$2.NgtMesh, selector: "ngt-mesh", exportAs: ["ngtMesh"] }, { type: i1.NgtMaterialGeometryController, selector: "    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-points  ", inputs: ["morphTargetInfluences", "morphTargetDictionary"], exportAs: ["ngtMaterialGeometryController"] }, { type: i1.NgtObject3dController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera  ", exportAs: ["ngtObject3dController"] }, { type: i1.NgtObject3dInputsController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }, { type: i1.NgtContentMaterialController, selector: "    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-text,,    ngt-points  ", inputs: ["material", "isMaterialArray", "contentMaterialController"], exportAs: ["ngtContentMaterialController"] }, { type: i1.NgtContentGeometryController, selector: "    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-points  ", inputs: ["geometry", "contentGeometryController"], exportAs: ["ngtContentGeometryController"] }, { type: i5.NgtPlaneGeometry, selector: "ngt-plane-geometry", inputs: ["args"], exportAs: ["ngtPlaneGeometry"] }, { type: NgtSobaImageShaderMaterial, selector: "ngt-soba-image-shader-material", exportAs: ["ngtSobaImageShaderMaterial"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaImage, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-image[url]',
                    template: `
    <ng-container *ngIf="texture$ | async as texture">
      <ngt-mesh
        [scale]="scale"
        [object3dInputsController]="objectInputsController"
        (ready)="object = $event"
      >
        <ngt-plane-geometry
          [args]="[1, 1, segments, segments]"
        ></ngt-plane-geometry>
        <ngt-soba-image-shader-material
          [parameters]="{color, map: texture, zoom, grayscale, scale: planeBounds, imageBounds}"
        ></ngt-soba-image-shader-material>
        <ng-content></ng-content>
      </ngt-mesh>
    </ng-container>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
                        { provide: NgtSobaExtender, useExisting: NgtSobaImage },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i1$1.NgtTextureLoaderService }, { type: i1.NgtObject3dInputsController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_INPUTS_WATCHED_CONTROLLER]
                }] }]; }, propDecorators: { segments: [{
                type: Input
            }], scale: [{
                type: Input
            }], color: [{
                type: Input
            }], zoom: [{
                type: Input
            }], grayscale: [{
                type: Input
            }], url: [{
                type: Input
            }] } });
class NgtSobaImageModule {
}
NgtSobaImageModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaImageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSobaImageModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaImageModule, declarations: [NgtSobaImage, NgtSobaImageShaderMaterial], imports: [NgtMeshModule, NgtPlaneGeometryModule, CommonModule], exports: [NgtSobaImage, NgtSobaImageShaderMaterial, NgtObject3dInputsControllerModule] });
NgtSobaImageModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaImageModule, imports: [[NgtMeshModule, NgtPlaneGeometryModule, CommonModule], NgtObject3dInputsControllerModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaImageModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtSobaImage, NgtSobaImageShaderMaterial],
                    exports: [
                        NgtSobaImage,
                        NgtSobaImageShaderMaterial,
                        NgtObject3dInputsControllerModule,
                    ],
                    imports: [NgtMeshModule, NgtPlaneGeometryModule, CommonModule],
                }]
        }] });

var _NgtSobaLine_resolution, _NgtSobaLine_sobaLineInputsController;
class NgtSobaLineInputsController extends Controller {
    constructor() {
        super(...arguments);
        this.color = 'black';
        this.parameters = {};
    }
    get controller() {
        return this.sobaLineInputsController;
    }
    get props() {
        return ['color', 'vertexColors', 'lineWidth', 'dashed', 'parameters'];
    }
}
NgtSobaLineInputsController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaLineInputsController, deps: null, target: i0.ɵɵFactoryTarget.Directive });
NgtSobaLineInputsController.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaLineInputsController, selector: "ngt-soba-line,ngt-soba-quadratic-bezier-line,ngt-soba-cubic-bezier-line", inputs: { color: "color", vertexColors: "vertexColors", lineWidth: "lineWidth", dashed: "dashed", parameters: "parameters", sobaLineInputsController: "sobaLineInputsController" }, exportAs: ["ngtSobaLineInputsController"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaLineInputsController, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ngt-soba-line,ngt-soba-quadratic-bezier-line,ngt-soba-cubic-bezier-line',
                    exportAs: 'ngtSobaLineInputsController',
                }]
        }], propDecorators: { color: [{
                type: Input
            }], vertexColors: [{
                type: Input
            }], lineWidth: [{
                type: Input
            }], dashed: [{
                type: Input
            }], parameters: [{
                type: Input
            }], sobaLineInputsController: [{
                type: Input
            }] } });
const [NGT_SOBA_LINE_INPUTS_WATCHED_CONTROLLER, NGT_SOBA_LINE_INPUTS_CONTROLLER_PROVIDER,] = createControllerProviderFactory({
    watchedControllerTokenName: 'Watched SobaLine Inputs Controller',
    controller: NgtSobaLineInputsController,
});
class NgtSobaLine extends EnhancedRxState {
    constructor(sobaLineInputsController, objectInputsController, ngZone) {
        super();
        this.sobaLineInputsController = sobaLineInputsController;
        this.objectInputsController = objectInputsController;
        this.ngZone = ngZone;
        _NgtSobaLine_resolution.set(this, new THREE.Vector2(512, 512));
        _NgtSobaLine_sobaLineInputsController.set(this, void 0);
        this.ready = this.select('line');
    }
    set points(points) {
        this.set({ points });
    }
    ngOnInit() {
        __classPrivateFieldSet(this, _NgtSobaLine_sobaLineInputsController, this.sobaLineInputsController.sobaLineInputsController ||
            this.sobaLineInputsController, "f");
        this.set({
            lineMaterial: new LineMaterial(),
        });
        const geometryChanges$ = combineLatest([
            this.select('points'),
            __classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f").change$.pipe(map(() => __classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f").vertexColors), distinctUntilChanged(), startWith(undefined)),
        ]);
        const materialChanges$ = combineLatest([
            this.select('lineMaterial'),
            __classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f").change$.pipe(map((changes) => {
                return {
                    color: (changes.sobaLineInputsController
                        ? changes.sobaLineInputsController.currentValue
                        : __classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f")).color,
                    vertexColors: Boolean((changes.sobaLineInputsController
                        ? changes.sobaLineInputsController.currentValue
                        : __classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f")).vertexColors),
                    linewidth: (changes.sobaLineInputsController
                        ? changes.sobaLineInputsController.currentValue
                        : __classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f")).lineWidth,
                    dashed: (changes.sobaLineInputsController
                        ? changes.sobaLineInputsController.currentValue
                        : __classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f")).dashed,
                    parameters: (changes.sobaLineInputsController
                        ? changes.sobaLineInputsController.currentValue
                        : __classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f")).parameters,
                };
            }), startWith({
                color: __classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f").color,
                vertexColors: Boolean(__classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f").vertexColors),
                linewidth: __classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f").lineWidth,
                dashed: __classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f").dashed,
                parameters: __classPrivateFieldGet(this, _NgtSobaLine_sobaLineInputsController, "f").parameters,
            })),
        ]);
        this.hold(this.select(selectSlice(['line', 'points'])), ({ line }) => {
            line.computeLineDistances();
        });
        this.hold(materialChanges$, ([lineMaterial, { dashed, parameters, vertexColors, color, linewidth },]) => {
            const lineParameters = {
                vertexColors,
                color,
                resolution: __classPrivateFieldGet(this, _NgtSobaLine_resolution, "f"),
                ...parameters,
            };
            if (dashed !== undefined) {
                lineParameters.dashed = dashed;
            }
            if (linewidth !== undefined) {
                lineParameters.linewidth = linewidth;
            }
            lineMaterial.setValues(lineParameters);
            if (dashed) {
                lineMaterial.defines.USE_DASH = '';
            }
            else {
                // Setting lineMaterial.defines.USE_DASH to undefined is apparently not sufficient.
                delete lineMaterial.defines.USE_DASH;
            }
            lineMaterial.needsUpdate = true;
        });
        this.connect('lineGeometry', geometryChanges$, (_, [points, vertexColors]) => {
            return this.ngZone.runOutsideAngular(() => {
                const lineGeometry = new LineGeometry();
                const pValues = points.map((p) => p instanceof THREE.Vector3 ? p.toArray() : p);
                lineGeometry.setPositions(pValues.flat());
                if (vertexColors) {
                    const cValues = vertexColors.map((c) => c instanceof THREE.Color ? c.toArray() : c);
                    lineGeometry.setColors(cValues.flat());
                }
                return lineGeometry;
            });
        });
        this.holdEffect(this.select('lineGeometry'), (lineGeometry) => {
            return () => {
                lineGeometry.dispose();
            };
        });
        this.holdEffect(this.select('lineMaterial'), (lineMaterial) => {
            return () => {
                lineMaterial.dispose();
            };
        });
        this.hold(this.select(selectSlice(['lineGeometry', 'lineMaterial'])), ({ lineMaterial, lineGeometry }) => {
            const line = this.get('line');
            if (!line) {
                this.set({ line: new Line2(lineGeometry, lineMaterial) });
            }
            else {
                line.geometry = lineGeometry;
                line.computeLineDistances();
            }
        });
    }
    get line() {
        return this.get('line');
    }
}
_NgtSobaLine_resolution = new WeakMap(), _NgtSobaLine_sobaLineInputsController = new WeakMap();
NgtSobaLine.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaLine, deps: [{ token: NGT_SOBA_LINE_INPUTS_WATCHED_CONTROLLER }, { token: NGT_OBJECT_INPUTS_WATCHED_CONTROLLER }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaLine.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaLine, selector: "ngt-soba-line[points]", inputs: { points: "points" }, outputs: { ready: "ready" }, providers: [
        NGT_SOBA_LINE_INPUTS_CONTROLLER_PROVIDER,
        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
    ], usesInheritance: true, ngImport: i0, template: `
    <ngt-primitive
      [object]="line"
      [object3dInputsController]="objectInputsController"
    ></ngt-primitive>
  `, isInline: true, directives: [{ type: i1.NgtObject3dController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera  ", exportAs: ["ngtObject3dController"] }, { type: i1.NgtObject3dInputsController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }, { type: i3$1.NgtPrimitive, selector: "ngt-primitive[object]", inputs: ["object"], outputs: ["ready"], exportAs: ["ngtPrimitive"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaLine, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-line[points]',
                    template: `
    <ngt-primitive
      [object]="line"
      [object3dInputsController]="objectInputsController"
    ></ngt-primitive>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NGT_SOBA_LINE_INPUTS_CONTROLLER_PROVIDER,
                        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: NgtSobaLineInputsController, decorators: [{
                    type: Inject,
                    args: [NGT_SOBA_LINE_INPUTS_WATCHED_CONTROLLER]
                }] }, { type: i1.NgtObject3dInputsController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_INPUTS_WATCHED_CONTROLLER]
                }] }, { type: i0.NgZone }]; }, propDecorators: { points: [{
                type: Input
            }], ready: [{
                type: Output
            }] } });
class NgtSobaLineModule {
}
NgtSobaLineModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaLineModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSobaLineModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaLineModule, declarations: [NgtSobaLine, NgtSobaLineInputsController], imports: [NgtPrimitiveModule], exports: [NgtSobaLine, NgtSobaLineInputsController, NgtObject3dInputsControllerModule] });
NgtSobaLineModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaLineModule, imports: [[NgtPrimitiveModule], NgtObject3dInputsControllerModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaLineModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtSobaLine, NgtSobaLineInputsController],
                    exports: [
                        NgtSobaLine,
                        NgtSobaLineInputsController,
                        NgtObject3dInputsControllerModule,
                    ],
                    imports: [NgtPrimitiveModule],
                }]
        }] });

var _NgtSobaQuadraticBezierLine_instances, _NgtSobaQuadraticBezierLine_getPoints;
class NgtSobaQuadraticBezierLine extends EnhancedRxState {
    constructor(sobaLineInputsController, objectInputsController) {
        super();
        this.sobaLineInputsController = sobaLineInputsController;
        this.objectInputsController = objectInputsController;
        _NgtSobaQuadraticBezierLine_instances.add(this);
        this.v = new THREE.Vector3();
        this.set({
            start: [0, 0, 0],
            end: [0, 0, 0],
            segments: 20,
            mid: null,
            curve: new THREE.QuadraticBezierCurve3(undefined, undefined, undefined),
        });
        this.connect('points', this.select(selectSlice(['start', 'end', 'mid', 'segments'])), (_, { segments, mid, end, start }) => __classPrivateFieldGet(this, _NgtSobaQuadraticBezierLine_instances, "m", _NgtSobaQuadraticBezierLine_getPoints).call(this, start, end, mid, segments));
    }
    set start(start) {
        this.set({ start });
    }
    set end(end) {
        this.set({ end });
    }
    set mid(mid) {
        this.set({ mid });
    }
    set segments(segments) {
        this.set({ segments });
    }
    get points() {
        return this.get('points');
    }
    onLineReady(line) {
        line.setPoints = (start, end, mid) => {
            const points = __classPrivateFieldGet(this, _NgtSobaQuadraticBezierLine_instances, "m", _NgtSobaQuadraticBezierLine_getPoints).call(this, start, end, mid);
            if (line.geometry) {
                // @ts-ignore
                line.geometry.setPositions(points.map((p) => p.toArray()).flat());
            }
        };
    }
}
_NgtSobaQuadraticBezierLine_instances = new WeakSet(), _NgtSobaQuadraticBezierLine_getPoints = function _NgtSobaQuadraticBezierLine_getPoints(start, end, mid, segments = 20) {
    const curve = this.get('curve');
    if (start instanceof THREE.Vector3)
        curve.v0.copy(start);
    else
        curve.v0.set(...start);
    if (end instanceof THREE.Vector3)
        curve.v2.copy(end);
    else
        curve.v2.set(...end);
    if (mid instanceof THREE.Vector3) {
        curve.v1.copy(mid);
    }
    else {
        curve.v1.copy(curve.v0
            .clone()
            .add(curve.v2.clone().sub(curve.v0))
            .add(this.v.set(0, curve.v0.y - curve.v2.y, 0)));
    }
    return curve.getPoints(segments);
};
NgtSobaQuadraticBezierLine.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaQuadraticBezierLine, deps: [{ token: NGT_SOBA_LINE_INPUTS_WATCHED_CONTROLLER }, { token: NGT_OBJECT_INPUTS_WATCHED_CONTROLLER }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaQuadraticBezierLine.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaQuadraticBezierLine, selector: "ngt-soba-quadratic-bezier-line[start][end]", inputs: { start: "start", end: "end", mid: "mid", segments: "segments" }, providers: [
        NGT_SOBA_LINE_INPUTS_CONTROLLER_PROVIDER,
        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
    ], usesInheritance: true, ngImport: i0, template: `
    <ngt-soba-line
      *ngIf="points"
      (ready)="onLineReady($any($event))"
      [points]="points"
      [sobaLineInputsController]="sobaLineInputsController"
      [object3dInputsController]="objectInputsController"
    ></ngt-soba-line>
  `, isInline: true, components: [{ type: NgtSobaLine, selector: "ngt-soba-line[points]", inputs: ["points"], outputs: ["ready"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: NgtSobaLineInputsController, selector: "ngt-soba-line,ngt-soba-quadratic-bezier-line,ngt-soba-cubic-bezier-line", inputs: ["color", "vertexColors", "lineWidth", "dashed", "parameters", "sobaLineInputsController"], exportAs: ["ngtSobaLineInputsController"] }, { type: i1.NgtObject3dInputsController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaQuadraticBezierLine, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-quadratic-bezier-line[start][end]',
                    template: `
    <ngt-soba-line
      *ngIf="points"
      (ready)="onLineReady($any($event))"
      [points]="points"
      [sobaLineInputsController]="sobaLineInputsController"
      [object3dInputsController]="objectInputsController"
    ></ngt-soba-line>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NGT_SOBA_LINE_INPUTS_CONTROLLER_PROVIDER,
                        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: NgtSobaLineInputsController, decorators: [{
                    type: Inject,
                    args: [NGT_SOBA_LINE_INPUTS_WATCHED_CONTROLLER]
                }] }, { type: i1.NgtObject3dInputsController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_INPUTS_WATCHED_CONTROLLER]
                }] }]; }, propDecorators: { start: [{
                type: Input
            }], end: [{
                type: Input
            }], mid: [{
                type: Input
            }], segments: [{
                type: Input
            }] } });
class NgtSobaQuadraticBezierLineModule {
}
NgtSobaQuadraticBezierLineModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaQuadraticBezierLineModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSobaQuadraticBezierLineModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaQuadraticBezierLineModule, declarations: [NgtSobaQuadraticBezierLine], imports: [NgtSobaLineModule, CommonModule], exports: [NgtSobaQuadraticBezierLine, NgtSobaLineModule,
        NgtObject3dInputsControllerModule] });
NgtSobaQuadraticBezierLineModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaQuadraticBezierLineModule, imports: [[NgtSobaLineModule, CommonModule], NgtSobaLineModule,
        NgtObject3dInputsControllerModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaQuadraticBezierLineModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtSobaQuadraticBezierLine],
                    exports: [
                        NgtSobaQuadraticBezierLine,
                        NgtSobaLineModule,
                        NgtObject3dInputsControllerModule,
                    ],
                    imports: [NgtSobaLineModule, CommonModule],
                }]
        }] });

class NgtSobaPositionalAudioStore extends EnhancedRxState {
    constructor(loaderService, store) {
        super();
        this.loaderService = loaderService;
        this.store = store;
        this.buffer$ = this.select('url').pipe(switchMap((url) => this.loaderService.use(THREE.AudioLoader, url)));
        this.changes$ = combineLatest([
            this.buffer$,
            this.select(selectSlice(['distance', 'loop'])),
        ]).pipe(map(([buffer, { loop, distance }]) => ({ buffer, loop, distance })));
        this.set({ listener: new THREE.AudioListener(), distance: 1, loop: true });
        this.hold(this.changes$, ({ buffer, loop, distance }) => {
            const { autoplay, audio } = this.get();
            if (audio) {
                audio.setBuffer(buffer);
                audio.setRefDistance(distance);
                audio.setLoop(loop);
                if (autoplay && !audio.isPlaying)
                    audio.play();
            }
        });
        this.holdEffect(this.select('autoplay'), () => {
            const { audio, listener } = this.get();
            const camera = this.store.get('camera');
            if (camera) {
                camera.add(listener);
            }
            return () => {
                if (camera) {
                    camera.remove(listener);
                }
                if (audio) {
                    if (audio.isPlaying)
                        audio.stop();
                    if (audio.source &&
                        audio.source._connected) {
                        audio.disconnect();
                    }
                }
            };
        });
    }
}
NgtSobaPositionalAudioStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaPositionalAudioStore, deps: [{ token: i1.NgtLoaderService }, { token: i1.NgtStore }], target: i0.ɵɵFactoryTarget.Injectable });
NgtSobaPositionalAudioStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaPositionalAudioStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaPositionalAudioStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.NgtLoaderService }, { type: i1.NgtStore }]; } });
class NgtSobaPositionalAudio extends NgtSobaExtender {
    constructor(audioController, sobaPositionalAudioStore) {
        super();
        this.audioController = audioController;
        this.sobaPositionalAudioStore = sobaPositionalAudioStore;
        this.listener$ = this.sobaPositionalAudioStore.select('listener');
        sobaPositionalAudioStore.connect('autoplay', audioController.change$.pipe(map(() => audioController.autoplay || false), startWith(audioController.autoplay || false), distinctUntilChanged()));
    }
    set url(url) {
        this.sobaPositionalAudioStore.set({ url });
    }
    set distance(distance) {
        this.sobaPositionalAudioStore.set({ distance });
    }
    set loop(loop) {
        this.sobaPositionalAudioStore.set({ loop });
    }
    onPositionalAudioReady(audio) {
        this.object = audio;
        this.sobaPositionalAudioStore.set({ audio });
    }
}
NgtSobaPositionalAudio.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaPositionalAudio, deps: [{ token: NGT_AUDIO_WATCHED_CONTROLLER }, { token: NgtSobaPositionalAudioStore }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaPositionalAudio.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaPositionalAudio, selector: "ngt-soba-positional-audio", inputs: { url: "url", distance: "distance", loop: "loop" }, providers: [
        NGT_AUDIO_CONTROLLER_PROVIDER,
        NgtSobaPositionalAudioStore,
        { provide: NgtSobaExtender, useExisting: NgtSobaPositionalAudio },
    ], usesInheritance: true, ngImport: i0, template: `
    <ngt-positional-audio
      *ngIf="listener$ | async as listener"
      (ready)="onPositionalAudioReady($event)"
      [listener]="listener"
      [audioController]="audioController"
    ></ngt-positional-audio>
  `, isInline: true, directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$3.NgtPositionalAudio, selector: "ngt-positional-audio", exportAs: ["ngtPositionalAudio"] }, { type: i1.NgtAudioController, selector: "    ngt-audio,    ngt-positional-audio,    ngt-soba-positional-audio,  ", inputs: ["autoplay", "buffer", "detune", "loop", "loopStart", "loopEnd", "offset", "duration", "playbackRate", "isPlaying", "hasPlaybackControl", "sourceType", "source", "filters", "audioController"], exportAs: ["ngtAudioController"] }, { type: i1.NgtObject3dController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera  ", exportAs: ["ngtObject3dController"] }, { type: i1.NgtObject3dInputsController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaPositionalAudio, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-positional-audio',
                    template: `
    <ngt-positional-audio
      *ngIf="listener$ | async as listener"
      (ready)="onPositionalAudioReady($event)"
      [listener]="listener"
      [audioController]="audioController"
    ></ngt-positional-audio>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NGT_AUDIO_CONTROLLER_PROVIDER,
                        NgtSobaPositionalAudioStore,
                        { provide: NgtSobaExtender, useExisting: NgtSobaPositionalAudio },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i1.NgtAudioController, decorators: [{
                    type: Inject,
                    args: [NGT_AUDIO_WATCHED_CONTROLLER]
                }] }, { type: NgtSobaPositionalAudioStore }]; }, propDecorators: { url: [{
                type: Input
            }], distance: [{
                type: Input
            }], loop: [{
                type: Input
            }] } });
class NgtSobaPositionalAudioModule {
}
NgtSobaPositionalAudioModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaPositionalAudioModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSobaPositionalAudioModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaPositionalAudioModule, declarations: [NgtSobaPositionalAudio], imports: [NgtPositionalAudioModule, CommonModule], exports: [NgtSobaPositionalAudio, NgtAudioControllerModule] });
NgtSobaPositionalAudioModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaPositionalAudioModule, imports: [[NgtPositionalAudioModule, CommonModule], NgtAudioControllerModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaPositionalAudioModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtSobaPositionalAudio],
                    exports: [NgtSobaPositionalAudio, NgtAudioControllerModule],
                    imports: [NgtPositionalAudioModule, CommonModule],
                }]
        }] });

var _NgtSobaGizmoHelperStore_instances, _NgtSobaGizmoHelperStore_animating, _NgtSobaGizmoHelperStore_focusPoint, _NgtSobaGizmoHelperStore_radius, _NgtSobaGizmoHelperStore_ready$, _NgtSobaGizmoHelperStore_animateStep, _NgtSobaGizmoHelperStore_beforeRender;
const turnRate = 2 * Math.PI; // turn rate in angles per second
const dummy = new THREE.Object3D();
const matrix = new THREE.Matrix4();
const [q1, q2] = [new THREE.Quaternion(), new THREE.Quaternion()];
const target = new THREE.Vector3();
const targetPosition = new THREE.Vector3();
class NgtSobaGizmoHelperStore extends EnhancedRxState {
    constructor(objectInputsController, animationFrameStore, ngZone, store, loopService) {
        super();
        this.store = store;
        this.loopService = loopService;
        _NgtSobaGizmoHelperStore_instances.add(this);
        _NgtSobaGizmoHelperStore_animating.set(this, false);
        _NgtSobaGizmoHelperStore_focusPoint.set(this, new THREE.Vector3());
        _NgtSobaGizmoHelperStore_radius.set(this, 0);
        this.actions = this.create();
        this.gizmoProps$ = combineLatest([
            this.select(selectSlice(['margin', 'alignment', 'objectInputsController'])),
            this.store.select('size'),
        ]).pipe(map(([{ alignment, margin: [marginX, marginY], objectInputsController, }, size,]) => {
            const x = alignment.endsWith('-left')
                ? -size.width / 2 + marginX
                : size.width / 2 - marginX;
            const y = alignment.startsWith('top-')
                ? size.height / 2 - marginY
                : -size.height / 2 + marginY;
            objectInputsController.position = [x, y, 0];
            return {
                objectInputsController,
                x,
                y,
            };
        }));
        _NgtSobaGizmoHelperStore_ready$.set(this, combineLatest([
            this.actions.init$,
            this.store.select('ready').pipe(filter((ready) => ready)),
        ]));
        const virtualScene = new THREE.Scene();
        objectInputsController.appendTo = virtualScene;
        this.set({
            alignment: 'bottom-right',
            margin: [80, 80],
            renderPriority: 0,
            virtualScene,
            objectInputsController,
        });
        this.holdEffect(__classPrivateFieldGet(this, _NgtSobaGizmoHelperStore_ready$, "f"), () => {
            return ngZone.runOutsideAngular(() => {
                let mainSceneBackground;
                const scene = this.store.get('scene');
                const virtualScene = this.get('virtualScene');
                if (scene.background) {
                    mainSceneBackground = scene.background;
                    scene.background = null;
                    virtualScene.background = mainSceneBackground;
                }
                return () => {
                    if (mainSceneBackground) {
                        scene.background = mainSceneBackground;
                    }
                };
            });
        });
        this.holdEffect(__classPrivateFieldGet(this, _NgtSobaGizmoHelperStore_ready$, "f"), () => {
            return ngZone.runOutsideAngular(() => {
                const priority = this.get('renderPriority');
                const renderer = this.store.get('renderer');
                const animationUuid = animationFrameStore.register({
                    callback: ({ delta }) => {
                        const { virtualScene, virtualCamera, gizmo } = this.get();
                        if (virtualCamera && gizmo) {
                            __classPrivateFieldGet(this, _NgtSobaGizmoHelperStore_instances, "m", _NgtSobaGizmoHelperStore_animateStep).call(this, delta);
                            __classPrivateFieldGet(this, _NgtSobaGizmoHelperStore_instances, "m", _NgtSobaGizmoHelperStore_beforeRender).call(this);
                            renderer.autoClear = false;
                            renderer.clearDepth();
                            renderer.render(virtualScene, virtualCamera);
                        }
                    },
                    priority,
                });
                return () => {
                    animationFrameStore.actions.unsubscriberUuid(animationUuid);
                };
            });
        });
        this.connect('raycast', this.select('virtualCamera'), (_, virtualCamera) => {
            const mouse = this.store.get('mouse');
            const raycaster = new THREE.Raycaster();
            return function (_, intersects) {
                raycaster.setFromCamera(mouse, virtualCamera);
                const rc = this.constructor.prototype.raycast.bind(this);
                if (rc) {
                    rc(raycaster, intersects);
                }
            };
        });
    }
    tweenCamera(direction) {
        const { controls: defaultControls, camera: mainCamera } = this.store.get();
        __classPrivateFieldSet(this, _NgtSobaGizmoHelperStore_animating, true, "f");
        if (defaultControls) {
            __classPrivateFieldSet(this, _NgtSobaGizmoHelperStore_focusPoint, defaultControls.target, "f");
        }
        __classPrivateFieldSet(this, _NgtSobaGizmoHelperStore_radius, mainCamera.position.distanceTo(target), "f");
        // Rotate from current camera orientation
        q1.copy(mainCamera.quaternion);
        // To new current camera orientation
        targetPosition.copy(direction).multiplyScalar(__classPrivateFieldGet(this, _NgtSobaGizmoHelperStore_radius, "f")).add(target);
        dummy.lookAt(targetPosition);
        q2.copy(dummy.quaternion);
        this.loopService.invalidate();
    }
}
_NgtSobaGizmoHelperStore_animating = new WeakMap(), _NgtSobaGizmoHelperStore_focusPoint = new WeakMap(), _NgtSobaGizmoHelperStore_radius = new WeakMap(), _NgtSobaGizmoHelperStore_ready$ = new WeakMap(), _NgtSobaGizmoHelperStore_instances = new WeakSet(), _NgtSobaGizmoHelperStore_animateStep = function _NgtSobaGizmoHelperStore_animateStep(delta) {
    if (!__classPrivateFieldGet(this, _NgtSobaGizmoHelperStore_animating, "f"))
        return;
    if (q1.angleTo(q2) < 0.01) {
        __classPrivateFieldSet(this, _NgtSobaGizmoHelperStore_animating, false, "f");
        return;
    }
    const { controls: defaultControls, camera: mainCamera } = this.store.get();
    const step = delta * turnRate;
    // animate position by doing a lerp and then scaling the position on the unit sphere
    q1.rotateTowards(q2, step);
    // animate orientation
    mainCamera.position
        .set(0, 0, 1)
        .applyQuaternion(q1)
        .multiplyScalar(__classPrivateFieldGet(this, _NgtSobaGizmoHelperStore_radius, "f"))
        .add(__classPrivateFieldGet(this, _NgtSobaGizmoHelperStore_focusPoint, "f"));
    mainCamera.up.set(0, 1, 0).applyQuaternion(q1).normalize();
    mainCamera.quaternion.copy(q1);
    if (defaultControls) {
        defaultControls.update();
    }
    this.loopService.invalidate();
}, _NgtSobaGizmoHelperStore_beforeRender = function _NgtSobaGizmoHelperStore_beforeRender() {
    const mainCamera = this.store.get('camera');
    const gizmo = this.get('gizmo');
    // sync gizmo with main camera orientation
    matrix.copy(mainCamera.matrix).invert();
    gizmo?.quaternion.setFromRotationMatrix(matrix);
};
NgtSobaGizmoHelperStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoHelperStore, deps: [{ token: NGT_OBJECT_INPUTS_WATCHED_CONTROLLER }, { token: i1.NgtAnimationFrameStore }, { token: i0.NgZone }, { token: i1.NgtStore }, { token: i1.NgtLoopService }], target: i0.ɵɵFactoryTarget.Injectable });
NgtSobaGizmoHelperStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoHelperStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoHelperStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.NgtObject3dInputsController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_INPUTS_WATCHED_CONTROLLER]
                }] }, { type: i1.NgtAnimationFrameStore }, { type: i0.NgZone }, { type: i1.NgtStore }, { type: i1.NgtLoopService }]; } });

class NgtSobaGizmoHelper extends NgtSobaExtender {
    constructor(sobaGizmoHelperStore) {
        super();
        this.sobaGizmoHelperStore = sobaGizmoHelperStore;
        this.gizmoProps$ = this.sobaGizmoHelperStore.gizmoProps$;
        this.virtualScene$ = this.sobaGizmoHelperStore.select('virtualScene');
    }
    set alignment(alignment) {
        this.sobaGizmoHelperStore.set({ alignment });
    }
    set margin(margin) {
        this.sobaGizmoHelperStore.set({ margin });
    }
    set renderPriority(renderPriority) {
        this.sobaGizmoHelperStore.set({ renderPriority });
    }
    ngOnInit() {
        this.sobaGizmoHelperStore.actions.init();
    }
    onCameraReady(camera) {
        this.sobaGizmoHelperStore.set({ virtualCamera: camera });
    }
    onGizmoReady(gizmo) {
        this.sobaGizmoHelperStore.set({ gizmo });
        this.object = gizmo;
    }
}
NgtSobaGizmoHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoHelper, deps: [{ token: NgtSobaGizmoHelperStore }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaGizmoHelper.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaGizmoHelper, selector: "ngt-soba-gizmo-helper", inputs: { alignment: "alignment", margin: "margin", renderPriority: "renderPriority" }, providers: [
        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
        NgtSobaGizmoHelperStore,
        {
            provide: NgtSobaExtender,
            useExisting: NgtSobaGizmoHelper,
        },
    ], usesInheritance: true, ngImport: i0, template: `
    <ng-container *ngIf="virtualScene$ | async as virtualScene">
      <ngt-group
        *ngIf="gizmoProps$ | async as gizmoProps"
        (ready)="onGizmoReady($event)"
        [appendTo]="virtualScene"
        [position]="[gizmoProps.x, gizmoProps.y, 0]"
        [object3dInputsController]="gizmoProps.objectInputsController"
      ></ngt-group>
      <ngt-soba-orthographic-camera
        [appendTo]="virtualScene"
        [makeDefault]="false"
        [position]="[0, 0, 200]"
        (ready)="onCameraReady($event)"
      ></ngt-soba-orthographic-camera>
      <ng-content></ng-content>
    </ng-container>
  `, isInline: true, components: [{ type: i2.NgtSobaOrthographicCamera, selector: "ngt-soba-orthographic-camera", inputs: ["makeDefault", "manual", "near", "far"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4.NgtGroup, selector: "ngt-group", outputs: ["ready"], exportAs: ["ngtGroup"] }, { type: i1.NgtObject3dController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera  ", exportAs: ["ngtObject3dController"] }, { type: i1.NgtObject3dInputsController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoHelper, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-gizmo-helper',
                    template: `
    <ng-container *ngIf="virtualScene$ | async as virtualScene">
      <ngt-group
        *ngIf="gizmoProps$ | async as gizmoProps"
        (ready)="onGizmoReady($event)"
        [appendTo]="virtualScene"
        [position]="[gizmoProps.x, gizmoProps.y, 0]"
        [object3dInputsController]="gizmoProps.objectInputsController"
      ></ngt-group>
      <ngt-soba-orthographic-camera
        [appendTo]="virtualScene"
        [makeDefault]="false"
        [position]="[0, 0, 200]"
        (ready)="onCameraReady($event)"
      ></ngt-soba-orthographic-camera>
      <ng-content></ng-content>
    </ng-container>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
                        NgtSobaGizmoHelperStore,
                        {
                            provide: NgtSobaExtender,
                            useExisting: NgtSobaGizmoHelper,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: NgtSobaGizmoHelperStore }]; }, propDecorators: { alignment: [{
                type: Input
            }], margin: [{
                type: Input
            }], renderPriority: [{
                type: Input
            }] } });
class NgtSobaGizmoHelperModule {
}
NgtSobaGizmoHelperModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoHelperModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSobaGizmoHelperModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoHelperModule, declarations: [NgtSobaGizmoHelper], imports: [NgtCoreModule,
        NgtGroupModule,
        NgtSobaOrthographicCameraModule,
        CommonModule], exports: [NgtSobaGizmoHelper] });
NgtSobaGizmoHelperModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoHelperModule, imports: [[
            NgtCoreModule,
            NgtGroupModule,
            NgtSobaOrthographicCameraModule,
            CommonModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoHelperModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtSobaGizmoHelper],
                    exports: [NgtSobaGizmoHelper],
                    imports: [
                        NgtCoreModule,
                        NgtGroupModule,
                        NgtSobaOrthographicCameraModule,
                        CommonModule,
                    ],
                }]
        }] });

var _NgtSobaGizmoFaceMaterial_change$;
const colors = { bg: '#f0f0f0', hover: '#999', text: 'black', stroke: 'black' };
const defaultFaces = ['Right', 'Left', 'Top', 'Bottom', 'Front', 'Back'];
const makePositionVector = (xyz) => new THREE.Vector3(...xyz).multiplyScalar(0.38);
const corners = [
    [1, 1, 1],
    [1, 1, -1],
    [1, -1, 1],
    [1, -1, -1],
    [-1, 1, 1],
    [-1, 1, -1],
    [-1, -1, 1],
    [-1, -1, -1],
].map(makePositionVector);
const cornerDimensions = [0.25, 0.25, 0.25];
const edges = [
    [1, 1, 0],
    [1, 0, 1],
    [1, 0, -1],
    [1, -1, 0],
    [0, 1, 1],
    [0, 1, -1],
    [0, -1, 1],
    [0, -1, -1],
    [-1, 1, 0],
    [-1, 0, 1],
    [-1, 0, -1],
    [-1, -1, 0],
].map(makePositionVector);
const edgeDimensions = edges.map((edge) => edge
    .toArray()
    .map((axis) => (axis == 0 ? 0.5 : 0.25)));
class GenericController extends Controller {
    constructor(ngZone, state) {
        super(ngZone);
        this.state = state;
        this.click = new EventEmitter();
        this.state.set({
            font: '20px Inter var, Arial, sans-serif',
            faces: defaultFaces,
            color: colors.bg,
            hoverColor: colors.hover,
            textColor: colors.text,
            strokeColor: colors.stroke,
            opacity: 1,
        });
    }
    get props() {
        return [
            'font',
            'opacity',
            'color',
            'hoverColor',
            'textColor',
            'strokeColor',
            'faces',
            'click',
        ];
    }
    get controller() {
        return this.genericController;
    }
    set font(font) {
        this.state.set({ font });
    }
    set opacity(opacity) {
        this.state.set({ opacity });
    }
    set color(color) {
        this.state.set({ color });
    }
    set hoverColor(hoverColor) {
        this.state.set({ hoverColor });
    }
    set textColor(textColor) {
        this.state.set({ textColor });
    }
    set strokeColor(strokeColor) {
        this.state.set({ strokeColor });
    }
    set faces(faces) {
        this.state.set({ faces });
    }
    get rxState() {
        return this.genericController?.rxState || this.state;
    }
    get clickOutput() {
        return this.genericController?.click || this.click;
    }
}
GenericController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: GenericController, deps: [{ token: i0.NgZone }, { token: i1.EnhancedRxState }], target: i0.ɵɵFactoryTarget.Directive });
GenericController.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: GenericController, selector: "\n    ngt-soba-gizmo-viewcube,\n    ngt-soba-gizmo-edgecube,\n    ngt-soba-gizmo-facecube,\n    ngt-soba-gizmo-face-material\n  ", inputs: { genericController: "genericController", font: "font", opacity: "opacity", color: "color", hoverColor: "hoverColor", textColor: "textColor", strokeColor: "strokeColor", faces: "faces" }, outputs: { click: "click" }, providers: [EnhancedRxState], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: GenericController, decorators: [{
            type: Directive,
            args: [{
                    selector: `
    ngt-soba-gizmo-viewcube,
    ngt-soba-gizmo-edgecube,
    ngt-soba-gizmo-facecube,
    ngt-soba-gizmo-face-material
  `,
                    providers: [EnhancedRxState],
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i1.EnhancedRxState }]; }, propDecorators: { genericController: [{
                type: Input
            }], font: [{
                type: Input
            }], opacity: [{
                type: Input
            }], color: [{
                type: Input
            }], hoverColor: [{
                type: Input
            }], textColor: [{
                type: Input
            }], strokeColor: [{
                type: Input
            }], faces: [{
                type: Input
            }], click: [{
                type: Output
            }] } });
const [NGT_VIEWCUBE_GENERIC_WATCHED_CONTROLLER, NGT_VIEWCUBE_GENERIC_CONTROLLER_PROVIDER,] = createControllerProviderFactory({
    watchedControllerTokenName: 'Viewcube Generic Controller',
    controller: GenericController,
});
class NgtSobaGizmoViewcube extends NgtSobaExtender {
    constructor(genericController, gizmoHelperStore) {
        super();
        this.genericController = genericController;
        this.gizmoHelperStore = gizmoHelperStore;
        this.corners = corners;
        this.edges = edges;
        this.cornerDimensions = cornerDimensions;
        this.edgeDimensions = edgeDimensions;
        this.gizmo$ = this.gizmoHelperStore.select('gizmo');
    }
}
NgtSobaGizmoViewcube.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoViewcube, deps: [{ token: NGT_VIEWCUBE_GENERIC_WATCHED_CONTROLLER }, { token: NgtSobaGizmoHelperStore }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaGizmoViewcube.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaGizmoViewcube, selector: "ngt-soba-gizmo-viewcube", providers: [
        NGT_VIEWCUBE_GENERIC_CONTROLLER_PROVIDER,
        {
            provide: NgtSobaExtender,
            useExisting: NgtSobaGizmoViewcube,
        },
    ], usesInheritance: true, ngImport: i0, template: `
    <ngt-group
      *ngIf="gizmo$ | async as gizmo"
      [appendTo]="gizmo"
      [scale]="[60, 60, 60]"
      (ready)="object = $event"
    >
      <ngt-soba-gizmo-facecube
        [genericController]="genericController"
      ></ngt-soba-gizmo-facecube>

      <ngt-soba-gizmo-edgecube
        *ngFor="let edge of edges; index as i"
        [position]="edge"
        [dimensions]="edgeDimensions[i]"
        [genericController]="genericController"
      ></ngt-soba-gizmo-edgecube>

      <ngt-soba-gizmo-edgecube
        *ngFor="let corner of corners"
        [position]="corner"
        [dimensions]="cornerDimensions"
        [genericController]="genericController"
      ></ngt-soba-gizmo-edgecube>

      <ngt-ambient-light [intensity]="0.5"></ngt-ambient-light>
      <ngt-point-light
        [intensity]="0.5"
        [position]="[10, 10, 10]"
      ></ngt-point-light>
    </ngt-group>
  `, isInline: true, components: [{ type: i0.forwardRef(function () { return NgtSobaGizmoFacecube; }), selector: "ngt-soba-gizmo-facecube" }, { type: i0.forwardRef(function () { return NgtSobaGizmoEdgecube; }), selector: "ngt-soba-gizmo-edgecube[dimensions][position]", inputs: ["dimensions", "position"] }], directives: [{ type: i0.forwardRef(function () { return i3.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return i4.NgtGroup; }), selector: "ngt-group", outputs: ["ready"], exportAs: ["ngtGroup"] }, { type: i0.forwardRef(function () { return i1.NgtObject3dController; }), selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera  ", exportAs: ["ngtObject3dController"] }, { type: i0.forwardRef(function () { return i1.NgtObject3dInputsController; }), selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }, { type: i0.forwardRef(function () { return GenericController; }), selector: "\n    ngt-soba-gizmo-viewcube,\n    ngt-soba-gizmo-edgecube,\n    ngt-soba-gizmo-facecube,\n    ngt-soba-gizmo-face-material\n  ", inputs: ["genericController", "font", "opacity", "color", "hoverColor", "textColor", "strokeColor", "faces"], outputs: ["click"] }, { type: i0.forwardRef(function () { return i3.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i0.forwardRef(function () { return i5$1.NgtAmbientLight; }), selector: "ngt-ambient-light", inputs: ["args"], exportAs: ["ngtAmbientLight"] }, { type: i0.forwardRef(function () { return i5$1.NgtPointLight; }), selector: "ngt-point-light", inputs: ["args"], exportAs: ["ngtPointLight"] }], pipes: { "async": i0.forwardRef(function () { return i3.AsyncPipe; }) }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoViewcube, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-gizmo-viewcube',
                    template: `
    <ngt-group
      *ngIf="gizmo$ | async as gizmo"
      [appendTo]="gizmo"
      [scale]="[60, 60, 60]"
      (ready)="object = $event"
    >
      <ngt-soba-gizmo-facecube
        [genericController]="genericController"
      ></ngt-soba-gizmo-facecube>

      <ngt-soba-gizmo-edgecube
        *ngFor="let edge of edges; index as i"
        [position]="edge"
        [dimensions]="edgeDimensions[i]"
        [genericController]="genericController"
      ></ngt-soba-gizmo-edgecube>

      <ngt-soba-gizmo-edgecube
        *ngFor="let corner of corners"
        [position]="corner"
        [dimensions]="cornerDimensions"
        [genericController]="genericController"
      ></ngt-soba-gizmo-edgecube>

      <ngt-ambient-light [intensity]="0.5"></ngt-ambient-light>
      <ngt-point-light
        [intensity]="0.5"
        [position]="[10, 10, 10]"
      ></ngt-point-light>
    </ngt-group>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NGT_VIEWCUBE_GENERIC_CONTROLLER_PROVIDER,
                        {
                            provide: NgtSobaExtender,
                            useExisting: NgtSobaGizmoViewcube,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: GenericController, decorators: [{
                    type: Inject,
                    args: [NGT_VIEWCUBE_GENERIC_WATCHED_CONTROLLER]
                }] }, { type: NgtSobaGizmoHelperStore }]; } });
class NgtSobaGizmoEdgecube extends NgtSobaExtender {
    constructor(genericController, gizmoHelperStore, state) {
        super();
        this.genericController = genericController;
        this.gizmoHelperStore = gizmoHelperStore;
        this.state = state;
        this.hover = false;
        this.raycast$ = this.gizmoHelperStore.select('raycast');
        this.vm$ = combineLatest([
            this.state.select(selectSlice(['dimensions', 'position'])),
            this.genericController.rxState
                .select('hoverColor')
                .pipe(startWith(this.genericController.rxState.get('hoverColor'))),
        ]).pipe(map(([{ dimensions, position }, hoverColor]) => ({
            dimensions,
            position,
            hoverColor,
        })));
    }
    set dimensions(dimensions) {
        this.state.set({ dimensions });
    }
    set position(position) {
        this.state.set({ position });
    }
    onEdgeClick($event) {
        if (this.genericController.clickOutput.observed) {
            this.genericController.clickOutput.emit($event);
        }
        else {
            $event.stopPropagation();
            this.gizmoHelperStore.tweenCamera(this.state.get('position'));
        }
    }
}
NgtSobaGizmoEdgecube.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoEdgecube, deps: [{ token: NGT_VIEWCUBE_GENERIC_WATCHED_CONTROLLER }, { token: NgtSobaGizmoHelperStore }, { token: i1.EnhancedRxState }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaGizmoEdgecube.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaGizmoEdgecube, selector: "ngt-soba-gizmo-edgecube[dimensions][position]", inputs: { dimensions: "dimensions", position: "position" }, providers: [
        NGT_VIEWCUBE_GENERIC_CONTROLLER_PROVIDER,
        EnhancedRxState,
        {
            provide: NgtSobaExtender,
            useExisting: NgtSobaGizmoEdgecube,
        },
    ], usesInheritance: true, ngImport: i0, template: `
    <ng-container *ngIf="vm$ | async as vm">
      <ngt-soba-box
        [args]="vm.dimensions"
        [raycast]="raycast$ | async"
        [scale]="[1.01, 1.01, 1.01]"
        [position]="vm.position"
        (pointerover)="$event.stopPropagation(); hover = true"
        (pointerout)="$event.stopPropagation(); hover = false"
        (click)="onEdgeClick($event)"
      >
        <ngt-mesh-basic-material
          [parameters]="{
            color: hover ? vm.hoverColor : 'white',
            transparent: true,
            opacity: 0.6,
            visible: hover
          }"
        ></ngt-mesh-basic-material>
      </ngt-soba-box>
    </ng-container>
  `, isInline: true, components: [{ type: i6.NgtSobaBox, selector: "ngt-soba-box", inputs: ["args"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgtObject3dInputsController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }, { type: i1.NgtContentMaterialController, selector: "    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-text,,    ngt-points  ", inputs: ["material", "isMaterialArray", "contentMaterialController"], exportAs: ["ngtContentMaterialController"] }, { type: i7.NgtMeshBasicMaterial, selector: "ngt-mesh-basic-material", exportAs: ["ngtMeshBasicMaterial"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoEdgecube, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-gizmo-edgecube[dimensions][position]',
                    template: `
    <ng-container *ngIf="vm$ | async as vm">
      <ngt-soba-box
        [args]="vm.dimensions"
        [raycast]="raycast$ | async"
        [scale]="[1.01, 1.01, 1.01]"
        [position]="vm.position"
        (pointerover)="$event.stopPropagation(); hover = true"
        (pointerout)="$event.stopPropagation(); hover = false"
        (click)="onEdgeClick($event)"
      >
        <ngt-mesh-basic-material
          [parameters]="{
            color: hover ? vm.hoverColor : 'white',
            transparent: true,
            opacity: 0.6,
            visible: hover
          }"
        ></ngt-mesh-basic-material>
      </ngt-soba-box>
    </ng-container>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NGT_VIEWCUBE_GENERIC_CONTROLLER_PROVIDER,
                        EnhancedRxState,
                        {
                            provide: NgtSobaExtender,
                            useExisting: NgtSobaGizmoEdgecube,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: GenericController, decorators: [{
                    type: Inject,
                    args: [NGT_VIEWCUBE_GENERIC_WATCHED_CONTROLLER]
                }] }, { type: NgtSobaGizmoHelperStore }, { type: i1.EnhancedRxState }]; }, propDecorators: { dimensions: [{
                type: Input
            }], position: [{
                type: Input
            }] } });
class NgtSobaGizmoFacecube extends NgtSobaExtender {
    constructor(genericController, gizmoHelperStore) {
        super();
        this.genericController = genericController;
        this.gizmoHelperStore = gizmoHelperStore;
        this.hover = null;
        this.raycast$ = this.gizmoHelperStore.select('raycast');
    }
    onFacePointerMove($event) {
        $event.stopPropagation();
        this.hover = Math.floor($event.faceIndex / 2);
    }
    onFacePointerOut($event) {
        $event.stopPropagation();
        this.hover = null;
    }
    onFaceClick($event) {
        if (this.genericController.clickOutput.observed) {
            this.genericController.clickOutput.emit($event);
        }
        else {
            $event.stopPropagation();
            this.gizmoHelperStore.tweenCamera($event.face.normal);
        }
    }
}
NgtSobaGizmoFacecube.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoFacecube, deps: [{ token: NGT_VIEWCUBE_GENERIC_WATCHED_CONTROLLER }, { token: NgtSobaGizmoHelperStore }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaGizmoFacecube.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaGizmoFacecube, selector: "ngt-soba-gizmo-facecube", providers: [
        NGT_VIEWCUBE_GENERIC_CONTROLLER_PROVIDER,
        {
            provide: NgtSobaExtender,
            useExisting: NgtSobaGizmoFacecube,
        },
    ], usesInheritance: true, ngImport: i0, template: `
    <ngt-soba-box
      [isMaterialArray]="true"
      [raycast]="raycast$ | async"
      (ready)="object = $event"
      (click)="onFaceClick($event)"
      (pointermove)="onFacePointerMove($event)"
      (pointerout)="onFacePointerOut($event)"
    >
      <ngt-soba-gizmo-face-material
        *repeat="let index of 6"
        [hover]="hover === index"
        [index]="index"
        [genericController]="genericController"
      ></ngt-soba-gizmo-face-material>
    </ngt-soba-box>
  `, isInline: true, components: [{ type: i0.forwardRef(function () { return i6.NgtSobaBox; }), selector: "ngt-soba-box", inputs: ["args"] }, { type: i0.forwardRef(function () { return NgtSobaGizmoFaceMaterial; }), selector: "ngt-soba-gizmo-face-material[hover][index]", inputs: ["hover", "index"] }], directives: [{ type: i0.forwardRef(function () { return i1.NgtObject3dInputsController; }), selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }, { type: i0.forwardRef(function () { return i1.NgtContentMaterialController; }), selector: "    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-text,,    ngt-points  ", inputs: ["material", "isMaterialArray", "contentMaterialController"], exportAs: ["ngtContentMaterialController"] }, { type: i0.forwardRef(function () { return i1.NgtRepeat; }), selector: "[repeat][repeatOf]", inputs: ["repeatOf"] }, { type: i0.forwardRef(function () { return GenericController; }), selector: "\n    ngt-soba-gizmo-viewcube,\n    ngt-soba-gizmo-edgecube,\n    ngt-soba-gizmo-facecube,\n    ngt-soba-gizmo-face-material\n  ", inputs: ["genericController", "font", "opacity", "color", "hoverColor", "textColor", "strokeColor", "faces"], outputs: ["click"] }], pipes: { "async": i0.forwardRef(function () { return i3.AsyncPipe; }) }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoFacecube, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-gizmo-facecube',
                    template: `
    <ngt-soba-box
      [isMaterialArray]="true"
      [raycast]="raycast$ | async"
      (ready)="object = $event"
      (click)="onFaceClick($event)"
      (pointermove)="onFacePointerMove($event)"
      (pointerout)="onFacePointerOut($event)"
    >
      <ngt-soba-gizmo-face-material
        *repeat="let index of 6"
        [hover]="hover === index"
        [index]="index"
        [genericController]="genericController"
      ></ngt-soba-gizmo-face-material>
    </ngt-soba-box>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NGT_VIEWCUBE_GENERIC_CONTROLLER_PROVIDER,
                        {
                            provide: NgtSobaExtender,
                            useExisting: NgtSobaGizmoFacecube,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: GenericController, decorators: [{
                    type: Inject,
                    args: [NGT_VIEWCUBE_GENERIC_WATCHED_CONTROLLER]
                }] }, { type: NgtSobaGizmoHelperStore }]; } });
class NgtSobaGizmoFaceMaterial {
    constructor(genericController, state, store, document) {
        this.genericController = genericController;
        this.state = state;
        this.store = store;
        this.parameter$ = combineLatest([
            this.state.select(selectSlice(['hover', 'index', 'texture'])),
            this.genericController.rxState.select(selectSlice(['hoverColor', 'opacity']), startWith({
                hoverColor: this.genericController.rxState.get('hoverColor'),
                opacity: this.genericController.rxState.get('opacity'),
            })),
            this.store.select('renderer'),
        ]).pipe(map(([{ texture, hover }, { hoverColor, opacity }, renderer]) => {
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy() || 1;
            return {
                texture,
                color: hover ? hoverColor : 'white',
                opacity: opacity,
            };
        }));
        _NgtSobaGizmoFaceMaterial_change$.set(this, combineLatest([
            this.state.select('index'),
            this.genericController.rxState.select(selectSlice(['font', 'color', 'textColor', 'strokeColor'])),
        ]).pipe(map(([index, { font, color, textColor, strokeColor }]) => ({
            index,
            font,
            color,
            textColor,
            strokeColor,
        }))));
        this.state.connect('texture', __classPrivateFieldGet(this, _NgtSobaGizmoFaceMaterial_change$, "f"), (_, { index, font, color, textColor, strokeColor }) => {
            const faces = this.genericController.rxState.get('faces');
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = color;
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.strokeStyle = strokeColor;
            context.strokeRect(0, 0, canvas.width, canvas.height);
            context.font = font;
            context.textAlign = 'center';
            context.fillStyle = textColor;
            context.fillText(faces[index].toUpperCase(), 64, 76);
            return new THREE.CanvasTexture(canvas);
        });
    }
    set hover(hover) {
        this.state.set({ hover });
    }
    set index(index) {
        this.state.set({ index });
    }
}
_NgtSobaGizmoFaceMaterial_change$ = new WeakMap();
NgtSobaGizmoFaceMaterial.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoFaceMaterial, deps: [{ token: NGT_VIEWCUBE_GENERIC_WATCHED_CONTROLLER }, { token: i1.EnhancedRxState }, { token: i1.NgtStore }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaGizmoFaceMaterial.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaGizmoFaceMaterial, selector: "ngt-soba-gizmo-face-material[hover][index]", inputs: { hover: "hover", index: "index" }, providers: [NGT_VIEWCUBE_GENERIC_CONTROLLER_PROVIDER, EnhancedRxState], ngImport: i0, template: `
    <ngt-mesh-lambert-material
      *ngIf="parameter$ | async as parameter"
      [parameters]="{
        map: parameter.texture,
        color: parameter.color,
        opacity: parameter.opacity,
        transparent: true
      }"
    ></ngt-mesh-lambert-material>
  `, isInline: true, directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i7.NgtMeshLambertMaterial, selector: "ngt-mesh-lambert-material", exportAs: ["ngtMeshLambertMaterial"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoFaceMaterial, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-gizmo-face-material[hover][index]',
                    template: `
    <ngt-mesh-lambert-material
      *ngIf="parameter$ | async as parameter"
      [parameters]="{
        map: parameter.texture,
        color: parameter.color,
        opacity: parameter.opacity,
        transparent: true
      }"
    ></ngt-mesh-lambert-material>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [NGT_VIEWCUBE_GENERIC_CONTROLLER_PROVIDER, EnhancedRxState],
                }]
        }], ctorParameters: function () { return [{ type: GenericController, decorators: [{
                    type: Inject,
                    args: [NGT_VIEWCUBE_GENERIC_WATCHED_CONTROLLER]
                }] }, { type: i1.EnhancedRxState }, { type: i1.NgtStore }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; }, propDecorators: { hover: [{
                type: Input
            }], index: [{
                type: Input
            }] } });
class NgtSobaGizmoViewcubeModule {
}
NgtSobaGizmoViewcubeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoViewcubeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSobaGizmoViewcubeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoViewcubeModule, declarations: [GenericController, NgtSobaGizmoViewcube, NgtSobaGizmoEdgecube, NgtSobaGizmoFacecube, NgtSobaGizmoFaceMaterial], imports: [NgtGroupModule,
        NgtAmbientLightModule,
        NgtPointLightModule,
        NgtMeshLambertMaterialModule,
        CommonModule,
        NgtRepeatModule,
        NgtMeshBasicMaterialModule,
        NgtSobaBoxModule], exports: [NgtSobaGizmoViewcube, GenericController] });
NgtSobaGizmoViewcubeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoViewcubeModule, imports: [[
            NgtGroupModule,
            NgtAmbientLightModule,
            NgtPointLightModule,
            NgtMeshLambertMaterialModule,
            CommonModule,
            NgtRepeatModule,
            NgtMeshBasicMaterialModule,
            NgtSobaBoxModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoViewcubeModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        GenericController,
                        NgtSobaGizmoViewcube,
                        NgtSobaGizmoEdgecube,
                        NgtSobaGizmoFacecube,
                        NgtSobaGizmoFaceMaterial,
                    ],
                    exports: [NgtSobaGizmoViewcube, GenericController],
                    imports: [
                        NgtGroupModule,
                        NgtAmbientLightModule,
                        NgtPointLightModule,
                        NgtMeshLambertMaterialModule,
                        CommonModule,
                        NgtRepeatModule,
                        NgtMeshBasicMaterialModule,
                        NgtSobaBoxModule,
                    ],
                }]
        }] });

var _NgtSobaGizmoAxis_scale, _NgtSobaGizmoAxisHead_changes$;
class NgtSobaGizmoViewport extends NgtSobaExtender {
    constructor(objectInputsController, gizmoHelperStore) {
        super();
        this.objectInputsController = objectInputsController;
        this.gizmoHelperStore = gizmoHelperStore;
        this.axisColors = [
            '#ff3653',
            '#0adb50',
            '#2c8fdf',
        ];
        this.labels = ['X', 'Y', 'Z'];
        this.labelColor = '#000';
        this.font = '18px Inter var, Arial, sans-serif';
        this.axisHeadScale = 1;
        this.hideNegativeAxes = false;
        this.hideAxisHeads = false;
        this.disabled = false;
        this.click = new EventEmitter();
        this.gizmo$ = this.gizmoHelperStore.select('gizmo');
        this.raycast$ = this.gizmoHelperStore.select('raycast');
    }
}
NgtSobaGizmoViewport.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoViewport, deps: [{ token: NGT_OBJECT_INPUTS_WATCHED_CONTROLLER }, { token: NgtSobaGizmoHelperStore }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaGizmoViewport.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaGizmoViewport, selector: "ngt-soba-gizmo-viewport", inputs: { axisColors: "axisColors", labels: "labels", labelColor: "labelColor", font: "font", axisHeadScale: "axisHeadScale", hideNegativeAxes: "hideNegativeAxes", hideAxisHeads: "hideAxisHeads", disabled: "disabled", axisScale: "axisScale" }, outputs: { click: "click" }, providers: [
        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
        { provide: NgtSobaExtender, useExisting: NgtSobaGizmoViewport },
    ], usesInheritance: true, ngImport: i0, template: `
    <ngt-group
      *ngIf="gizmo$ | async as gizmo"
      (ready)="object = $event; object.scale.set(40, 40, 40)"
      [appendTo]="gizmo"
      [object3dInputsController]="objectInputsController"
    >
      <ngt-soba-gizmo-axis
        [color]="axisColors[0]"
        [rotation]="[0, 0, 0]"
        [scale]="axisScale"
      ></ngt-soba-gizmo-axis>
      <ngt-soba-gizmo-axis
        [color]="axisColors[1]"
        [rotation]="[0, 0, 0.5 | mathConst: 'PI']"
        [scale]="axisScale"
      ></ngt-soba-gizmo-axis>
      <ngt-soba-gizmo-axis
        [color]="axisColors[2]"
        [rotation]="[0, -0.5 | mathConst: 'PI', 0]"
        [scale]="axisScale"
      ></ngt-soba-gizmo-axis>
      <ng-container *ngIf="!hideAxisHeads">
        <ng-container *ngIf="{ raycast: raycast$ | async } as vm">
          <ngt-soba-gizmo-axis-head
            [arcStyle]="axisColors[0]"
            [position]="[1, 0, 0]"
            [label]="labels[0]"
            [font]="font"
            [disabled]="disabled"
            [labelColor]="labelColor"
            [raycast]="vm.raycast"
            [axisHeadScale]="axisHeadScale"
          ></ngt-soba-gizmo-axis-head>
          <ngt-soba-gizmo-axis-head
            [arcStyle]="axisColors[1]"
            [position]="[0, 1, 0]"
            [label]="labels[1]"
            [font]="font"
            [disabled]="disabled"
            [labelColor]="labelColor"
            [raycast]="vm.raycast"
            [axisHeadScale]="axisHeadScale"
          ></ngt-soba-gizmo-axis-head>
          <ngt-soba-gizmo-axis-head
            [arcStyle]="axisColors[2]"
            [position]="[0, 0, 1]"
            [label]="labels[2]"
            [font]="font"
            [disabled]="disabled"
            [labelColor]="labelColor"
            [raycast]="vm.raycast"
            [axisHeadScale]="axisHeadScale"
          ></ngt-soba-gizmo-axis-head>

          <ng-container *ngIf="!hideNegativeAxes">
            <ngt-soba-gizmo-axis-head
              [arcStyle]="axisColors[0]"
              [position]="[-1, 0, 0]"
              [font]="font"
              [disabled]="disabled"
              [labelColor]="labelColor"
              [raycast]="vm.raycast"
              [axisHeadScale]="axisHeadScale"
            ></ngt-soba-gizmo-axis-head>
            <ngt-soba-gizmo-axis-head
              [arcStyle]="axisColors[1]"
              [position]="[0, -1, 0]"
              [font]="font"
              [disabled]="disabled"
              [labelColor]="labelColor"
              [raycast]="vm.raycast"
              [axisHeadScale]="axisHeadScale"
            ></ngt-soba-gizmo-axis-head>
            <ngt-soba-gizmo-axis-head
              [arcStyle]="axisColors[2]"
              [position]="[0, 0, -1]"
              [font]="font"
              [disabled]="disabled"
              [labelColor]="labelColor"
              [raycast]="vm.raycast"
              [axisHeadScale]="axisHeadScale"
            ></ngt-soba-gizmo-axis-head>
          </ng-container>
        </ng-container>
      </ng-container>
      <ngt-ambient-light [intensity]="0.5"></ngt-ambient-light>
      <ngt-point-light
        [intensity]="0.5"
        [position]="[10, 10, 10]"
      ></ngt-point-light>
    </ngt-group>
  `, isInline: true, components: [{ type: i0.forwardRef(function () { return NgtSobaGizmoAxis; }), selector: "ngt-soba-gizmo-axis[color][rotation]", inputs: ["color", "rotation", "scale"] }, { type: i0.forwardRef(function () { return NgtSobaGizmoAxisHead; }), selector: "ngt-soba-gizmo-axis-head", inputs: ["arcStyle", "label", "labelColor", "axisHeadScale", "disabled", "font"] }], directives: [{ type: i0.forwardRef(function () { return i3.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return i4.NgtGroup; }), selector: "ngt-group", outputs: ["ready"], exportAs: ["ngtGroup"] }, { type: i0.forwardRef(function () { return i1.NgtObject3dController; }), selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera  ", exportAs: ["ngtObject3dController"] }, { type: i0.forwardRef(function () { return i1.NgtObject3dInputsController; }), selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }, { type: i0.forwardRef(function () { return i5$1.NgtAmbientLight; }), selector: "ngt-ambient-light", inputs: ["args"], exportAs: ["ngtAmbientLight"] }, { type: i0.forwardRef(function () { return i5$1.NgtPointLight; }), selector: "ngt-point-light", inputs: ["args"], exportAs: ["ngtPointLight"] }], pipes: { "async": i0.forwardRef(function () { return i3.AsyncPipe; }), "mathConst": i0.forwardRef(function () { return i1.NgtMathConstantPipe; }) }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoViewport, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-gizmo-viewport',
                    template: `
    <ngt-group
      *ngIf="gizmo$ | async as gizmo"
      (ready)="object = $event; object.scale.set(40, 40, 40)"
      [appendTo]="gizmo"
      [object3dInputsController]="objectInputsController"
    >
      <ngt-soba-gizmo-axis
        [color]="axisColors[0]"
        [rotation]="[0, 0, 0]"
        [scale]="axisScale"
      ></ngt-soba-gizmo-axis>
      <ngt-soba-gizmo-axis
        [color]="axisColors[1]"
        [rotation]="[0, 0, 0.5 | mathConst: 'PI']"
        [scale]="axisScale"
      ></ngt-soba-gizmo-axis>
      <ngt-soba-gizmo-axis
        [color]="axisColors[2]"
        [rotation]="[0, -0.5 | mathConst: 'PI', 0]"
        [scale]="axisScale"
      ></ngt-soba-gizmo-axis>
      <ng-container *ngIf="!hideAxisHeads">
        <ng-container *ngIf="{ raycast: raycast$ | async } as vm">
          <ngt-soba-gizmo-axis-head
            [arcStyle]="axisColors[0]"
            [position]="[1, 0, 0]"
            [label]="labels[0]"
            [font]="font"
            [disabled]="disabled"
            [labelColor]="labelColor"
            [raycast]="vm.raycast"
            [axisHeadScale]="axisHeadScale"
          ></ngt-soba-gizmo-axis-head>
          <ngt-soba-gizmo-axis-head
            [arcStyle]="axisColors[1]"
            [position]="[0, 1, 0]"
            [label]="labels[1]"
            [font]="font"
            [disabled]="disabled"
            [labelColor]="labelColor"
            [raycast]="vm.raycast"
            [axisHeadScale]="axisHeadScale"
          ></ngt-soba-gizmo-axis-head>
          <ngt-soba-gizmo-axis-head
            [arcStyle]="axisColors[2]"
            [position]="[0, 0, 1]"
            [label]="labels[2]"
            [font]="font"
            [disabled]="disabled"
            [labelColor]="labelColor"
            [raycast]="vm.raycast"
            [axisHeadScale]="axisHeadScale"
          ></ngt-soba-gizmo-axis-head>

          <ng-container *ngIf="!hideNegativeAxes">
            <ngt-soba-gizmo-axis-head
              [arcStyle]="axisColors[0]"
              [position]="[-1, 0, 0]"
              [font]="font"
              [disabled]="disabled"
              [labelColor]="labelColor"
              [raycast]="vm.raycast"
              [axisHeadScale]="axisHeadScale"
            ></ngt-soba-gizmo-axis-head>
            <ngt-soba-gizmo-axis-head
              [arcStyle]="axisColors[1]"
              [position]="[0, -1, 0]"
              [font]="font"
              [disabled]="disabled"
              [labelColor]="labelColor"
              [raycast]="vm.raycast"
              [axisHeadScale]="axisHeadScale"
            ></ngt-soba-gizmo-axis-head>
            <ngt-soba-gizmo-axis-head
              [arcStyle]="axisColors[2]"
              [position]="[0, 0, -1]"
              [font]="font"
              [disabled]="disabled"
              [labelColor]="labelColor"
              [raycast]="vm.raycast"
              [axisHeadScale]="axisHeadScale"
            ></ngt-soba-gizmo-axis-head>
          </ng-container>
        </ng-container>
      </ng-container>
      <ngt-ambient-light [intensity]="0.5"></ngt-ambient-light>
      <ngt-point-light
        [intensity]="0.5"
        [position]="[10, 10, 10]"
      ></ngt-point-light>
    </ngt-group>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
                        { provide: NgtSobaExtender, useExisting: NgtSobaGizmoViewport },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i1.NgtObject3dInputsController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_INPUTS_WATCHED_CONTROLLER]
                }] }, { type: NgtSobaGizmoHelperStore }]; }, propDecorators: { axisColors: [{
                type: Input
            }], labels: [{
                type: Input
            }], labelColor: [{
                type: Input
            }], font: [{
                type: Input
            }], axisHeadScale: [{
                type: Input
            }], hideNegativeAxes: [{
                type: Input
            }], hideAxisHeads: [{
                type: Input
            }], disabled: [{
                type: Input
            }], axisScale: [{
                type: Input
            }], click: [{
                type: Output
            }] } });
class NgtSobaGizmoAxis extends NgtSobaExtender {
    constructor() {
        super(...arguments);
        _NgtSobaGizmoAxis_scale.set(this, [0.8, 0.05, 0.05]);
    }
    set scale(v) {
        __classPrivateFieldSet(this, _NgtSobaGizmoAxis_scale, v || __classPrivateFieldGet(this, _NgtSobaGizmoAxis_scale, "f"), "f");
    }
    get scale() {
        return __classPrivateFieldGet(this, _NgtSobaGizmoAxis_scale, "f");
    }
}
_NgtSobaGizmoAxis_scale = new WeakMap();
NgtSobaGizmoAxis.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoAxis, deps: null, target: i0.ɵɵFactoryTarget.Component });
NgtSobaGizmoAxis.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaGizmoAxis, selector: "ngt-soba-gizmo-axis[color][rotation]", inputs: { color: "color", rotation: "rotation", scale: "scale" }, providers: [{ provide: NgtSobaExtender, useExisting: NgtSobaGizmoAxis }], usesInheritance: true, ngImport: i0, template: `
    <ngt-group (ready)="object = $event" [rotation]="rotation">
      <ngt-soba-box [args]="scale" [position]="[0.4, 0, 0]">
        <ngt-mesh-basic-material
          [parameters]="{ color, toneMapped: false }"
        ></ngt-mesh-basic-material>
      </ngt-soba-box>
    </ngt-group>
  `, isInline: true, components: [{ type: i6.NgtSobaBox, selector: "ngt-soba-box", inputs: ["args"] }], directives: [{ type: i4.NgtGroup, selector: "ngt-group", outputs: ["ready"], exportAs: ["ngtGroup"] }, { type: i1.NgtObject3dController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera  ", exportAs: ["ngtObject3dController"] }, { type: i1.NgtObject3dInputsController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }, { type: i1.NgtContentMaterialController, selector: "    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-text,,    ngt-points  ", inputs: ["material", "isMaterialArray", "contentMaterialController"], exportAs: ["ngtContentMaterialController"] }, { type: i7.NgtMeshBasicMaterial, selector: "ngt-mesh-basic-material", exportAs: ["ngtMeshBasicMaterial"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoAxis, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-gizmo-axis[color][rotation]',
                    template: `
    <ngt-group (ready)="object = $event" [rotation]="rotation">
      <ngt-soba-box [args]="scale" [position]="[0.4, 0, 0]">
        <ngt-mesh-basic-material
          [parameters]="{ color, toneMapped: false }"
        ></ngt-mesh-basic-material>
      </ngt-soba-box>
    </ngt-group>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: NgtSobaExtender, useExisting: NgtSobaGizmoAxis }],
                }]
        }], propDecorators: { color: [{
                type: Input
            }], rotation: [{
                type: Input
            }], scale: [{
                type: Input
            }] } });
class NgtSobaGizmoAxisHead extends NgtSobaExtender {
    constructor(objectInputsController, document, gizmoViewport, gizmoHelperStore, store, state) {
        super();
        this.objectInputsController = objectInputsController;
        this.gizmoViewport = gizmoViewport;
        this.gizmoHelperStore = gizmoHelperStore;
        this.store = store;
        this.state = state;
        _NgtSobaGizmoAxisHead_changes$.set(this, this.state.select(selectSlice(['arcStyle', 'label', 'labelColor', 'font'])));
        this.vm$ = combineLatest([
            this.state.select(selectSlice(['active', 'label', 'axisHeadScale', 'texture'])),
            this.store.select('renderer'),
        ]).pipe(map(([{ texture, label, active, axisHeadScale }, renderer]) => {
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy() || 1;
            return {
                texture,
                scale: (label ? 1 : 0.75) * (active ? 1.2 : 1) * axisHeadScale,
                opacity: label ? 1 : 0.75,
            };
        }));
        this.state.set({
            label: '',
            active: false,
            disabled: false,
        });
        this.state.connect('texture', __classPrivateFieldGet(this, _NgtSobaGizmoAxisHead_changes$, "f"), (_, { label, labelColor, arcStyle, font }) => {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.beginPath();
            context.arc(32, 32, 16, 0, 2 * Math.PI);
            context.closePath();
            context.fillStyle = arcStyle;
            context.fill();
            if (label) {
                context.font = font;
                context.textAlign = 'center';
                context.fillStyle = labelColor;
                context.fillText(label, 32, 41);
            }
            return new THREE.CanvasTexture(canvas);
        });
    }
    set arcStyle(arcStyle) {
        this.state.set({ arcStyle });
    }
    set label(label) {
        this.state.set({ label });
    }
    set labelColor(labelColor) {
        this.state.set({ labelColor });
    }
    set axisHeadScale(axisHeadScale) {
        this.state.set({ axisHeadScale });
    }
    set disabled(disabled) {
        this.state.set({ disabled: disabled || false });
    }
    set font(font) {
        this.state.set({ font });
    }
    onAxisHeadPointerOver($event) {
        if (!this.state.get('disabled')) {
            $event.stopPropagation();
            this.state.set({ active: true });
        }
    }
    onAxisHeadPointerOut($event) {
        if (!this.state.get('disabled')) {
            if (this.gizmoViewport.click.observed) {
                this.gizmoViewport.click.emit($event);
            }
            else {
                $event.stopPropagation();
                this.state.set({ active: false });
            }
        }
    }
    onAxisHeadPointerDown($event) {
        if (!this.state.get('disabled')) {
            $event.stopPropagation();
            this.gizmoHelperStore.tweenCamera($event.object.position);
        }
    }
}
_NgtSobaGizmoAxisHead_changes$ = new WeakMap();
NgtSobaGizmoAxisHead.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoAxisHead, deps: [{ token: NGT_OBJECT_INPUTS_WATCHED_CONTROLLER }, { token: DOCUMENT }, { token: NgtSobaGizmoViewport }, { token: NgtSobaGizmoHelperStore }, { token: i1.NgtStore }, { token: i1.EnhancedRxState }], target: i0.ɵɵFactoryTarget.Component });
NgtSobaGizmoAxisHead.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: NgtSobaGizmoAxisHead, selector: "ngt-soba-gizmo-axis-head", inputs: { arcStyle: "arcStyle", label: "label", labelColor: "labelColor", axisHeadScale: "axisHeadScale", disabled: "disabled", font: "font" }, providers: [
        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
        EnhancedRxState,
        { provide: NgtSobaExtender, useExisting: NgtSobaGizmoAxisHead },
    ], usesInheritance: true, ngImport: i0, template: `
    <ng-container *ngIf="vm$ | async as vm">
      <ngt-sprite-material
        #spriteMaterial="ngtSpriteMaterial"
        [parameters]="{
          map: vm.texture,
          opacity: vm.opacity,
          toneMapped: false,
          alphaTest: 0.3
        }"
      ></ngt-sprite-material>
      <ngt-sprite
        (ready)="object = $event"
        (pointerover)="onAxisHeadPointerOver($event)"
        (pointerout)="onAxisHeadPointerOut($event)"
        (pointerdown)="onAxisHeadPointerDown($event)"
        [scale]="vm.scale"
        [material]="spriteMaterial.material"
        [object3dInputsController]="objectInputsController"
      ></ngt-sprite>
    </ng-container>
  `, isInline: true, directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i7.NgtSpriteMaterial, selector: "ngt-sprite-material", exportAs: ["ngtSpriteMaterial"] }, { type: i1.NgtObject3dController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera  ", exportAs: ["ngtObject3dController"] }, { type: i1.NgtObject3dInputsController, selector: "    ngt-primitive,    ngt-bone,    ngt-group,    ngt-lod,    ngt-points,    ngt-mesh,    ngt-instanced-mesh,    ngt-skinned-mesh,    ngt-audio,    ngt-positional-audio,    ngt-line,    ngt-line-loop,    ngt-line-segments,    ngt-light-probe,    ngt-ambient-light,    ngt-ambient-light-probe,    ngt-hemisphere-light,    ngt-hemisphere-light-probe,    ngt-directional-light,    ngt-point-light,    ngt-spot-light,    ngt-rect-area-light,    ngt-arrow-helper,    ngt-axes-helper,    ngt-box3-helper,    ngt-grid-helper,    ngt-plane-helper,    ngt-polar-grid-helper,    ngt-sprite,    ngt-camera,    ngt-perspective-camera,    ngt-orthographic-camera,    ngt-array-camera,    ngt-stereo-camera,    ngt-cube-camera,    ngt-soba-plane,    ngt-soba-box,    ngt-soba-cylinder,    ngt-soba-cone,    ngt-soba-circle,    ngt-soba-sphere,    ngt-soba-tube,    ngt-soba-torus,    ngt-soba-tetrahedron,    ngt-soba-ring,    ngt-soba-polyhedron,    ngt-soba-octahedron,    ngt-soba-dodecahedron,    ngt-soba-icosahedron,    ngt-soba-extrude,    ngt-soba-lathe,    ngt-soba-torus-knot,    ngt-soba-billboard,    ngt-soba-detailed,    ngt-soba-line,    ngt-soba-quadratic-bezier-line,    ngt-soba-cubic-bezier-line,    ngt-soba-orthographic-camera,    ngt-soba-gizmo-helper,    ngt-soba-gizmo-viewport,    ngt-soba-gizmo-axis-head,    ngt-soba-text  ", inputs: ["name", "position", "rotation", "quaternion", "scale", "color", "userData", "castShadow", "receiveShadow", "visible", "matrixAutoUpdate", "dispose", "raycast", "appendMode", "appendTo", "object3dInputsController"], outputs: ["click", "contextmenu", "dblclick", "pointerup", "pointerdown", "pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove", "pointermissed", "pointercancel", "wheel"], exportAs: ["ngtObject3dInputsController"] }, { type: i8.NgtSprite, selector: "ngt-sprite", exportAs: ["ngtSprite"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoAxisHead, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngt-soba-gizmo-axis-head',
                    template: `
    <ng-container *ngIf="vm$ | async as vm">
      <ngt-sprite-material
        #spriteMaterial="ngtSpriteMaterial"
        [parameters]="{
          map: vm.texture,
          opacity: vm.opacity,
          toneMapped: false,
          alphaTest: 0.3
        }"
      ></ngt-sprite-material>
      <ngt-sprite
        (ready)="object = $event"
        (pointerover)="onAxisHeadPointerOver($event)"
        (pointerout)="onAxisHeadPointerOut($event)"
        (pointerdown)="onAxisHeadPointerDown($event)"
        [scale]="vm.scale"
        [material]="spriteMaterial.material"
        [object3dInputsController]="objectInputsController"
      ></ngt-sprite>
    </ng-container>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        NGT_OBJECT_INPUTS_CONTROLLER_PROVIDER,
                        EnhancedRxState,
                        { provide: NgtSobaExtender, useExisting: NgtSobaGizmoAxisHead },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i1.NgtObject3dInputsController, decorators: [{
                    type: Inject,
                    args: [NGT_OBJECT_INPUTS_WATCHED_CONTROLLER]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: NgtSobaGizmoViewport }, { type: NgtSobaGizmoHelperStore }, { type: i1.NgtStore }, { type: i1.EnhancedRxState }]; }, propDecorators: { arcStyle: [{
                type: Input
            }], label: [{
                type: Input
            }], labelColor: [{
                type: Input
            }], axisHeadScale: [{
                type: Input
            }], disabled: [{
                type: Input
            }], font: [{
                type: Input
            }] } });
class NgtSobaGizmoViewportModule {
}
NgtSobaGizmoViewportModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoViewportModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgtSobaGizmoViewportModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoViewportModule, declarations: [NgtSobaGizmoViewport, NgtSobaGizmoAxis, NgtSobaGizmoAxisHead], imports: [CommonModule,
        NgtGroupModule,
        NgtSobaBoxModule,
        NgtMeshBasicMaterialModule,
        NgtSpriteModule,
        NgtSpriteMaterialModule,
        NgtMathPipeModule,
        NgtAmbientLightModule,
        NgtPointLightModule], exports: [NgtSobaGizmoViewport] });
NgtSobaGizmoViewportModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoViewportModule, imports: [[
            CommonModule,
            NgtGroupModule,
            NgtSobaBoxModule,
            NgtMeshBasicMaterialModule,
            NgtSpriteModule,
            NgtSpriteMaterialModule,
            NgtMathPipeModule,
            NgtAmbientLightModule,
            NgtPointLightModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: NgtSobaGizmoViewportModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgtSobaGizmoViewport, NgtSobaGizmoAxis, NgtSobaGizmoAxisHead],
                    exports: [NgtSobaGizmoViewport],
                    imports: [
                        CommonModule,
                        NgtGroupModule,
                        NgtSobaBoxModule,
                        NgtMeshBasicMaterialModule,
                        NgtSpriteModule,
                        NgtSpriteMaterialModule,
                        NgtMathPipeModule,
                        NgtAmbientLightModule,
                        NgtPointLightModule,
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { GenericController, ImageShaderMaterial, NGT_SOBA_LINE_INPUTS_CONTROLLER_PROVIDER, NGT_SOBA_LINE_INPUTS_WATCHED_CONTROLLER, NGT_VIEWCUBE_GENERIC_CONTROLLER_PROVIDER, NGT_VIEWCUBE_GENERIC_WATCHED_CONTROLLER, NgtSobaBillboard, NgtSobaBillboardModule, NgtSobaGizmoAxis, NgtSobaGizmoAxisHead, NgtSobaGizmoEdgecube, NgtSobaGizmoFaceMaterial, NgtSobaGizmoFacecube, NgtSobaGizmoHelper, NgtSobaGizmoHelperModule, NgtSobaGizmoHelperStore, NgtSobaGizmoViewcube, NgtSobaGizmoViewcubeModule, NgtSobaGizmoViewport, NgtSobaGizmoViewportModule, NgtSobaImage, NgtSobaImageModule, NgtSobaImageShaderMaterial, NgtSobaLine, NgtSobaLineInputsController, NgtSobaLineModule, NgtSobaPositionalAudio, NgtSobaPositionalAudioModule, NgtSobaPositionalAudioStore, NgtSobaQuadraticBezierLine, NgtSobaQuadraticBezierLineModule, NgtSobaText, NgtSobaTextModule };
//# sourceMappingURL=angular-three-soba-abstractions.mjs.map
